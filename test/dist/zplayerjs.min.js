(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["zPlayer"] = factory();
	else
		root["zPlayer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "<%=baseUrl%>/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _player = __webpack_require__(1);

	var _player2 = _interopRequireDefault(_player);

	var _utils = __webpack_require__(2);

	var _utils2 = _interopRequireDefault(_utils);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _container_plugin = __webpack_require__(109);

	var _container_plugin2 = _interopRequireDefault(_container_plugin);

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	var _ui_core_plugin = __webpack_require__(117);

	var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

	var _ui_container_plugin = __webpack_require__(104);

	var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	var _container = __webpack_require__(22);

	var _container2 = _interopRequireDefault(_container);

	var _core = __webpack_require__(13);

	var _core2 = _interopRequireDefault(_core);

	var _loader = __webpack_require__(91);

	var _loader2 = _interopRequireDefault(_loader);

	var _mediator = __webpack_require__(53);

	var _mediator2 = _interopRequireDefault(_mediator);

	var _player_info = __webpack_require__(54);

	var _player_info2 = _interopRequireDefault(_player_info);

	var _html5_video = __webpack_require__(93);

	var _html5_video2 = _interopRequireDefault(_html5_video);

	var _youtube = __webpack_require__(188);

	var _youtube2 = _interopRequireDefault(_youtube);

	var _no_op = __webpack_require__(98);

	var _no_op2 = _interopRequireDefault(_no_op);

	var _poster = __webpack_require__(179);

	var _poster2 = _interopRequireDefault(_poster);

	var _log = __webpack_require__(6);

	var _log2 = _interopRequireDefault(_log);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _vendor = __webpack_require__(8);

	var _vendor2 = _interopRequireDefault(_vendor);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// import HLS from 'playbacks/hls';

	// import MediaControl from 'components/media_control'

	// import Browser from 'components/browser'
	// Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var version = ("0.0.1");

	// Utils

	// import HTMLImg from 'playbacks/html_img'

	// import HTML5Audio from 'playbacks/html5_audio'

	var DEBUG_KEY = 'zplayer-debug';

	var debug = function debug() {
	  window.localStorage.setItem(DEBUG_KEY, true);
	  window.location.reload();
	};

	var stopDebug = function stopDebug() {
	  if (isDebugging()) {
	    window.localStorage.setItem(DEBUG_KEY, false);
	    window.location.reload();
	  }
	};

	var isDebugging = function isDebugging() {
	  var currentDebugState = window.localStorage.getItem(DEBUG_KEY);
	  return currentDebugState == 'true';
	};

	exports.default = {
	  Player: _player2.default,
	  YoutubePlayback: _youtube2.default,
	  // HLS,
	  Events: _events2.default,
	  debug: debug,
	  stopDebug: stopDebug
	};
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _core_factory = __webpack_require__(11);

	var _core_factory2 = _interopRequireDefault(_core_factory);

	var _loader = __webpack_require__(91);

	var _loader2 = _interopRequireDefault(_loader);

	var _player_info = __webpack_require__(54);

	var _player_info2 = _interopRequireDefault(_player_info);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var baseUrl = (0, _utils.currentScriptUrl)().replace(/\/[^\/]+$/, '');

	var Player = function (_BaseObject) {
	  _inherits(Player, _BaseObject);

	  _createClass(Player, [{
	    key: 'loader',
	    set: function set(loader) {
	      this._loader = loader;
	    },
	    get: function get() {
	      if (!this._loader) {
	        this._loader = new _loader2.default(this.options.plugins || {}, this.options.playerId);
	      }
	      return this._loader;
	    }
	  }, {
	    key: 'ended',
	    get: function get() {
	      return this.core.mediaControl.container.ended;
	    }
	  }, {
	    key: 'buffering',
	    get: function get() {
	      return this.core.mediaControl.container.buffering;
	    }
	  }, {
	    key: 'isReady',
	    get: function get() {
	      return !!this._ready;
	    }
	  }, {
	    key: 'eventsMapping',
	    get: function get() {
	      return {
	        onReady: _events2.default.PLAYER_READY,
	        onResize: _events2.default.PLAYER_RESIZE,
	        onPlay: _events2.default.PLAYER_PLAY,
	        onNext: _events2.default.PLAYER_NEXT,
	        onCloseAds: _events2.default.PLAYER_CLOSEADS,
	        onPrev: _events2.default.PLAYER_PREV,
	        onPause: _events2.default.PLAYER_PAUSE,
	        onStop: _events2.default.PLAYER_STOP,
	        onEnded: _events2.default.PLAYER_ENDED,
	        onSeek: _events2.default.PLAYER_SEEK,
	        onError: _events2.default.PLAYER_ERROR,
	        onTimeUpdate: _events2.default.PLAYER_TIMEUPDATE,
	        onVolumeUpdate: _events2.default.PLAYER_VOLUMEUPDATE
	      };
	    }
	  }]);

	  function Player(options) {
	    _classCallCheck(this, Player);

	    var _this = _possibleConstructorReturn(this, _BaseObject.call(this, options));

	    var defaultOptions = {
	      playerId: (0, _utils.uniqueId)(''),
	      persistConfig: true,
	      width: 640,
	      height: 360,
	      baseUrl: baseUrl,
	      allowUserInteraction: _browser2.default.isMobile
	    };
	    // Check if any instance of player already created
	    if (window.hasAnPlayerInstance) {
	      _this.options.hasAnPlayerInstance = false;
	    } else {
	      _this.options.hasAnPlayerInstance = false;
	      window.hasAnPlayerInstance = true;
	    }

	    _this._options = _clapprZepto2.default.extend(defaultOptions, options);
	    _this.options.sources = _this._normalizeSources(options);
	    if (!_this.options.chromeless) {
	      // "allowUserInteraction" cannot be false if not in chromeless mode.
	      _this.options.allowUserInteraction = true;
	    }
	    if (!_this.options.allowUserInteraction) {
	      // if user iteraction is not allowed ensure keyboard shortcuts are disabled
	      _this.options.disableKeyboardShortcuts = true;
	    }
	    _this._registerOptionEventListeners();
	    _this._coreFactory = new _core_factory2.default(_this);
	    _this.playerInfo = _player_info2.default.getInstance(_this.options.playerId);
	    _this.playerInfo.currentSize = { width: options.width, height: options.height };
	    _this.playerInfo.options = _this.options;
	    if (_this.options.parentId) {
	      _this.setParentId(_this.options.parentId);
	    } else if (_this.options.parent) {
	      _this.attachTo(_this.options.parent);
	    }

	    return _this;
	  }

	  Player.prototype.setParentId = function setParentId(parentId) {
	    var el = document.querySelector(parentId);
	    if (el) {
	      this.attachTo(el);
	    }
	    return this;
	  };

	  Player.prototype.attachTo = function attachTo(element) {
	    this.options.parentElement = element;
	    this.core = this._coreFactory.create();
	    this._addEventListeners();
	    return this;
	  };

	  Player.prototype._addEventListeners = function _addEventListeners() {
	    if (!this.core.isReady) {
	      this.listenToOnce(this.core, _events2.default.CORE_READY, this._onReady);
	    } else {
	      this._onReady();
	    }
	    this.listenTo(this.core.mediaControl, _events2.default.MC_CONTAINERCHANGED, this._containerChanged);
	    this.listenTo(this.core, _events2.default.CORE_FULLSCREEN, this._onFullscreenChange);
	    return this;
	  };

	  Player.prototype._addContainerEventListeners = function _addContainerEventListeners() {
	    var container = this.core.mediaControl.container;
	    this.listenTo(this.core, _events2.default.CORE_CANTPLAY, this._onCanPlay);
	    if (container) {
	      this.listenTo(container, _events2.default.CT_PLAY, this._onPlay);
	      this.listenTo(container, _events2.default.CT_CLOSEADS, this._oncloseAds);
	      this.listenTo(container, _events2.default.CT_NEXT, this._onnext);
	      this.listenTo(container, _events2.default.CT_PREV, this._onprev);
	      this.listenTo(container, _events2.default.CT_CLICK, this._onScreenClick);
	      this.listenTo(container, _events2.default.CT_SHOW, this._onShowMenu);
	      this.listenTo(container, _events2.default.CT_PLAYITEM, this._onplayItem);
	      this.listenTo(container, _events2.default.CT_PAUSE, this._onPause);
	      this.listenTo(container, _events2.default.CT_STOP, this._onStop);
	      this.listenTo(container, _events2.default.CT_ENDED, this._onEnded);
	      this.listenTo(container, _events2.default.CT_SEEK, this._onSeek);
	      this.listenTo(container, _events2.default.CT_ERROR, this._onError);
	      this.listenTo(container, _events2.default.CT_TIMEUPDATE, this._onTimeUpdate);
	      this.listenTo(container, _events2.default.CT_VOLUME, this._onVolumeUpdate);
	      this.listenTo(container, _events2.default.CT_UPDATE_SONG_MODE, this._onSongMode);
	      this.listenTo(container, _events2.default.CT_SELECTLEVEL, this._onSelectLevel);
	      this.listenTo(container, _events2.default.CT_CANCEL_PLAYNEXT, this._onCancelPlayNext);
	      this.listenTo(container, _events2.default.CT_CLICK_PLAYNEXT, this._onClickPlayNext);
	      this.listenTo(container, _events2.default.CT_CHANGE_AD_MODE, this._onChangeAdMode);
	      this.listenTo(container, _events2.default.CT_START_LINEAR_AD, this._onPlay);
	      this.listenTo(container, _events2.default.CT_FINISH_LINEAR_AD, this._onFinishLinearAd);
	      this.listenTo(container, _events2.default.CT_PRESS_PAUSE, this._onPressPause);
	      this.listenTo(container, _events2.default.CT_PRESS_PLAY, this._onPressPlay);
	    }
	    return this;
	  };

	  Player.prototype._registerOptionEventListeners = function _registerOptionEventListeners() {
	    var _this2 = this;

	    var userEvents = this.options.events || {};
	    Object.keys(userEvents).forEach(function (userEvent) {
	      var eventType = _this2.eventsMapping[userEvent];
	      if (eventType) {
	        var eventFunction = userEvents[userEvent];
	        eventFunction = typeof eventFunction === 'function' && eventFunction;
	        eventFunction && _this2.on(eventType, eventFunction);
	      }
	    });
	    return this;
	  };

	  Player.prototype._containerChanged = function _containerChanged() {
	    this.stopListening();
	    this._addEventListeners();
	  };

	  Player.prototype._onReady = function _onReady() {
	    if (!this._ready) {
	      this.trigger(_events2.default.PLAYER_READY);
	    }
	    this._ready = true;
	    this._addContainerEventListeners();
	  };

	  Player.prototype._onFullscreenChange = function _onFullscreenChange(fullscreen) {
	    this.trigger(_events2.default.PLAYER_FULLSCREEN, fullscreen);
	  };

	  Player.prototype._onVolumeUpdate = function _onVolumeUpdate(volume) {
	    this.trigger(_events2.default.PLAYER_VOLUMEUPDATE, volume);
	  };

	  Player.prototype._oncloseAds = function _oncloseAds() {
	    this.trigger(_events2.default.PLAYER_CLOSEADS);
	  };

	  Player.prototype._onPlay = function _onPlay(e) {
	    this.trigger(_events2.default.PLAYER_PLAY, e);
	  };

	  Player.prototype._onFinishLinearAd = function _onFinishLinearAd() {
	    this.trigger(_events2.default.PLAYER_STOP_LINEAR_AD);
	  };

	  Player.prototype._onPressPause = function _onPressPause() {
	    this.trigger(_events2.default.PLAYER_PRESS_PAUSE);
	  };

	  Player.prototype._onPressPlay = function _onPressPlay() {
	    this.trigger(_events2.default.PLAYER_PRESS_PLAY);
	  };

	  Player.prototype._onPause = function _onPause() {
	    this.trigger(_events2.default.PLAYER_PAUSE);
	  };

	  Player.prototype._onnext = function _onnext() {
	    this.trigger(_events2.default.PLAYER_NEXT);
	  };

	  Player.prototype._onprev = function _onprev() {
	    this.trigger(_events2.default.PLAYER_PREV);
	  };

	  Player.prototype._onScreenClick = function _onScreenClick() {
	    this.trigger(_events2.default.PLAYER_CLICK_SCREEN);
	  };

	  Player.prototype._onShowMenu = function _onShowMenu() {
	    this.trigger(_events2.default.PLAYER_SHOW_MENU);
	  };

	  Player.prototype._onplayItem = function _onplayItem(index) {
	    this.trigger(_events2.default.PLAYER_PLAYITEM, index);
	  };

	  Player.prototype._onStop = function _onStop() {
	    this.trigger(_events2.default.PLAYER_STOP, this.getCurrentTime());
	  };

	  Player.prototype._onEnded = function _onEnded() {
	    this.trigger(_events2.default.PLAYER_ENDED);
	  };

	  Player.prototype._onSeek = function _onSeek(time) {
	    this.trigger(_events2.default.PLAYER_SEEK, time);
	  };

	  Player.prototype._onCanPlay = function _onCanPlay(index) {
	    this.trigger(_events2.default.PLAYER_CANTPLAY, index);
	  };

	  Player.prototype._onSongMode = function _onSongMode(e) {
	    this.trigger(_events2.default.PLAYER_UPDATE_SONG_MODE, e);
	  };

	  Player.prototype._onSelectLevel = function _onSelectLevel(e) {
	    this.trigger(_events2.default.PLAYER_SELECT_LEVEL, e);
	  };

	  Player.prototype._onClickPlayNext = function _onClickPlayNext(e) {
	    this.trigger(_events2.default.PLAYER_CLICK_PLAYNEXT, e);
	  };

	  Player.prototype._onCancelPlayNext = function _onCancelPlayNext(e) {
	    this.trigger(_events2.default.PLAYER_CANCEL_PLAYNEXT, e);
	  };

	  Player.prototype._onChangeAdMode = function _onChangeAdMode(e) {
	    this.trigger(_events2.default.PLAYER_CHANGE_AD_MODE, e);
	  };

	  Player.prototype._onTimeUpdate = function _onTimeUpdate(timeProgress) {
	    this.trigger(_events2.default.PLAYER_TIMEUPDATE, timeProgress);
	  };

	  Player.prototype._onError = function _onError(error) {
	    this.trigger(_events2.default.PLAYER_ERROR, error);
	  };

	  Player.prototype._normalizeSources = function _normalizeSources(options) {
	    var sources = options.sources || (options.sources !== undefined ? options.sources : []);
	    return sources.length === 0 ? [{ source: '', mimeType: '' }] : sources;
	  };

	  Player.prototype.resize = function resize(size) {
	    this.core.resize(size);
	    return this;
	  };

	  Player.prototype.load = function load(sources, mimeType, autoPlay) {
	    if (autoPlay !== undefined) {
	      this.configure({ autoPlay: !!autoPlay });
	    }
	    this.core.load(sources, mimeType);
	    return this;
	  };

	  Player.prototype.destroy = function destroy() {
	    this.core.destroy();
	    return this;
	  };

	  Player.prototype.play = function play() {
	    this.core.mediaControl.container.play();
	    return this;
	  };

	  Player.prototype.pause = function pause() {
	    this.core.mediaControl.container.pause();
	    return this;
	  };

	  Player.prototype.clear = function clear() {
	    return this;
	  };

	  Player.prototype.stop = function stop() {
	    this.core.mediaControl.container.stop();
	    return this;
	  };

	  Player.prototype.pauseAd = function pauseAd() {
	    this.core.mediaControl.container.trigger(_events2.default.CT_PAUSE_AD);
	    return this;
	  };

	  Player.prototype.playAd = function playAd() {
	    this.core.mediaControl.container.trigger(_events2.default.CT_PLAY_AD);
	    return this;
	  };

	  Player.prototype.seek = function seek(time) {
	    this.core.mediaControl.container.seek(time);
	    return this;
	  };

	  Player.prototype.seekPercentage = function seekPercentage(percentage) {
	    this.core.mediaControl.container.seekPercentage(percentage);
	    return this;
	  };

	  Player.prototype.setVolume = function setVolume(volume) {
	    if (this.core && this.core.mediaControl) {
	      this.core.mediaControl.setVolume(volume);
	    }
	    return this;
	  };

	  Player.prototype.setSongMode = function setSongMode(songMode) {
	    if (this.core && this.core.mediaControl) {
	      this.core.mediaControl.setSongMode(songMode);
	    }
	    return this;
	  };

	  Player.prototype.hideNextButton = function hideNextButton() {
	    this.core.mediaControl.hideNextButton();
	  };

	  Player.prototype.hidePrevButton = function hidePrevButton() {
	    this.core.mediaControl.hidePrevButton();
	  };

	  Player.prototype.showNextButton = function showNextButton() {
	    this.core.mediaControl.showNextButton();
	  };

	  Player.prototype.showPrevButton = function showPrevButton() {
	    this.core.mediaControl.showPrevButton();
	  };

	  Player.prototype.getVolume = function getVolume() {
	    return this.core && this.core.mediaControl ? this.core.mediaControl.volume : 0;
	  };

	  Player.prototype.mute = function mute() {
	    this._mutedVolume = this.getVolume();
	    this.setVolume(0);
	    return this;
	  };

	  Player.prototype.unmute = function unmute() {
	    this.setVolume(typeof this._mutedVolume === 'number' ? this._mutedVolume : 100);
	    if (this.core.mediaControl.container.playback) {
	      this.core.mediaControl.container.playback.el.muted = false;
	    }
	    this._mutedVolume = null;
	    return this;
	  };

	  Player.prototype.isPlaying = function isPlaying() {
	    return this.core.mediaControl.container.isPlaying();
	  };

	  Player.prototype.isDvrEnabled = function isDvrEnabled() {
	    return this.core.mediaControl.container.isDvrEnabled();
	  };

	  Player.prototype.isDvrInUse = function isDvrInUse() {
	    return this.core.mediaControl.container.isDvrInUse();
	  };

	  Player.prototype.configure = function configure(options) {
	    this.core.configure(options);
	    return this;
	  };

	  Player.prototype.getPlugin = function getPlugin(name) {
	    var plugins = this.core.plugins.concat(this.core.mediaControl.container.plugins);
	    return (0, _arrayPrototype2.default)(plugins, function (plugin) {
	      return plugin.name === name;
	    });
	  };

	  Player.prototype.next = function next() {
	    var playlistPlugin = this.getPlugin("playlist");
	    playlistPlugin.next();
	  };

	  Player.prototype.prev = function prev() {
	    var playlistPlugin = this.getPlugin("playlist");
	    playlistPlugin.prev();
	  };

	  Player.prototype.playItem = function playItem(index) {
	    var playlistPlugin = this.getPlugin("playlist");
	    playlistPlugin.playItem(index);
	  };

	  Player.prototype.getCurrentTime = function getCurrentTime() {
	    return this.core.mediaControl.container.getCurrentTime();
	  };

	  Player.prototype.getStartTimeOffset = function getStartTimeOffset() {
	    return this.core.mediaControl.container.getStartTimeOffset();
	  };

	  Player.prototype.getDuration = function getDuration() {
	    return this.core.mediaControl.container.getDuration();
	  };

	  Player.prototype.setSongPlayMode = function setSongPlayMode(index) {
	    this.core.mediaControl.setSongMode(index);
	  };

	  Player.prototype.setSource = function setSource(sourceUrl) {
	    if (sourceUrl && sourceUrl !== '') {
	      var currentTime = this.core.mediaControl.container.playback.el.currentTime;
	      var playback = this.core.mediaControl.container.playback;
	      playback._setupSrc(sourceUrl);
	      playback.seek(currentTime);
	    }
	    return this;
	  };

	  Player.prototype.playNext = function playNext(item) {
	    this.core.mediaControl.playNext(item);
	  };

	  return Player;
	}(_base_object2.default);

	exports.default = Player;


	Player.REPEAT_SONG = 0;
	Player.NO_REPEAT_SONG = 1;
	module.exports = exports['default'];

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.QueryString = exports.Config = exports.Fullscreen = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.extend = extend;
	exports.formatTime = formatTime;
	exports.seekStringToSeconds = seekStringToSeconds;
	exports.uniqueId = uniqueId;
	exports.isNumber = isNumber;
	exports.convertToSecond = convertToSecond;
	exports.currentScriptUrl = currentScriptUrl;
	exports.getBrowserLanguage = getBrowserLanguage;
	exports.now = now;
	exports.removeArrayItem = removeArrayItem;
	exports.uniqBy = uniqBy;

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function assign(obj, source) {
	    if (source) {
	        for (var prop in source) {
	            var propDescriptor = Object.getOwnPropertyDescriptor(source, prop);
	            propDescriptor ? Object.defineProperty(obj, prop, propDescriptor) : obj[prop] = source[prop];
	        }
	    }
	    return obj;
	}

	function extend(parent, properties) {
	    var Surrogate = function (_parent) {
	        _inherits(Surrogate, _parent);

	        function Surrogate() {
	            _classCallCheck(this, Surrogate);

	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            var _this = _possibleConstructorReturn(this, _parent.call.apply(_parent, [this].concat(args)));

	            if (properties.initialize) {
	                properties.initialize.apply(_this, args);
	            }
	            return _this;
	        }

	        return Surrogate;
	    }(parent);

	    assign(Surrogate.prototype, properties);
	    return Surrogate;
	}

	function formatTime(time, paddedHours) {
	    if (!isFinite(time)) {
	        return '--:--';
	    }
	    time = time * 1000;
	    time = parseInt(time / 1000);
	    var seconds = time % 60;
	    time = parseInt(time / 60);
	    var minutes = time % 60;
	    time = parseInt(time / 60);
	    var hours = time % 24;
	    var days = parseInt(time / 24);
	    var out = '';
	    if (days && days > 0) {
	        out += days + ':';
	        if (hours < 1) {
	            out += '00:';
	        }
	    }
	    if (hours && hours > 0 || paddedHours) {
	        out += ('0' + hours).slice(-2) + ':';
	    }
	    out += ('0' + minutes).slice(-2) + ':';
	    out += ('0' + seconds).slice(-2);
	    return out.trim();
	}

	var Fullscreen = exports.Fullscreen = {
	    isFullscreen: function isFullscreen() {
	        return !!(document.webkitFullscreenElement || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement);
	    },
	    requestFullscreen: function requestFullscreen(el) {
	        if (el.requestFullscreen) {
	            el.requestFullscreen();
	        } else if (el.webkitRequestFullscreen) {
	            el.webkitRequestFullscreen();
	        } else if (el.mozRequestFullScreen) {
	            el.mozRequestFullScreen();
	        } else if (el.msRequestFullscreen) {
	            el.msRequestFullscreen();
	        } else if (el.querySelector && el.querySelector('video') && el.querySelector('video').webkitEnterFullScreen) {
	            el.querySelector('video').webkitEnterFullScreen();
	        }
	    },
	    cancelFullscreen: function cancelFullscreen() {
	        if (document.exitFullscreen) {
	            document.exitFullscreen();
	        } else if (document.webkitCancelFullScreen) {
	            document.webkitCancelFullScreen();
	        } else if (document.webkitExitFullscreen) {
	            document.webkitExitFullscreen();
	        } else if (document.mozCancelFullScreen) {
	            document.mozCancelFullScreen();
	        } else if (document.msExitFullscreen) {
	            document.msExitFullscreen();
	        }
	    },
	    fullscreenEnabled: function fullscreenEnabled() {
	        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
	    }
	};

	var Config = exports.Config = function () {
	    function Config() {
	        _classCallCheck(this, Config);
	    }

	    Config._defaultConfig = function _defaultConfig() {
	        return {
	            volume: {
	                value: 100,
	                parse: parseInt
	            }
	        };
	    };

	    Config._defaultValueFor = function _defaultValueFor(key) {
	        try {
	            return this._defaultConfig()[key].parse(this._defaultConfig()[key].value);
	        } catch (e) {
	            return undefined;
	        }
	    };

	    Config._createKeyspace = function _createKeyspace(key) {
	        return 'zplayer.' + document.domain + '.' + key;
	    };

	    Config.restore = function restore(key) {
	        if (_browser2.default.hasLocalstorage && localStorage[this._createKeyspace(key)]) {
	            return this._defaultConfig()[key].parse(localStorage[this._createKeyspace(key)]);
	        }
	        return this._defaultValueFor(key);
	    };

	    Config.persist = function persist(key, value) {
	        if (_browser2.default.hasLocalstorage) {
	            try {
	                localStorage[this._createKeyspace(key)] = value;
	                return true;
	            } catch (e) {
	                return false;
	            }
	        }
	    };

	    return Config;
	}();

	var QueryString = exports.QueryString = function () {
	    function QueryString() {
	        _classCallCheck(this, QueryString);
	    }

	    QueryString.parse = function parse(paramsString) {
	        var match = void 0;
	        var pl = /\+/g,
	            // Regex for replacing addition symbol with a space
	        search = /([^&=]+)=?([^&]*)/g,
	            decode = function decode(s) {
	            return decodeURIComponent(s.replace(pl, ' '));
	        },
	            params = {};
	        while (match = search.exec(paramsString)) {
	            // eslint-disable-line no-cond-assign
	            params[decode(match[1]).toLowerCase()] = decode(match[2]);
	        }
	        return params;
	    };

	    _createClass(QueryString, null, [{
	        key: 'params',
	        get: function get() {
	            var query = window.location.search.substring(1);
	            if (query !== this.query) {
	                this._urlParams = this.parse(query);
	                this.query = query;
	            }
	            return this._urlParams;
	        }
	    }, {
	        key: 'hashParams',
	        get: function get() {
	            var hash = window.location.hash.substring(1);
	            if (hash !== this.hash) {
	                this._hashParams = this.parse(hash);
	                this.hash = hash;
	            }
	            return this._hashParams;
	        }
	    }]);

	    return QueryString;
	}();

	function seekStringToSeconds() {
	    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 't';

	    var seconds = 0;
	    var seekString = QueryString.params[paramName] || QueryString.hashParams[paramName] || '';
	    var parts = seekString.match(/[0-9]+[hms]+/g) || [];
	    if (parts.length > 0) {
	        (function () {
	            var factor = { 'h': 3600, 'm': 60, 's': 1 };
	            parts.forEach(function (el) {
	                if (el) {
	                    var suffix = el[el.length - 1];
	                    var time = parseInt(el.slice(0, el.length - 1), 10);
	                    seconds += time * factor[suffix];
	                }
	            });
	        })();
	    } else if (seekString) {
	        seconds = parseInt(seekString, 10);
	    }
	    return seconds;
	}

	var idsCounter = {};

	function uniqueId(prefix) {
	    idsCounter[prefix] || (idsCounter[prefix] = 0);
	    var id = ++idsCounter[prefix];
	    return prefix + id;
	}

	function isNumber(value) {
	    return value - parseFloat(value) + 1 >= 0;
	}

	function convertToSecond(hms) {
	    var hms = hms.split(':');
	    return +hms[0] * 60 * 60 + +hms[1] * 60 + +hms[2];
	}

	function currentScriptUrl() {
	    var scripts = document.getElementsByTagName('script');
	    return scripts[scripts.length - 1].src;
	}

	var requestAnimationFrame = exports.requestAnimationFrame = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
	    window.setTimeout(fn, 1000 / 60);
	}).bind(window);

	var cancelAnimationFrame = exports.cancelAnimationFrame = (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout).bind(window);

	function getBrowserLanguage() {
	    return window.navigator && window.navigator.language;
	}

	function now() {
	    return new Date();
	}

	// remove the item from the array if it exists in the array
	function removeArrayItem(arr, item) {
	    var i = arr.indexOf(item);
	    if (i >= 0) {
	        arr.splice(i, 1);
	    }
	}

	function uniqBy(arr, predicate) {
	    var cb = typeof predicate === 'function' ? predicate : function (o) {
	        return o[predicate];
	    };

	    return [].concat(_toConsumableArray(arr.reduce(function (map, item) {
	        var key = cb(item);

	        map.has(key) || map.set(key, item);

	        return map;
	    }, new Map()).values()));
	}

	/*	This work is licensed under Creative Commons GNU LGPL License.

	 License: http://creativecommons.org/licenses/LGPL/2.1/
	 Version: 0.9
	 Author:  Stefan Goessner/2006
	 Web:     http://goessner.net/
	 */

	exports.default = {
	    Config: Config,
	    Fullscreen: Fullscreen,
	    QueryString: QueryString,
	    extend: extend,
	    formatTime: formatTime,
	    seekStringToSeconds: seekStringToSeconds,
	    uniqueId: uniqueId,
	    currentScriptUrl: currentScriptUrl,
	    isNumber: isNumber,
	    requestAnimationFrame: requestAnimationFrame,
	    cancelAnimationFrame: cancelAnimationFrame,
	    getBrowserLanguage: getBrowserLanguage,
	    now: now,
	    removeArrayItem: removeArrayItem,
	    convertToSecond: convertToSecond,
	    uniqBy: uniqBy
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var Browser = {};

	var hasLocalstorage = function hasLocalstorage() {
	    try {
	        localStorage.setItem('zplayer', 'zplayer');
	        localStorage.removeItem('zplayer');
	        return true;
	    } catch (e) {
	        return false;
	    }
	};

	var hasFlash = function hasFlash() {
	    try {
	        var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
	        return !!fo;
	    } catch (e) {
	        return !!(navigator.mimeTypes && navigator.mimeTypes['application/x-shockwave-flash'] !== undefined && navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin);
	    }
	};

	var getBrowserInfo = function getBrowserInfo() {
	    var ua = navigator.userAgent;
	    var parts = ua.match(/\b(playstation 4|nx|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [],
	        extra = void 0;
	    if (/trident/i.test(parts[1])) {
	        extra = /\brv[ :]+(\d+)/g.exec(ua) || [];
	        return { name: 'IE', version: parseInt(extra[1] || '') };
	    } else if (parts[1] === 'Chrome') {
	        extra = ua.match(/\bOPR\/(\d+)/);
	        if (extra != null) {
	            return { name: 'Opera', version: parseInt(extra[1]) };
	        }
	    }
	    parts = parts[2] ? [parts[1], parts[2]] : [navigator.appName, navigator.appVersion, '-?'];

	    if (extra = ua.match(/version\/(\d+)/i)) {
	        parts.splice(1, 1, extra[1]);
	    }
	    return { name: parts[0], version: parseInt(parts[1]) };
	};

	var browserInfo = getBrowserInfo();

	Browser.isSafari = /safari/i.test(navigator.userAgent) && navigator.userAgent.indexOf('Chrome') === -1;
	Browser.isChrome = /chrome/i.test(navigator.userAgent);
	Browser.isFirefox = /firefox/i.test(navigator.userAgent);
	Browser.isLegacyIE = !!window.ActiveXObject;
	Browser.isIE = Browser.isLegacyIE || /trident.*rv:1\d/i.test(navigator.userAgent);
	Browser.isIE11 = /trident.*rv:11/i.test(navigator.userAgent);
	Browser.isChromecast = Browser.isChrome && /CrKey/i.test(navigator.userAgent);
	Browser.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone|IEMobile|Opera Mini/i.test(navigator.userAgent);
	Browser.isiOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
	Browser.isAndroid = /Android/i.test(navigator.userAgent);
	Browser.isWindowsPhone = /Windows Phone/i.test(navigator.userAgent);
	Browser.isWin8App = /MSAppHost/i.test(navigator.userAgent);
	Browser.isWiiU = /WiiU/i.test(navigator.userAgent);
	Browser.isPS4 = /PlayStation 4/i.test(navigator.userAgent);
	Browser.hasLocalstorage = hasLocalstorage();
	Browser.hasFlash = hasFlash();

	Browser.name = browserInfo.name;
	Browser.version = browserInfo.version;

	exports.default = Browser;
	module.exports = exports['default'];

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var BaseObject = function (_Events) {
	    _inherits(BaseObject, _Events);

	    _createClass(BaseObject, [{
	        key: 'product',
	        get: function get() {
	            return 'zingmp3';
	        }
	    }, {
	        key: 'options',
	        get: function get() {
	            return this._options;
	        }
	    }]);

	    function BaseObject() {
	        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        _classCallCheck(this, BaseObject);

	        var _this = _possibleConstructorReturn(this, _Events.call(this, options));

	        _this._options = options;
	        _this.uniqueId = (0, _utils.uniqueId)('o');
	        return _this;
	    }

	    return BaseObject;
	}(_events2.default);

	exports.default = BaseObject;
	module.exports = exports['default'];

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _log = __webpack_require__(6);

	var _log2 = _interopRequireDefault(_log);

	var _utils = __webpack_require__(2);

	var _lodash = __webpack_require__(10);

	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var slice = Array.prototype.slice;

	var eventSplitter = /\s+/;

	var eventsApi = function eventsApi(obj, action, name, rest) {
	    if (!name) {
	        return true;
	    }

	    // Handle event maps.
	    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	        for (var key in name) {
	            obj[action].apply(obj, [key, name[key]].concat(rest));
	        }
	        return false;
	    }

	    // Handle space separated event names.
	    if (eventSplitter.test(name)) {
	        var names = name.split(eventSplitter);
	        for (var i = 0, l = names.length; i < l; i++) {
	            obj[action].apply(obj, [names[i]].concat(rest));
	        }
	        return false;
	    }

	    return true;
	};

	var triggerEvents = function triggerEvents(events, args, klass, name) {
	    var ev = void 0,
	        i = -1;
	    var l = events.length,
	        a1 = args[0],
	        a2 = args[1],
	        a3 = args[2];
	    run();

	    function run() {
	        try {
	            switch (args.length) {
	                case 0:
	                    while (++i < l) {
	                        (ev = events[i]).callback.call(ev.ctx);
	                    }
	                    return;
	                case 1:
	                    while (++i < l) {
	                        (ev = events[i]).callback.call(ev.ctx, a1);
	                    }
	                    return;
	                case 2:
	                    while (++i < l) {
	                        (ev = events[i]).callback.call(ev.ctx, a1, a2);
	                    }
	                    return;
	                case 3:
	                    while (++i < l) {
	                        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
	                    }
	                    return;
	                default:
	                    while (++i < l) {
	                        (ev = events[i]).callback.apply(ev.ctx, args);
	                    }
	                    return;
	            }
	        } catch (exception) {
	            _log2.default.error.apply(_log2.default, [klass, 'error on event', name, 'trigger', '-', exception]);
	            run();
	        }
	    }
	};

	var Events = function () {
	    function Events() {
	        _classCallCheck(this, Events);
	    }

	    Events.prototype.on = function on(name, callback, context) {
	        if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {
	            return this;
	        }
	        this._events || (this._events = {});
	        var events = this._events[name] || (this._events[name] = []);
	        events.push({ callback: callback, context: context, ctx: context || this });
	        return this;
	    };

	    Events.prototype.once = function once(name, callback, context) {
	        if (!eventsApi(this, 'once', name, [callback, context]) || !callback) {
	            return this;
	        }
	        var self = this;
	        var once = (0, _lodash2.default)(function () {
	            self.off(name, once);
	            callback.apply(this, arguments);
	        });
	        once._callback = callback;
	        return this.on(name, once, context);
	    };

	    Events.prototype.off = function off(name, callback, context) {
	        var retain = void 0,
	            ev = void 0,
	            events = void 0,
	            names = void 0,
	            i = void 0,
	            l = void 0,
	            j = void 0,
	            k = void 0;
	        if (!this._events || !eventsApi(this, 'off', name, [callback, context])) {
	            return this;
	        }
	        if (!name && !callback && !context) {
	            this._events = void 0;
	            return this;
	        }
	        names = name ? [name] : Object.keys(this._events);
	        // jshint maxdepth:5
	        for (i = 0, l = names.length; i < l; i++) {
	            name = names[i];
	            events = this._events[name];
	            if (events) {
	                this._events[name] = retain = [];
	                if (callback || context) {
	                    for (j = 0, k = events.length; j < k; j++) {
	                        ev = events[j];
	                        if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
	                            retain.push(ev);
	                        }
	                    }
	                }
	                if (!retain.length) {
	                    delete this._events[name];
	                }
	            }
	        }
	        return this;
	    };

	    Events.prototype.trigger = function trigger(name) {
	        var klass = this.name || this.constructor.name;
	        _log2.default.debug.apply(_log2.default, [klass].concat(Array.prototype.slice.call(arguments)));
	        if (!this._events) {
	            return this;
	        }
	        var args = slice.call(arguments, 1);
	        if (!eventsApi(this, 'trigger', name, args)) {
	            return this;
	        }
	        var events = this._events[name];
	        var allEvents = this._events.all;
	        if (events) {
	            triggerEvents(events, args, klass, name);
	        }
	        if (allEvents) {
	            triggerEvents(allEvents, arguments, klass, name);
	        }
	        return this;
	    };

	    Events.prototype.stopListening = function stopListening(obj, name, callback) {
	        var listeningTo = this._listeningTo;
	        if (!listeningTo) {
	            return this;
	        }
	        var remove = !name && !callback;
	        if (!callback && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	            callback = this;
	        }
	        if (obj) {
	            (listeningTo = {})[obj._listenId] = obj;
	        }
	        for (var id in listeningTo) {
	            obj = listeningTo[id];
	            obj.off(name, callback, this);
	            if (remove || Object.keys(obj._events).length === 0) {
	                delete this._listeningTo[id];
	            }
	        }
	        return this;
	    };

	    return Events;
	}();

	exports.default = Events;


	var listenMethods = { listenTo: 'on', listenToOnce: 'once' };

	Object.keys(listenMethods).forEach(function (method) {
	    Events.prototype[method] = function (obj, name, callback) {
	        var listeningTo = this._listeningTo || (this._listeningTo = {});
	        var id = obj._listenId || (obj._listenId = (0, _utils.uniqueId)('l'));
	        listeningTo[id] = obj;
	        if (!callback && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	            callback = this;
	        }
	        obj[listenMethods[method]](name, callback, this);
	        return this;
	    };
	});
	// eval(decodeURIComponent('%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%52%45%53%49%5a%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%32%25%36%35%25%37%33%25%36%39%25%37%61%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%53%45%45%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%33%25%36%35%25%36%35%25%36%62%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%56%4f%4c%55%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%36%25%36%66%25%36%63%25%37%35%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%50%52%4f%47%52%45%53%53%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%37%32%25%36%66%25%36%37%25%37%32%25%36%35%25%37%33%25%37%33%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%42%55%46%46%45%52%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%42%55%46%46%45%52%46%55%4c%4c%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%36%25%37%35%25%36%63%25%36%63%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%53%45%54%54%49%4e%47%53%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%36%35%25%37%34%25%37%34%25%36%39%25%36%65%25%36%37%25%37%33%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4c%4f%41%44%45%44%4d%45%54%41%44%41%54%41%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%36%64%25%36%35%25%37%34%25%36%31%25%36%34%25%36%31%25%37%34%25%36%31%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%48%49%47%48%44%45%46%49%4e%49%54%49%4f%4e%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%38%25%36%39%25%36%37%25%36%38%25%36%34%25%36%35%25%36%36%25%36%39%25%36%65%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%42%49%54%52%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%36%39%25%37%34%25%37%32%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4c%45%56%45%4c%53%5f%41%56%41%49%4c%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%36%31%25%37%36%25%36%31%25%36%39%25%36%63%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%5f%53%54%41%52%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%33%61%25%37%33%25%37%34%25%36%31%25%37%32%25%37%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%5f%45%4e%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%33%61%25%36%35%25%36%65%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%50%4c%41%59%42%41%43%4b%53%54%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%44%56%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%34%25%37%36%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%44%49%53%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%34%25%36%39%25%37%33%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%45%4e%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%35%25%36%65%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%50%4c%41%59%5f%49%4e%54%45%4e%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%33%61%25%36%39%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%53%54%41%54%53%5f%41%44%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%36%31%25%36%34%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%46%52%41%47%4d%45%4e%54%5f%4c%4f%41%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%36%25%37%32%25%36%31%25%36%37%25%36%64%25%36%35%25%36%65%25%37%34%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%50%42%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%4f%50%54%49%4f%4e%53%5f%43%48%41%4e%47%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%66%25%37%30%25%37%34%25%36%39%25%36%66%25%36%65%25%37%33%25%33%61%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%50%4c%41%59%42%41%43%4b%53%54%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%50%4c%41%59%42%41%43%4b%44%56%52%53%54%41%54%45%43%48%41%4e%47%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%37%36%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%42%49%54%52%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%32%25%36%39%25%37%34%25%37%32%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%54%41%54%53%5f%52%45%50%4f%52%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%37%32%25%36%35%25%37%30%25%36%66%25%37%32%25%37%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%44%45%53%54%52%4f%59%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%36%35%25%37%33%25%37%34%25%37%32%25%36%66%25%37%39%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4c%4f%41%44%45%44%4d%45%54%41%44%41%54%41%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%36%64%25%36%35%25%37%34%25%36%31%25%36%34%25%36%31%25%37%34%25%36%31%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%50%52%4f%47%52%45%53%53%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%37%32%25%36%66%25%36%37%25%37%32%25%36%35%25%37%33%25%37%33%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%43%4c%49%43%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%33%25%36%63%25%36%39%25%36%33%25%36%62%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%44%42%4c%43%4c%49%43%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%36%32%25%36%63%25%36%33%25%36%63%25%36%39%25%36%33%25%36%62%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%43%4f%4e%54%45%58%54%4d%45%4e%55%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%35%25%37%38%25%37%34%25%36%64%25%36%35%25%36%65%25%37%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%4f%55%53%45%5f%45%4e%54%45%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%35%25%36%65%25%37%34%25%36%35%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%4f%55%53%45%5f%4c%45%41%56%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%63%25%36%35%25%36%31%25%37%36%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%45%45%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%56%4f%4c%55%4d%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%36%25%36%66%25%36%63%25%37%35%25%36%64%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%54%41%54%45%5f%42%55%46%46%45%52%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%54%41%54%45%5f%42%55%46%46%45%52%46%55%4c%4c%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%36%25%37%35%25%36%63%25%36%63%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%45%54%54%49%4e%47%53%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%36%35%25%37%34%25%37%34%25%36%39%25%36%65%25%36%37%25%37%33%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%48%49%47%48%44%45%46%49%4e%49%54%49%4f%4e%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%38%25%36%39%25%36%37%25%36%38%25%36%34%25%36%35%25%36%36%25%36%39%25%36%65%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%53%48%4f%57%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%33%25%36%38%25%36%66%25%37%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%48%49%44%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%38%25%36%39%25%36%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%44%49%53%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%34%25%36%39%25%37%33%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%45%4e%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%35%25%36%65%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%53%54%41%54%53%5f%41%44%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%36%31%25%36%34%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%54%5f%4f%50%54%49%4f%4e%53%5f%43%48%41%4e%47%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%66%25%37%30%25%37%34%25%36%39%25%36%66%25%36%65%25%37%33%25%33%61%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%52%45%4e%44%45%52%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%32%25%36%35%25%36%65%25%36%34%25%36%35%25%37%32%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%53%48%4f%57%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%33%25%36%38%25%36%66%25%37%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%48%49%44%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%38%25%36%39%25%36%34%25%36%35%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%4d%4f%55%53%45%4d%4f%56%45%5f%53%45%45%4b%42%41%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%64%25%36%66%25%37%36%25%36%35%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%36%32%25%36%31%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%4d%4f%55%53%45%4c%45%41%56%45%5f%53%45%45%4b%42%41%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%63%25%36%35%25%36%31%25%37%36%25%36%35%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%36%32%25%36%31%25%37%32%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%50%4c%41%59%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%4e%4f%54%50%4c%41%59%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%65%25%36%66%25%37%34%25%37%30%25%36%63%25%36%31%25%37%39%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%4d%43%5f%43%4f%4e%54%41%49%4e%45%52%43%48%41%4e%47%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%36%34%25%32%37%27%29%29%3b%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%43%4f%4e%54%41%49%4e%45%52%53%5f%43%52%45%41%54%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%37%33%25%33%61%25%36%33%25%37%32%25%36%35%25%36%31%25%37%34%25%36%35%25%36%34%25%32%37%27%29%29%3b%20'));
	// eval(decodeURIComponent('%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%52%45%53%49%5a%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%32%25%36%35%25%37%33%25%36%39%25%37%61%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%53%45%45%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%33%25%36%35%25%36%35%25%36%62%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%45%52%5f%56%4f%4c%55%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%36%25%36%66%25%36%63%25%37%35%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%50%52%4f%47%52%45%53%53%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%37%32%25%36%66%25%36%37%25%37%32%25%36%35%25%37%33%25%37%33%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%42%55%46%46%45%52%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%42%55%46%46%45%52%46%55%4c%4c%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%36%25%37%35%25%36%63%25%36%63%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%53%45%54%54%49%4e%47%53%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%36%35%25%37%34%25%37%34%25%36%39%25%36%65%25%36%37%25%37%33%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4c%4f%41%44%45%44%4d%45%54%41%44%41%54%41%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%36%64%25%36%35%25%37%34%25%36%31%25%36%34%25%36%31%25%37%34%25%36%31%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%48%49%47%48%44%45%46%49%4e%49%54%49%4f%4e%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%38%25%36%39%25%36%37%25%36%38%25%36%34%25%36%35%25%36%36%25%36%39%25%36%65%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%42%49%54%52%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%32%25%36%39%25%37%34%25%37%32%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4c%45%56%45%4c%53%5f%41%56%41%49%4c%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%36%31%25%37%36%25%36%31%25%36%39%25%36%63%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%5f%53%54%41%52%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%33%61%25%37%33%25%37%34%25%36%31%25%37%32%25%37%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%5f%45%4e%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%37%33%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%33%61%25%36%35%25%36%65%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%50%4c%41%59%42%41%43%4b%53%54%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%44%56%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%34%25%37%36%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%44%49%53%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%34%25%36%39%25%37%33%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%45%4e%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%35%25%36%65%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%50%4c%41%59%5f%49%4e%54%45%4e%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%33%61%25%36%39%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%53%54%41%54%53%5f%41%44%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%36%31%25%36%34%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%46%52%41%47%4d%45%4e%54%5f%4c%4f%41%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%36%25%37%32%25%36%31%25%36%37%25%36%64%25%36%35%25%36%65%25%37%34%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%50%4c%41%59%42%41%43%4b%5f%4c%45%56%45%4c%5f%53%57%49%54%43%48%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%33%61%25%36%63%25%36%35%25%37%36%25%36%35%25%36%63%25%33%61%25%37%33%25%37%37%25%36%39%25%37%34%25%36%33%25%36%38%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%4f%50%54%49%4f%4e%53%5f%43%48%41%4e%47%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%66%25%37%30%25%37%34%25%36%39%25%36%66%25%36%65%25%37%33%25%33%61%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%50%4c%41%59%42%41%43%4b%53%54%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%32%25%36%31%25%36%33%25%36%62%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%50%4c%41%59%42%41%43%4b%44%56%52%53%54%41%54%45%43%48%41%4e%47%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%37%36%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%42%49%54%52%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%32%25%36%39%25%37%34%25%37%32%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%54%41%54%53%5f%52%45%50%4f%52%54%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%37%32%25%36%35%25%37%30%25%36%66%25%37%32%25%37%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%44%45%53%54%52%4f%59%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%36%35%25%37%33%25%37%34%25%37%32%25%36%66%25%37%39%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%52%45%41%44%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%32%25%36%35%25%36%31%25%36%34%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%45%52%52%4f%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4c%4f%41%44%45%44%4d%45%54%41%44%41%54%41%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%63%25%36%66%25%36%31%25%36%34%25%36%35%25%36%34%25%36%64%25%36%35%25%37%34%25%36%31%25%36%34%25%36%31%25%37%34%25%36%31%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%54%49%4d%45%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%34%25%36%39%25%36%64%25%36%35%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%50%52%4f%47%52%45%53%53%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%37%32%25%36%66%25%36%37%25%37%32%25%36%35%25%37%33%25%37%33%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%50%4c%41%59%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%54%4f%50%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%66%25%37%30%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%50%41%55%53%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%30%25%36%31%25%37%35%25%37%33%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%45%4e%44%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%35%25%36%65%25%36%34%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%43%4c%49%43%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%33%25%36%63%25%36%39%25%36%33%25%36%62%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%44%42%4c%43%4c%49%43%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%34%25%36%32%25%36%63%25%36%33%25%36%63%25%36%39%25%36%33%25%36%62%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%43%4f%4e%54%45%58%54%4d%45%4e%55%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%35%25%37%38%25%37%34%25%36%64%25%36%35%25%36%65%25%37%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%4f%55%53%45%5f%45%4e%54%45%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%35%25%36%65%25%37%34%25%36%35%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%4f%55%53%45%5f%4c%45%41%56%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%63%25%36%35%25%36%31%25%37%36%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%45%45%4b%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%56%4f%4c%55%4d%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%36%25%36%66%25%36%63%25%37%35%25%36%64%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%54%41%54%45%5f%42%55%46%46%45%52%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%54%41%54%45%5f%42%55%46%46%45%52%46%55%4c%4c%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%36%35%25%33%61%25%36%32%25%37%35%25%36%36%25%36%36%25%36%35%25%37%32%25%36%36%25%37%35%25%36%63%25%36%63%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%45%54%54%49%4e%47%53%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%36%35%25%37%34%25%37%34%25%36%39%25%36%65%25%36%37%25%37%33%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%48%49%47%48%44%45%46%49%4e%49%54%49%4f%4e%55%50%44%41%54%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%38%25%36%39%25%36%37%25%36%38%25%36%34%25%36%35%25%36%36%25%36%39%25%36%65%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%37%35%25%37%30%25%36%34%25%36%31%25%37%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%53%48%4f%57%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%33%25%36%38%25%36%66%25%37%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%48%49%44%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%38%25%36%39%25%36%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%44%49%53%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%34%25%36%39%25%37%33%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%45%4e%41%42%4c%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%35%25%36%65%25%36%31%25%36%32%25%36%63%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%53%54%41%54%53%5f%41%44%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%37%33%25%37%34%25%36%31%25%37%34%25%37%33%25%33%61%25%36%31%25%36%34%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%4e%54%41%49%4e%45%52%5f%4f%50%54%49%4f%4e%53%5f%43%48%41%4e%47%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%33%61%25%36%66%25%37%30%25%37%34%25%36%39%25%36%66%25%36%65%25%37%33%25%33%61%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%52%45%4e%44%45%52%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%32%25%36%35%25%36%65%25%36%34%25%36%35%25%37%32%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%46%55%4c%4c%53%43%52%45%45%4e%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%36%25%37%35%25%36%63%25%36%63%25%37%33%25%36%33%25%37%32%25%36%35%25%36%35%25%36%65%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%53%48%4f%57%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%33%25%36%38%25%36%66%25%37%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%48%49%44%45%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%38%25%36%39%25%36%34%25%36%35%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%4d%4f%55%53%45%4d%4f%56%45%5f%53%45%45%4b%42%41%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%64%25%36%66%25%37%36%25%36%35%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%36%32%25%36%31%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%4d%4f%55%53%45%4c%45%41%56%45%5f%53%45%45%4b%42%41%52%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%64%25%36%66%25%37%35%25%37%33%25%36%35%25%36%63%25%36%35%25%36%31%25%37%36%25%36%35%25%33%61%25%37%33%25%36%35%25%36%35%25%36%62%25%36%32%25%36%31%25%37%32%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%50%4c%41%59%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%37%30%25%36%63%25%36%31%25%37%39%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%4e%4f%54%50%4c%41%59%49%4e%47%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%65%25%36%66%25%37%34%25%37%30%25%36%63%25%36%31%25%37%39%25%36%39%25%36%65%25%36%37%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%4d%45%44%49%41%43%4f%4e%54%52%4f%4c%5f%43%4f%4e%54%41%49%4e%45%52%43%48%41%4e%47%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%64%25%36%35%25%36%34%25%36%39%25%36%31%25%36%33%25%36%66%25%36%65%25%37%34%25%37%32%25%36%66%25%36%63%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%36%33%25%36%38%25%36%31%25%36%65%25%36%37%25%36%35%25%36%34%25%32%37%27%29%29%20%45%76%65%6e%74%73%2e%43%4f%52%45%5f%43%4f%4e%54%41%49%4e%45%52%53%5f%43%52%45%41%54%45%44%20%3d%20%65%76%61%6c%28%64%65%63%6f%64%65%55%52%49%43%6f%6d%70%6f%6e%65%6e%74%28%27%25%32%37%25%36%33%25%36%66%25%37%32%25%36%35%25%33%61%25%36%33%25%36%66%25%36%65%25%37%34%25%36%31%25%36%39%25%36%65%25%36%35%25%37%32%25%37%33%25%33%61%25%36%33%25%37%32%25%36%35%25%36%31%25%37%34%25%36%35%25%36%34%25%32%37%27%29%29%20'));
	// PLAYER EVENTS

	Events.PLAYER_READY = 'ready';

	Events.PLAYER_RESIZE = 'resize';

	Events.PLAYER_FULLSCREEN = 'fullscreen';

	Events.PLAYER_CLOSEADS = 'closeads';

	Events.PLAYER_PLAY = 'play';

	Events.PLAYER_NEXT = 'next';

	Events.PLAYER_PLAYITEM = 'playitem';

	Events.PLAYER_PREV = 'prev';

	Events.PLAYER_CLICK_SCREEN = 'click:screen';

	Events.PLAYER_SHOW_MENU = 'show:menu';

	Events.PLAYER_PAUSE = 'pause';

	Events.PLAYER_STOP = 'stop';

	Events.PLAYER_ENDED = 'ended';

	Events.PLAYER_SEEK = 'seek';

	Events.PLAYER_ERROR = 'error';

	Events.PLAYER_TIMEUPDATE = 'timeupdate';

	Events.PLAYER_VOLUMEUPDATE = 'volumeupdate';

	Events.PLAYER_UPDATE_SONG_MODE = 'updatesongmode';

	Events.PLAYER_SELECT_LEVEL = 'selectlevel';

	Events.PLAYER_CANCEL_PLAYNEXT = 'cancelplaynext';

	Events.PLAYER_CLICK_PLAYNEXT = 'clickplaynext';

	Events.PLAYER_CANTPLAY = 'cantplay';

	Events.PLAYER_CHANGE_AD_MODE = 'changeadmode';

	Events.PLAYER_STOP_LINEAR_AD = 'stoplinearad';

	Events.PLAYER_PRESS_PAUSE = 'presspause';

	Events.PLAYER_PRESS_PLAY = 'pressplay';

	// Playback Events
	Events.PB_STARTPLAY = 'playback:startplay';

	Events.PB_LOADSTART = 'playback:loadstart';

	Events.PB_CANPLAY = 'playback:canplay';

	Events.PB_CANTPLAY = 'playback:cantplay';

	Events.PB_CANPLAYTHROUGH = 'playback:canplaythrough';

	Events.PB_SEEKING = 'playback:seeking';

	Events.PB_WAITING = 'playback:waiting';

	Events.PB_PROGRESS = 'playback:progress';

	Events.PB_TIMEUPDATE = 'playback:timeupdate';

	Events.PB_READY = 'playback:ready';

	Events.PB_BUFFERING = 'playback:buffering';

	Events.PB_BUFFERFULL = 'playback:bufferfull';

	Events.PB_SETTINGSUPDATE = 'playback:settingsupdate';

	Events.PB_LOADEDMETADATA = 'playback:loadedmetadata';

	Events.PB_HIGHDEFINITIONUPDATE = 'playback:highdefinitionupdate';

	Events.PB_BITRATE = 'playback:bitrate';

	Events.PB_LEVELS_AVAILABLE = 'playback:levels:available';

	Events.PB_LEVEL_SWITCH_START = 'playback:levels:switch:start';

	Events.PB_LEVEL_SWITCH_END = 'playback:levels:switch:end';

	Events.PB_PLAYBACKSTATE = 'playback:playbackstate';

	Events.PB_DVR = 'playback:dvr';
	Events.PB_MEDIACONTROL_DISABLE = 'playback:mediacontrol:disable';
	Events.PB_MEDIACONTROL_ENABLE = 'playback:mediacontrol:enable';

	Events.PB_ENDED = 'playback:ended';

	Events.PB_PLAY_INTENT = 'playback:play:intent';

	Events.PB_PLAY_ERROR_SOURCE = 'playback:play:errorsource';

	Events.PB_PLAY = 'playback:play';

	Events.PB_PAUSE = 'playback:pause';

	Events.PB_STOP = 'playback:stop';

	Events.PB_ERROR = 'playback:error';
	Events.PB_STATS_ADD = 'playback:stats:add';
	Events.PB_FRAGMENT_LOADED = 'playback:fragment:loaded';
	Events.PB_LEVEL_SWITCH = 'playback:level:switch';
	Events.PB_CHECK_ONLINE = 'playback:check:online';

	Events.CORE_CANTPLAY = 'core:options:cantplay';
	Events.CORE_OPTIONS_CHANGE = 'core:options:change';

	Events.CORE_READY = 'core:ready';

	Events.CORE_FULLSCREEN = 'core:fullscreen';

	// Container Events
	Events.CT_PLAYBACKSTATE = 'container:playbackstate';
	Events.CT_PLAYBACKDVRSTATECHANGED = 'container:dvr';

	Events.CT_SHOWNEXT = 'container:shownext';
	Events.CT_BITRATE = 'container:bitrate';
	Events.CT_STATS_REPORT = 'container:stats:report';
	Events.CT_DESTROYED = 'container:destroyed';

	Events.CT_READY = 'container:ready';
	Events.CT_ERROR = 'container:error';
	Events.CT_CHECK_ONLINE = 'container:check:online';
	Events.CT_REPORT = 'container:report';
	Events.CT_SELECTLEVEL = 'container:selectlevel';
	Events.CT_LEVEl_AVAILABLE = 'container:levelavailable';
	Events.CT_LEVEL_SWITCH = 'container:levelswitch';

	Events.CT_LOADEDMETADATA = 'container:loadedmetadata';

	Events.CT_TIMEUPDATE = 'container:timeupdate';

	Events.CT_LOADSTART = 'container:loadstart';
	Events.CT_CANPLAY = 'container:canplay';
	Events.CT_CANPLAYTHROUGH = 'container:canplaythrough';
	Events.CT_SEEKING = 'container:seeking';
	Events.CT_WAITING = 'container:waiting';
	Events.CT_PROGRESS = 'container:progress';
	Events.CT_PLAY = 'container:play';
	Events.CT_PLAY_REQUEST = 'container:playrequest';
	Events.CT_STARTPLAY = 'container:startplay';
	Events.CT_STOP = 'container:stop';
	Events.CT_NEXT = 'container:next';
	Events.CT_KARAOKE = 'container:KARAOKE';
	Events.CT_PLAYMODE = 'container:playmode';
	Events.CT_CLOSEADS = 'container:closeads';
	Events.CT_PREV = 'container:prev';
	Events.CT_PLAYITEM = 'container:playitem';
	Events.CT_CANTPLAY = 'container:cantplay';
	Events.CT_PAUSE = 'container:pause';
	Events.CT_ENDED = 'container:ended';
	Events.CT_CLICK = 'container:click';
	Events.CT_DBLCLICK = 'container:dblclick';
	Events.CT_CONTEXTMENU = 'container:contextmenu';
	Events.CT_MOUSE_ENTER = 'container:mouseenter';
	Events.CT_MOUSE_LEAVE = 'container:mouseleave';

	Events.CT_START_PLAY = 'container:startplay';
	Events.CT_UPDATE_SONG_MODE = 'container:updatesongmode';
	Events.CT_SEEK = 'container:seek';
	Events.CT_VOLUME = 'container:volume';
	Events.CT_FULLSCREEN = 'container:fullscreen';
	Events.CT_CHANGESPEED = 'container:changespeed';
	Events.CT_LOADING_AD = 'container:loading_ad';
	Events.CT_LOADED_ADS = 'container:loaded_ads';
	Events.CT_LOADED_PAUSE_AD = 'container:load_pause_ad';
	Events.CT_START_LINEAR_AD = 'container:start_linear_ad';
	Events.CT_FINISH_LINEAR_AD = 'container:finish_linear_ad';
	Events.CT_START_NON_LINEAR_AD = 'container:start_non_linear_ad';
	Events.CT_START_MID_AD = 'container:start_mid_ad';
	Events.CT_FINISH_PREROLL_AD = 'container:finish_preroll_ad';

	Events.CT_STATE_BUFFERING = 'container:state:buffering';
	Events.CT_STATE_BUFFERFULL = 'container:state:bufferfull';
	Events.CT_SETTINGSUPDATE = 'container:settingsupdate';
	Events.CT_HIGHDEFINITIONUPDATE = 'container:highdefinitionupdate';
	Events.CT_MEDIACONTROL_SHOW = 'container:mediacontrol:show';
	Events.CT_MEDIACONTROL_HIDE = 'container:mediacontrol:hide';
	Events.CT_MEDIACONTROL_DISABLE = 'container:mediacontrol:disable';
	Events.CT_MEDIACONTROL_ENABLE = 'container:mediacontrol:enable';
	Events.CT_STATS_ADD = 'container:stats:add';
	Events.CT_TRACKINGZDN = 'container:stats:trackingzdn';
	Events.CT_TRACKINGZDN_END = 'container:stats:trackingzdn_end';
	Events.CT_OPTIONS_CHANGE = 'container:options:change';
	Events.CT_CLICK_PLAYNEXT = 'container:click:playnext';
	Events.CT_CANCEL_PLAYNEXT = 'container:cancel:playnext';
	Events.CT_CHANGE_AD_MODE = 'container:changeadmode';
	Events.CT_HIDE = 'container:hide';
	Events.CT_SHOW = 'container:show';
	Events.CT_PLAY_AD = 'container:playad';
	Events.CT_PAUSE_AD = 'container:pausead';
	Events.CT_UPDATE_REPEAT_MODE = 'container:updaterepeatmode';
	Events.CT_UPDATE_SHUFFLE_MODE = 'container:updateshufflemode';
	Events.CT_START_AUDIO_AD = 'container:startaudioad';
	Events.CT_FINISH_AUDIO_AD = 'container:finishaudioad';
	Events.CT_PRESS_PLAY = 'container:pressplay';
	Events.CT_PRESS_PAUSE = 'container:presspause';

	// MediaControl Events
	Events.MC_RENDERED = 'mediacontrol:rendered';

	Events.MC_FULLSCREEN = 'mediacontrol:fullscreen';

	Events.MC_SHOW = 'mediacontrol:show';

	Events.MC_HIDE = 'mediacontrol:hide';

	Events.MC_MOUSEMOVE_SEEKBAR = 'mediacontrol:mousemove:seekbar';

	Events.MC_MOUSELEAVE_SEEKBAR = 'mediacontrol:mouseleave:seekbar';

	Events.MC_PLAYING = 'mediacontrol:playing';

	Events.MC_NOTPLAYING = 'mediacontrol:notplaying';

	Events.MC_CONTAINERCHANGED = 'mediacontrol:containerchanged';

	Events.MC_TOGGLE_EXPAND = 'mediacontrol:toggleexpand';

	// Subtitle events
	Events.SUB_READY = 'sub:ready';

	// Core Events
	Events.CORE_CONTAINERS_CREATED = 'core:containers:created';
	module.exports = exports['default'];

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(7);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _vendor = __webpack_require__(8);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var BOLD = 'font-weight: bold; font-size: 13px;';
	var INFO = 'color: #006600;' + BOLD;
	var DEBUG = 'color: #0000ff;' + BOLD;
	var WARN = 'color: #ff8000;' + BOLD;
	var ERROR = 'color: #ff0000;' + BOLD;

	var LEVEL_DEBUG = 0;
	var LEVEL_INFO = 1;
	var LEVEL_WARN = 2;
	var LEVEL_ERROR = 3;
	var LEVEL_DISABLED = LEVEL_ERROR;

	var COLORS = [DEBUG, INFO, WARN, ERROR, ERROR];
	var DESCRIPTIONS = ['debug', 'info', 'warn', 'error', 'disabled'];

	var Log = function () {
	    function Log() {
	        var _this = this;

	        var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LEVEL_INFO;
	        var offLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LEVEL_DISABLED;

	        _classCallCheck(this, Log);

	        this.kibo = new _vendor.Kibo();
	        this.kibo.down(['ctrl shift d'], function () {
	            return _this.onOff();
	        });
	        this.BLACKLIST = ['timeupdate', 'playback:timeupdate', 'playback:progress', 'container:hover', 'container:timeupdate', 'container:progress'];
	        this.level = level;
	        this.offLevel = offLevel;
	    }

	    Log.prototype.debug = function debug(klass) {
	        this.log(klass, LEVEL_DEBUG, Array.prototype.slice.call(arguments, 1));
	    };

	    Log.prototype.info = function info(klass) {
	        this.log(klass, LEVEL_INFO, Array.prototype.slice.call(arguments, 1));
	    };

	    Log.prototype.warn = function warn(klass) {
	        this.log(klass, LEVEL_WARN, Array.prototype.slice.call(arguments, 1));
	    };

	    Log.prototype.error = function error(klass) {
	        this.log(klass, LEVEL_ERROR, Array.prototype.slice.call(arguments, 1));
	    };

	    Log.prototype.onOff = function onOff() {
	        if (this.level === this.offLevel) {
	            this.level = this.previousLevel;
	        } else {
	            this.previousLevel = this.level;
	            this.level = this.offLevel;
	        }
	        // handle instances where console.log is unavailable
	        if (window.console && window.console.log) {
	            window.console.log('%c[zPlayer.Log] set log level to ' + DESCRIPTIONS[this.level], WARN);
	        }
	    };

	    Log.prototype.level = function level(newLevel) {
	        this.level = newLevel;
	    };

	    Log.prototype.log = function log(klass, level, message) {
	        if (this.BLACKLIST.indexOf(message[0]) >= 0) return;
	        if (level < this.level) return;

	        if (!message) {
	            message = klass;
	            klass = null;
	        }
	        var color = COLORS[level];
	        var klassDescription = '';
	        if (klass) {
	            klassDescription = '[' + klass + ']';
	        }
	        if (window.console && window.console.log) {
	            window.console.log.apply(console, ['%c[' + DESCRIPTIONS[level] + ']' + klassDescription, color].concat(message));
	        }
	    };

	    return Log;
	}();

	exports.default = Log;


	Log.LEVEL_DEBUG = LEVEL_DEBUG;
	Log.LEVEL_INFO = LEVEL_INFO;
	Log.LEVEL_WARN = LEVEL_WARN;
	Log.LEVEL_ERROR = LEVEL_ERROR;

	Log.getInstance = function () {
	    if (this._instance === undefined) {
	        this._instance = new this();
	        this._instance.previousLevel = this._instance.level;
	        this._instance.level = this._instance.offLevel;
	    }
	    return this._instance;
	};

	Log.setLevel = function (level) {
	    this.getInstance().level = level;
	};

	Log.debug = function () {
	    this.getInstance().debug.apply(this.getInstance(), arguments);
	};
	Log.info = function () {
	    this.getInstance().info.apply(this.getInstance(), arguments);
	};
	Log.warn = function () {
	    this.getInstance().warn.apply(this.getInstance(), arguments);
	};
	Log.error = function () {
	    this.getInstance().error.apply(this.getInstance(), arguments);
	};
	module.exports = exports['default'];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _kibo = __webpack_require__(9);

	var _kibo2 = _interopRequireDefault(_kibo);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = { Kibo: _kibo2.default };
	module.exports = exports['default'];

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Kibo is released under the MIT License. Copyright (c) 2013 marquete.
	// see https://github.com/marquete/kibo

	var Kibo = function Kibo(element) {
	  this.element = element || window.document;
	  this.initialize();
	};

	Kibo.KEY_NAMES_BY_CODE = {
	  8: 'backspace', 9: 'tab', 13: 'enter',
	  16: 'shift', 17: 'ctrl', 18: 'alt',
	  20: 'caps_lock',
	  27: 'esc',
	  32: 'space',
	  37: 'left', 38: 'up', 39: 'right', 40: 'down',
	  48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9',
	  65: 'a', 66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h', 73: 'i', 74: 'j',
	  75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o', 80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't',
	  85: 'u', 86: 'v', 87: 'w', 88: 'x', 89: 'y', 90: 'z', 112: 'f1', 113: 'f2', 114: 'f3',
	  115: 'f4', 116: 'f5', 117: 'f6', 118: 'f7', 119: 'f8', 120: 'f9', 121: 'f10', 122: 'f11', 123: 'f12'
	};

	Kibo.KEY_CODES_BY_NAME = {};
	(function () {
	  for (var key in Kibo.KEY_NAMES_BY_CODE) {
	    if (Object.prototype.hasOwnProperty.call(Kibo.KEY_NAMES_BY_CODE, key)) {
	      Kibo.KEY_CODES_BY_NAME[Kibo.KEY_NAMES_BY_CODE[key]] = +key;
	    }
	  }
	})();

	Kibo.MODIFIERS = ['shift', 'ctrl', 'alt'];

	Kibo.registerEvent = function () {
	  if (document.addEventListener) {
	    return function (element, eventName, func) {
	      element.addEventListener(eventName, func, false);
	    };
	  } else if (document.attachEvent) {
	    return function (element, eventName, func) {
	      element.attachEvent('on' + eventName, func);
	    };
	  }
	}();

	Kibo.unregisterEvent = function () {
	  if (document.removeEventListener) {
	    return function (element, eventName, func) {
	      element.removeEventListener(eventName, func, false);
	    };
	  } else if (document.detachEvent) {
	    return function (element, eventName, func) {
	      element.detachEvent('on' + eventName, func);
	    };
	  }
	}();

	Kibo.stringContains = function (string, substring) {
	  return string.indexOf(substring) !== -1;
	};

	Kibo.neatString = function (string) {
	  return string.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
	};

	Kibo.capitalize = function (string) {
	  return string.toLowerCase().replace(/^./, function (match) {
	    return match.toUpperCase();
	  });
	};

	Kibo.isString = function (what) {
	  return Kibo.stringContains(Object.prototype.toString.call(what), 'String');
	};

	Kibo.arrayIncludes = function () {
	  if (Array.prototype.indexOf) {
	    return function (haystack, needle) {
	      return haystack.indexOf(needle) !== -1;
	    };
	  } else {
	    return function (haystack, needle) {
	      for (var i = 0; i < haystack.length; i++) {
	        if (haystack[i] === needle) {
	          return true;
	        }
	      }
	      return false;
	    };
	  }
	}();

	Kibo.extractModifiers = function (keyCombination) {
	  var modifiers, i;
	  modifiers = [];
	  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
	    if (Kibo.stringContains(keyCombination, Kibo.MODIFIERS[i])) {
	      modifiers.push(Kibo.MODIFIERS[i]);
	    }
	  }
	  return modifiers;
	};

	Kibo.extractKey = function (keyCombination) {
	  var keys, i;
	  keys = Kibo.neatString(keyCombination).split(' ');
	  for (i = 0; i < keys.length; i++) {
	    if (!Kibo.arrayIncludes(Kibo.MODIFIERS, keys[i])) {
	      return keys[i];
	    }
	  }
	};

	Kibo.modifiersAndKey = function (keyCombination) {
	  var result, key;

	  if (Kibo.stringContains(keyCombination, 'any')) {
	    return Kibo.neatString(keyCombination).split(' ').slice(0, 2).join(' ');
	  }

	  result = Kibo.extractModifiers(keyCombination);

	  key = Kibo.extractKey(keyCombination);
	  if (key && !Kibo.arrayIncludes(Kibo.MODIFIERS, key)) {
	    result.push(key);
	  }

	  return result.join(' ');
	};

	Kibo.keyName = function (keyCode) {
	  return Kibo.KEY_NAMES_BY_CODE[keyCode + ''];
	};

	Kibo.keyCode = function (keyName) {
	  return +Kibo.KEY_CODES_BY_NAME[keyName];
	};

	Kibo.prototype.initialize = function () {
	  var i,
	      that = this;

	  this.lastKeyCode = -1;
	  this.lastModifiers = {};
	  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
	    this.lastModifiers[Kibo.MODIFIERS[i]] = false;
	  }

	  this.keysDown = { any: [] };
	  this.keysUp = { any: [] };
	  this.downHandler = this.handler('down');
	  this.upHandler = this.handler('up');

	  Kibo.registerEvent(this.element, 'keydown', this.downHandler);
	  Kibo.registerEvent(this.element, 'keyup', this.upHandler);
	  Kibo.registerEvent(window, 'unload', function unloader() {
	    Kibo.unregisterEvent(that.element, 'keydown', that.downHandler);
	    Kibo.unregisterEvent(that.element, 'keyup', that.upHandler);
	    Kibo.unregisterEvent(window, 'unload', unloader);
	  });
	};

	Kibo.prototype.handler = function (upOrDown) {
	  var that = this;
	  return function (e) {
	    var i, registeredKeys, lastModifiersAndKey;

	    e = e || window.event;

	    that.lastKeyCode = e.keyCode;
	    for (i = 0; i < Kibo.MODIFIERS.length; i++) {
	      that.lastModifiers[Kibo.MODIFIERS[i]] = e[Kibo.MODIFIERS[i] + 'Key'];
	    }
	    if (Kibo.arrayIncludes(Kibo.MODIFIERS, Kibo.keyName(that.lastKeyCode))) {
	      that.lastModifiers[Kibo.keyName(that.lastKeyCode)] = true;
	    }

	    registeredKeys = that['keys' + Kibo.capitalize(upOrDown)];

	    for (i = 0; i < registeredKeys.any.length; i++) {
	      if (registeredKeys.any[i](e) === false && e.preventDefault) {
	        e.preventDefault();
	      }
	    }

	    lastModifiersAndKey = that.lastModifiersAndKey();
	    if (registeredKeys[lastModifiersAndKey]) {
	      for (i = 0; i < registeredKeys[lastModifiersAndKey].length; i++) {
	        if (registeredKeys[lastModifiersAndKey][i](e) === false && e.preventDefault) {
	          e.preventDefault();
	        }
	      }
	    }
	  };
	};

	Kibo.prototype.registerKeys = function (upOrDown, newKeys, func) {
	  var i,
	      keys,
	      registeredKeys = this['keys' + Kibo.capitalize(upOrDown)];

	  if (Kibo.isString(newKeys)) {
	    newKeys = [newKeys];
	  }

	  for (i = 0; i < newKeys.length; i++) {
	    keys = newKeys[i];
	    keys = Kibo.modifiersAndKey(keys + '');

	    if (registeredKeys[keys]) {
	      registeredKeys[keys].push(func);
	    } else {
	      registeredKeys[keys] = [func];
	    }
	  }

	  return this;
	};

	// jshint maxdepth:5
	Kibo.prototype.unregisterKeys = function (upOrDown, newKeys, func) {
	  var i,
	      j,
	      keys,
	      registeredKeys = this['keys' + Kibo.capitalize(upOrDown)];

	  if (Kibo.isString(newKeys)) {
	    newKeys = [newKeys];
	  }

	  for (i = 0; i < newKeys.length; i++) {
	    keys = newKeys[i];
	    keys = Kibo.modifiersAndKey(keys + '');

	    if (func === null) {
	      delete registeredKeys[keys];
	    } else {
	      if (registeredKeys[keys]) {
	        for (j = 0; j < registeredKeys[keys].length; j++) {
	          if (String(registeredKeys[keys][j]) === String(func)) {
	            registeredKeys[keys].splice(j, 1);
	            break;
	          }
	        }
	      }
	    }
	  }

	  return this;
	};

	Kibo.prototype.off = function (keys) {
	  return this.unregisterKeys('down', keys, null);
	};

	Kibo.prototype.delegate = function (upOrDown, keys, func) {
	  return func !== null || func !== undefined ? this.registerKeys(upOrDown, keys, func) : this.unregisterKeys(upOrDown, keys, func);
	};

	Kibo.prototype.down = function (keys, func) {
	  return this.delegate('down', keys, func);
	};

	Kibo.prototype.up = function (keys, func) {
	  return this.delegate('up', keys, func);
	};

	Kibo.prototype.lastKey = function (modifier) {
	  if (!modifier) {
	    return Kibo.keyName(this.lastKeyCode);
	  }

	  return this.lastModifiers[modifier];
	};

	Kibo.prototype.lastModifiersAndKey = function () {
	  var result, i;

	  result = [];
	  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
	    if (this.lastKey(Kibo.MODIFIERS[i])) {
	      result.push(Kibo.MODIFIERS[i]);
	    }
	  }

	  if (!Kibo.arrayIncludes(result, this.lastKey())) {
	    result.push(this.lastKey());
	  }

	  return result.join(' ');
	};

	exports.default = Kibo;
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Creates a function that invokes `func`, with the `this` binding and arguments
	 * of the created function, while it's called less than `n` times. Subsequent
	 * calls to the created function return the result of the last `func` invocation.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {number} n The number of calls at which `func` is no longer invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * jQuery(element).on('click', _.before(5, addContactToList));
	 * // => Allows adding up to 4 contacts to the list.
	 */
	function before(n, func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	}

	/**
	 * Creates a function that is restricted to invoking `func` once. Repeat calls
	 * to the function return the value of the first invocation. The `func` is
	 * invoked with the `this` binding and arguments of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var initialize = _.once(createApplication);
	 * initialize();
	 * initialize();
	 * // => `createApplication` is invoked once
	 */
	function once(func) {
	  return before(2, func);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = once;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(12);

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _core = __webpack_require__(13);

	var _core2 = _interopRequireDefault(_core);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var CoreFactory = function (_BaseObject) {
	    _inherits(CoreFactory, _BaseObject);

	    _createClass(CoreFactory, [{
	        key: 'loader',
	        get: function get() {
	            return this.player.loader;
	        }
	    }]);

	    function CoreFactory(player) {
	        _classCallCheck(this, CoreFactory);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this));

	        _this.player = player;
	        _this._options = player.options;

	        return _this;
	    }

	    CoreFactory.prototype.create = function create() {
	        this.options.loader = this.loader;
	        this.core = new _core2.default(this.options);
	        this.addCorePlugins();
	        this.core.createContainers(this.options);
	        return this.core;
	    };

	    CoreFactory.prototype.addCorePlugins = function addCorePlugins() {
	        var _this2 = this;

	        this.loader.corePlugins.forEach(function (Plugin) {
	            if (!Plugin) return;
	            var plugin = new Plugin(_this2.core);
	            _this2.core.addPlugin(plugin);
	            _this2.setupExternalInterface(plugin);
	        });
	        return this.core;
	    };

	    CoreFactory.prototype.setupExternalInterface = function setupExternalInterface(plugin) {
	        var externalFunctions = plugin.getExternalInterface();
	        for (var key in externalFunctions) {
	            this.player[key] = externalFunctions[key].bind(plugin);
	        }
	    };

	    return CoreFactory;
	}(_base_object2.default);

	exports.default = CoreFactory;
	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(14);

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _container_factory = __webpack_require__(20);

	var _container_factory2 = _interopRequireDefault(_container_factory);

	var _mediator = __webpack_require__(53);

	var _mediator2 = _interopRequireDefault(_mediator);

	var _player_info = __webpack_require__(54);

	var _player_info2 = _interopRequireDefault(_player_info);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	var _style = __webpack_require__(55);

	var _style2 = _interopRequireDefault(_style);

	var _media_control = __webpack_require__(57);

	var _media_control2 = _interopRequireDefault(_media_control);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Core = function (_UIObject) {
	    _inherits(Core, _UIObject);

	    _createClass(Core, [{
	        key: 'events',
	        get: function get() {
	            return {
	                'webkitfullscreenchange': 'handleFullscreenChange',
	                'mousemove': 'showMediaControl',
	                'click': 'showMediaControl',
	                'mouseleave': 'hideMediaControl'
	            };
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return {
	                'data-player': '',
	                tabindex: 9999
	            };
	        }
	    }, {
	        key: 'isReady',
	        get: function get() {
	            return !!this.ready;
	        }
	    }, {
	        key: 'i18n',
	        get: function get() {
	            return this.getPlugin('strings') || { t: function t(key) {
	                    return key;
	                } };
	        }
	    }]);

	    function Core(options) {
	        _classCallCheck(this, Core);

	        var _this = _possibleConstructorReturn(this, _UIObject.call(this, options));

	        _this.playerInfo = _player_info2.default.getInstance(options.playerId);
	        _this.firstResize = true;
	        _this.plugins = [];
	        _this.containers = [];
	        _this.setupMediaControl(null);

	        _this._boundFullscreenHandler = function () {
	            return _this.handleFullscreenChange();
	        };
	        (0, _clapprZepto2.default)(document).bind('fullscreenchange', _this._boundFullscreenHandler);
	        (0, _clapprZepto2.default)(document).bind('MSFullscreenChange', _this._boundFullscreenHandler);
	        (0, _clapprZepto2.default)(document).bind('mozfullscreenchange', _this._boundFullscreenHandler);
	        return _this;
	    }

	    Core.prototype.createContainers = function createContainers(options) {
	        var _this2 = this;

	        this.defer = _clapprZepto2.default.Deferred();
	        this.defer.promise(this);
	        this.containerFactory = new _container_factory2.default(options, options.loader, this.i18n);
	        this.containerFactory.createContainers().then(function (containers) {
	            return _this2.setupContainers(containers);
	        }).then(function (containers) {
	            return _this2.resolveOnContainersReady(containers);
	        });
	    };

	    Core.prototype.updateSize = function updateSize() {
	        if (_utils.Fullscreen.isFullscreen()) {
	            this.setFullscreen();
	        } else {
	            this.setPlayerSize();
	        }
	    };

	    Core.prototype.setFullscreen = function setFullscreen() {
	        if (!_browser2.default.isiOS) {
	            this.$el.addClass('fullscreen');
	            this.$el.removeAttr('style');
	            this.playerInfo.currentSize = { width: (0, _clapprZepto2.default)(window).width(), height: (0, _clapprZepto2.default)(window).height() };
	        }
	    };

	    Core.prototype.setPlayerSize = function setPlayerSize() {
	        this.$el.removeClass('fullscreen');
	        this.playerInfo.currentSize = this.playerInfo.previousSize;
	        this.playerInfo.previousSize = { width: (0, _clapprZepto2.default)(window).width(), height: (0, _clapprZepto2.default)(window).height() };
	        this.resize(this.playerInfo.currentSize);
	    };

	    Core.prototype.resize = function resize(options) {
	        if (!(0, _utils.isNumber)(options.height) && !(0, _utils.isNumber)(options.width)) {
	            this.el.style.height = '' + options.height;
	            this.el.style.width = '' + options.width;
	        } else {
	            this.el.style.height = options.height + 'px';
	            this.el.style.width = options.width + 'px';
	        }
	        this.playerInfo.previousSize = options;
	        this.options.width = options.width;
	        this.options.height = options.height;
	        this.playerInfo.currentSize = options;
	        this.triggerResize(this.playerInfo.currentSize);
	    };

	    Core.prototype.enableResizeObserver = function enableResizeObserver() {
	        var _this3 = this;

	        var checkSizeCallback = function checkSizeCallback() {
	            if (_this3.playerInfo.computedSize.width != _this3.el.clientWidth || _this3.playerInfo.computedSize.height != _this3.el.clientHeight) {
	                _this3.playerInfo.computedSize = { width: _this3.el.clientWidth, height: _this3.el.clientHeight };
	                _this3.triggerResize(_this3.playerInfo.computedSize);
	            }
	        };
	        this.resizeObserverInterval = setInterval(checkSizeCallback, 500);
	    };

	    Core.prototype.triggerResize = function triggerResize(newSize) {
	        var thereWasChange = this.firstResize || this.oldHeight !== newSize.height || this.oldWidth !== newSize.width;
	        if (thereWasChange) {
	            _mediator2.default.trigger(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, newSize);
	            this.oldHeight = newSize.height;
	            this.oldWidth = newSize.width;
	            this.firstResize = false;
	        }
	    };

	    Core.prototype.disableResizeObserver = function disableResizeObserver() {
	        if (this.resizeObserverInterval) clearInterval(this.resizeObserverInterval);
	    };

	    Core.prototype.resolveOnContainersReady = function resolveOnContainersReady(containers) {
	        var _this4 = this;

	        _clapprZepto2.default.when.apply(_clapprZepto2.default, containers).done(function () {
	            _this4.defer.resolve(_this4);
	            _this4.ready = true;
	            _this4.trigger(_events2.default.CORE_READY);
	        });
	        setTimeout(function () {
	            if (!_this4.ready) {
	                _this4.defer.resolve(_this4);
	                _this4.ready = true;
	                _this4.trigger(_events2.default.CORE_READY);
	            }
	        }, 100);
	    };

	    Core.prototype.addPlugin = function addPlugin(plugin) {
	        this.plugins.push(plugin);
	    };

	    Core.prototype.hasPlugin = function hasPlugin(name) {
	        return !!this.getPlugin(name);
	    };

	    Core.prototype.getPlugin = function getPlugin(name) {
	        return (0, _arrayPrototype2.default)(this.plugins, function (plugin) {
	            return plugin.name === name;
	        });
	    };

	    Core.prototype.load = function load(sources, mimeType) {
	        var _this5 = this;

	        var createContainer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	        this.options.mimeType = mimeType;
	        sources = sources && sources.constructor === Array ? sources : [sources];
	        this.containers.forEach(function (container) {
	            return container.destroy();
	        });
	        this.mediaControl.container = null;

	        this.containerFactory.options = _clapprZepto2.default.extend(this.options, { sources: sources });
	        if (createContainer) {
	            this.containerFactory.createContainers().then(function (containers) {
	                _this5.setupContainers(containers);
	            });
	        }
	    };

	    Core.prototype.destroy = function destroy() {
	        this.disableResizeObserver();
	        this.containers.forEach(function (container) {
	            return container.destroy();
	        });
	        this.plugins.forEach(function (plugin) {
	            return plugin.destroy();
	        });
	        this.$el.remove();
	        this.mediaControl.destroy();
	        (0, _clapprZepto2.default)(document).unbind('fullscreenchange', this._boundFullscreenHandler);
	        (0, _clapprZepto2.default)(document).unbind('MSFullscreenChange', this._boundFullscreenHandler);
	        (0, _clapprZepto2.default)(document).unbind('mozfullscreenchange', this._boundFullscreenHandler);
	    };

	    Core.prototype.handleFullscreenChange = function handleFullscreenChange() {
	        this.trigger(_events2.default.CORE_FULLSCREEN, _utils.Fullscreen.isFullscreen());
	        this.updateSize();
	        this.mediaControl.show();
	    };

	    Core.prototype.setMediaControlContainer = function setMediaControlContainer(container) {
	        this.mediaControl.setContainer(container);
	        this.mediaControl.render();
	    };

	    Core.prototype.disableMediaControl = function disableMediaControl() {
	        this.mediaControl.disable();
	        this.$el.removeClass('nocursor');
	    };

	    Core.prototype.enableMediaControl = function enableMediaControl() {
	        this.mediaControl.enable();
	    };

	    Core.prototype.removeContainer = function removeContainer(container) {
	        this.stopListening(container);
	        this.containers = this.containers.filter(function (c) {
	            return c !== container;
	        });
	    };

	    Core.prototype.appendContainer = function appendContainer(container) {
	        this.listenTo(container, _events2.default.CT_DESTROYED, this.removeContainer);
	        this.containers.push(container);
	    };

	    Core.prototype.setupContainers = function setupContainers(containers) {

	        containers.map(this.appendContainer.bind(this));
	        this.trigger(_events2.default.CORE_CONTAINERS_CREATED);
	        this.renderContainers();
	        this.setupMediaControl(this.getCurrentContainer());
	        this.render();
	        this.$el.appendTo(this.options.parentElement);
	        return this.containers;
	    };

	    Core.prototype.renderContainers = function renderContainers() {
	        var _this6 = this;

	        this.containers.map(function (container) {
	            return _this6.el.appendChild(container.render().el);
	        });
	    };

	    Core.prototype.createContainer = function createContainer(source, options) {
	        var container = this.containerFactory.createContainer(source, options);
	        this.appendContainer(container);
	        this.el.appendChild(container.render().el);
	        return container;
	    };

	    Core.prototype.setupMediaControl = function setupMediaControl(container) {
	        if (this.mediaControl) {
	            this.mediaControl.setContainer(container);
	        } else {
	            this.mediaControl = this.createMediaControl(_clapprZepto2.default.extend({
	                container: container,
	                focusElement: this.el
	            }, this.options));
	            this.listenTo(this.mediaControl, _events2.default.MC_FULLSCREEN, this.toggleFullscreen);
	            this.listenTo(this.mediaControl, _events2.default.MC_SHOW, this.onMediaControlShow.bind(this, true));
	            this.listenTo(this.mediaControl, _events2.default.MC_HIDE, this.onMediaControlShow.bind(this, false));
	        }
	    };

	    Core.prototype.createMediaControl = function createMediaControl(options) {
	        if (options.mediacontrol && options.mediacontrol.external) {
	            return new options.mediacontrol.external(options).render();
	        } else {
	            return new _media_control2.default(options).render();
	        }
	    };

	    Core.prototype.getCurrentContainer = function getCurrentContainer() {
	        if (!this.mediaControl || !this.mediaControl.container) {
	            return this.containers[0];
	        }
	        return this.mediaControl.container;
	    };

	    Core.prototype.getCurrentPlayback = function getCurrentPlayback() {
	        var container = this.getCurrentContainer();
	        return container && container.playback;
	    };

	    Core.prototype.getPlaybackType = function getPlaybackType() {
	        var container = this.getCurrentContainer();
	        return container && container.getPlaybackType();
	    };

	    Core.prototype.toggleFullscreen = function toggleFullscreen() {
	        if (!_utils.Fullscreen.isFullscreen()) {
	            _utils.Fullscreen.requestFullscreen(this.el);
	            if (!_browser2.default.isiOS) {
	                this.$el.addClass('fullscreen');
	            }
	        } else {
	            _utils.Fullscreen.cancelFullscreen();
	            if (!_browser2.default.isiOS) {
	                this.$el.removeClass('fullscreen nocursor');
	            }
	        }
	        this.mediaControl.show();
	    };

	    Core.prototype.showMediaControl = function showMediaControl() {
	        if (!this.options.alwaysShowControl && _browser2.default.isMobile) {
	            var container = this.getCurrentContainer();
	            container && container.playback.play();
	        }
	        this.mediaControl.show();
	    };

	    Core.prototype.hideMediaControl = function hideMediaControl() {
	        if (!this.options.alwaysShowControl) {
	            this.mediaControl.hide(this.options.hideMediaControlDelay);
	        }
	    };

	    Core.prototype.onMediaControlShow = function onMediaControlShow(showing) {
	        this.getCurrentContainer().trigger(showing ? _events2.default.CT_MEDIACONTROL_SHOW : _events2.default.CT_MEDIACONTROL_HIDE);

	        if (showing) this.$el.removeClass('nocursor');else if (_utils.Fullscreen.isFullscreen()) this.$el.addClass('nocursor');
	    };

	    Core.prototype.configure = function configure(options) {
	        var _this7 = this;

	        this._options = _clapprZepto2.default.extend(this._options, options);
	        this._options.mvUrl = options.mvUrl;
	        this._options.karaokeUrl = options.karaokeUrl;

	        var sources = options.source || options.sources;

	        if (sources) {
	            this.load(sources, options.mimeType || this.options.mimeType);
	        } else {
	            this.load('', '');
	            this.trigger(_events2.default.CORE_OPTIONS_CHANGE);
	            this.containers.forEach(function (container) {
	                container.configure(_this7.options);
	            });
	        }
	    };

	    Core.prototype.render = function render() {
	        var style = _styler2.default.getStyleFor(_style2.default, { baseUrl: this.options.baseUrl, customCSS: this.options.customCSS });
	        !this.options.hasAnPlayerInstance && this.$el.append(style);
	        this.$el.append(this.mediaControl.render().el);

	        this.options.width = this.options.width || this.$el.width();
	        this.options.height = this.options.height || this.$el.height();
	        var size = { width: this.options.width, height: this.options.height };
	        this.playerInfo.previousSize = this.playerInfo.currentSize = this.playerInfo.computedSize = size;
	        this.updateSize();

	        this.previousSize = { width: this.$el.width(), height: this.$el.height() };

	        this.enableResizeObserver();

	        return this;
	    };

	    return Core;
	}(_ui_object2.default);

	exports.default = Core;
	module.exports = exports['default'];

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var Styler = {
	    getStyleFor: function getStyleFor(style) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { baseUrl: '' };

	        if (options.customCSS) {
	            return "";
	        }
	        return (0, _clapprZepto2.default)('<style class="zplayer-style"></style>').html((0, _template2.default)(style.toString())(options));
	    }
	};

	exports.default = Styler;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports) {

	/* Zepto v1.1.4-80-ga9184b2 - zepto event ajax callbacks deferred touch selector ie - zeptojs.com/license */
	var Zepto=function(){function D(t){return null==t?String(t):j[S.call(t)]||"object"}function L(t){return"function"==D(t)}function k(t){return null!=t&&t==t.window}function Z(t){return null!=t&&t.nodeType==t.DOCUMENT_NODE}function $(t){return"object"==D(t)}function F(t){return $(t)&&!k(t)&&Object.getPrototypeOf(t)==Object.prototype}function R(t){return"number"==typeof t.length}function q(t){return s.call(t,function(t){return null!=t})}function W(t){return t.length>0?n.fn.concat.apply([],t):t}function z(t){return t.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()}function H(t){return t in c?c[t]:c[t]=new RegExp("(^|\\s)"+t+"(\\s|$)")}function _(t,e){return"number"!=typeof e||l[z(t)]?e:e+"px"}function I(t){var e,n;return f[t]||(e=u.createElement(t),u.body.appendChild(e),n=getComputedStyle(e,"").getPropertyValue("display"),e.parentNode.removeChild(e),"none"==n&&(n="block"),f[t]=n),f[t]}function U(t){return"children"in t?a.call(t.children):n.map(t.childNodes,function(t){return 1==t.nodeType?t:void 0})}function X(t,e){var n,i=t?t.length:0;for(n=0;i>n;n++)this[n]=t[n];this.length=i,this.selector=e||""}function B(n,i,r){for(e in i)r&&(F(i[e])||A(i[e]))?(F(i[e])&&!F(n[e])&&(n[e]={}),A(i[e])&&!A(n[e])&&(n[e]=[]),B(n[e],i[e],r)):i[e]!==t&&(n[e]=i[e])}function V(t,e){return null==e?n(t):n(t).filter(e)}function Y(t,e,n,i){return L(e)?e.call(t,n,i):e}function J(t,e,n){null==n?t.removeAttribute(e):t.setAttribute(e,n)}function G(e,n){var i=e.className||"",r=i&&i.baseVal!==t;return n===t?r?i.baseVal:i:void(r?i.baseVal=n:e.className=n)}function K(t){try{return t?"true"==t||("false"==t?!1:"null"==t?null:+t+""==t?+t:/^[\[\{]/.test(t)?n.parseJSON(t):t):t}catch(e){return t}}function Q(t,e){e(t);for(var n=0,i=t.childNodes.length;i>n;n++)Q(t.childNodes[n],e)}var t,e,n,i,N,P,r=[],o=r.concat,s=r.filter,a=r.slice,u=window.document,f={},c={},l={"column-count":1,columns:1,"font-weight":1,"line-height":1,opacity:1,"z-index":1,zoom:1},h=/^\s*<(\w+|!)[^>]*>/,p=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,d=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,m=/^(?:body|html)$/i,g=/([A-Z])/g,v=["val","css","html","text","data","width","height","offset"],y=["after","prepend","before","append"],w=u.createElement("table"),x=u.createElement("tr"),b={tr:u.createElement("tbody"),tbody:w,thead:w,tfoot:w,td:x,th:x,"*":u.createElement("div")},E=/complete|loaded|interactive/,T=/^[\w-]*$/,j={},S=j.toString,C={},O=u.createElement("div"),M={tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},A=Array.isArray||function(t){return t instanceof Array};return C.matches=function(t,e){if(!e||!t||1!==t.nodeType)return!1;var n=t.webkitMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.matchesSelector;if(n)return n.call(t,e);var i,r=t.parentNode,o=!r;return o&&(r=O).appendChild(t),i=~C.qsa(r,e).indexOf(t),o&&O.removeChild(t),i},N=function(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():""})},P=function(t){return s.call(t,function(e,n){return t.indexOf(e)==n})},C.fragment=function(e,i,r){var o,s,f;return p.test(e)&&(o=n(u.createElement(RegExp.$1))),o||(e.replace&&(e=e.replace(d,"<$1></$2>")),i===t&&(i=h.test(e)&&RegExp.$1),i in b||(i="*"),f=b[i],f.innerHTML=""+e,o=n.each(a.call(f.childNodes),function(){f.removeChild(this)})),F(r)&&(s=n(o),n.each(r,function(t,e){v.indexOf(t)>-1?s[t](e):s.attr(t,e)})),o},C.Z=function(t,e){return new X(t,e)},C.isZ=function(t){return t instanceof C.Z},C.init=function(e,i){var r;if(!e)return C.Z();if("string"==typeof e)if(e=e.trim(),"<"==e[0]&&h.test(e))r=C.fragment(e,RegExp.$1,i),e=null;else{if(i!==t)return n(i).find(e);r=C.qsa(u,e)}else{if(L(e))return n(u).ready(e);if(C.isZ(e))return e;if(A(e))r=q(e);else if($(e))r=[e],e=null;else if(h.test(e))r=C.fragment(e.trim(),RegExp.$1,i),e=null;else{if(i!==t)return n(i).find(e);r=C.qsa(u,e)}}return C.Z(r,e)},n=function(t,e){return C.init(t,e)},n.extend=function(t){var e,n=a.call(arguments,1);return"boolean"==typeof t&&(e=t,t=n.shift()),n.forEach(function(n){B(t,n,e)}),t},C.qsa=function(t,e){var n,i="#"==e[0],r=!i&&"."==e[0],o=i||r?e.slice(1):e,s=T.test(o);return t.getElementById&&s&&i?(n=t.getElementById(o))?[n]:[]:1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType?[]:a.call(s&&!i&&t.getElementsByClassName?r?t.getElementsByClassName(o):t.getElementsByTagName(e):t.querySelectorAll(e))},n.contains=u.documentElement.contains?function(t,e){return t!==e&&t.contains(e)}:function(t,e){for(;e&&(e=e.parentNode);)if(e===t)return!0;return!1},n.type=D,n.isFunction=L,n.isWindow=k,n.isArray=A,n.isPlainObject=F,n.isEmptyObject=function(t){var e;for(e in t)return!1;return!0},n.inArray=function(t,e,n){return r.indexOf.call(e,t,n)},n.camelCase=N,n.trim=function(t){return null==t?"":String.prototype.trim.call(t)},n.uuid=0,n.support={},n.expr={},n.noop=function(){},n.map=function(t,e){var n,r,o,i=[];if(R(t))for(r=0;r<t.length;r++)n=e(t[r],r),null!=n&&i.push(n);else for(o in t)n=e(t[o],o),null!=n&&i.push(n);return W(i)},n.each=function(t,e){var n,i;if(R(t)){for(n=0;n<t.length;n++)if(e.call(t[n],n,t[n])===!1)return t}else for(i in t)if(e.call(t[i],i,t[i])===!1)return t;return t},n.grep=function(t,e){return s.call(t,e)},window.JSON&&(n.parseJSON=JSON.parse),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(t,e){j["[object "+e+"]"]=e.toLowerCase()}),n.fn={constructor:C.Z,length:0,forEach:r.forEach,reduce:r.reduce,push:r.push,sort:r.sort,splice:r.splice,indexOf:r.indexOf,concat:function(){var t,e,n=[];for(t=0;t<arguments.length;t++)e=arguments[t],n[t]=C.isZ(e)?e.toArray():e;return o.apply(C.isZ(this)?this.toArray():this,n)},map:function(t){return n(n.map(this,function(e,n){return t.call(e,n,e)}))},slice:function(){return n(a.apply(this,arguments))},ready:function(t){return E.test(u.readyState)&&u.body?t(n):u.addEventListener("DOMContentLoaded",function(){t(n)},!1),this},get:function(e){return e===t?a.call(this):this[e>=0?e:e+this.length]},toArray:function(){return this.get()},size:function(){return this.length},remove:function(){return this.each(function(){null!=this.parentNode&&this.parentNode.removeChild(this)})},each:function(t){return r.every.call(this,function(e,n){return t.call(e,n,e)!==!1}),this},filter:function(t){return L(t)?this.not(this.not(t)):n(s.call(this,function(e){return C.matches(e,t)}))},add:function(t,e){return n(P(this.concat(n(t,e))))},is:function(t){return this.length>0&&C.matches(this[0],t)},not:function(e){var i=[];if(L(e)&&e.call!==t)this.each(function(t){e.call(this,t)||i.push(this)});else{var r="string"==typeof e?this.filter(e):R(e)&&L(e.item)?a.call(e):n(e);this.forEach(function(t){r.indexOf(t)<0&&i.push(t)})}return n(i)},has:function(t){return this.filter(function(){return $(t)?n.contains(this,t):n(this).find(t).size()})},eq:function(t){return-1===t?this.slice(t):this.slice(t,+t+1)},first:function(){var t=this[0];return t&&!$(t)?t:n(t)},last:function(){var t=this[this.length-1];return t&&!$(t)?t:n(t)},find:function(t){var e,i=this;return e=t?"object"==typeof t?n(t).filter(function(){var t=this;return r.some.call(i,function(e){return n.contains(e,t)})}):1==this.length?n(C.qsa(this[0],t)):this.map(function(){return C.qsa(this,t)}):n()},closest:function(t,e){var i=this[0],r=!1;for("object"==typeof t&&(r=n(t));i&&!(r?r.indexOf(i)>=0:C.matches(i,t));)i=i!==e&&!Z(i)&&i.parentNode;return n(i)},parents:function(t){for(var e=[],i=this;i.length>0;)i=n.map(i,function(t){return(t=t.parentNode)&&!Z(t)&&e.indexOf(t)<0?(e.push(t),t):void 0});return V(e,t)},parent:function(t){return V(P(this.pluck("parentNode")),t)},children:function(t){return V(this.map(function(){return U(this)}),t)},contents:function(){return this.map(function(){return this.contentDocument||a.call(this.childNodes)})},siblings:function(t){return V(this.map(function(t,e){return s.call(U(e.parentNode),function(t){return t!==e})}),t)},empty:function(){return this.each(function(){this.innerHTML=""})},pluck:function(t){return n.map(this,function(e){return e[t]})},show:function(){return this.each(function(){"none"==this.style.display&&(this.style.display=""),"none"==getComputedStyle(this,"").getPropertyValue("display")&&(this.style.display=I(this.nodeName))})},replaceWith:function(t){return this.before(t).remove()},wrap:function(t){var e=L(t);if(this[0]&&!e)var i=n(t).get(0),r=i.parentNode||this.length>1;return this.each(function(o){n(this).wrapAll(e?t.call(this,o):r?i.cloneNode(!0):i)})},wrapAll:function(t){if(this[0]){n(this[0]).before(t=n(t));for(var e;(e=t.children()).length;)t=e.first();n(t).append(this)}return this},wrapInner:function(t){var e=L(t);return this.each(function(i){var r=n(this),o=r.contents(),s=e?t.call(this,i):t;o.length?o.wrapAll(s):r.append(s)})},unwrap:function(){return this.parent().each(function(){n(this).replaceWith(n(this).children())}),this},clone:function(){return this.map(function(){return this.cloneNode(!0)})},hide:function(){return this.css("display","none")},toggle:function(e){return this.each(function(){var i=n(this);(e===t?"none"==i.css("display"):e)?i.show():i.hide()})},prev:function(t){return n(this.pluck("previousElementSibling")).filter(t||"*")},next:function(t){return n(this.pluck("nextElementSibling")).filter(t||"*")},html:function(t){return 0 in arguments?this.each(function(e){var i=this.innerHTML;n(this).empty().append(Y(this,t,e,i))}):0 in this?this[0].innerHTML:null},text:function(t){return 0 in arguments?this.each(function(e){var n=Y(this,t,e,this.textContent);this.textContent=null==n?"":""+n}):0 in this?this[0].textContent:null},attr:function(n,i){var r;return"string"!=typeof n||1 in arguments?this.each(function(t){if(1===this.nodeType)if($(n))for(e in n)J(this,e,n[e]);else J(this,n,Y(this,i,t,this.getAttribute(n)))}):this.length&&1===this[0].nodeType?!(r=this[0].getAttribute(n))&&n in this[0]?this[0][n]:r:t},removeAttr:function(t){return this.each(function(){1===this.nodeType&&t.split(" ").forEach(function(t){J(this,t)},this)})},prop:function(t,e){return t=M[t]||t,1 in arguments?this.each(function(n){this[t]=Y(this,e,n,this[t])}):this[0]&&this[0][t]},data:function(e,n){var i="data-"+e.replace(g,"-$1").toLowerCase(),r=1 in arguments?this.attr(i,n):this.attr(i);return null!==r?K(r):t},val:function(t){return 0 in arguments?this.each(function(e){this.value=Y(this,t,e,this.value)}):this[0]&&(this[0].multiple?n(this[0]).find("option").filter(function(){return this.selected}).pluck("value"):this[0].value)},offset:function(t){if(t)return this.each(function(e){var i=n(this),r=Y(this,t,e,i.offset()),o=i.offsetParent().offset(),s={top:r.top-o.top,left:r.left-o.left};"static"==i.css("position")&&(s.position="relative"),i.css(s)});if(!this.length)return null;if(!n.contains(u.documentElement,this[0]))return{top:0,left:0};var e=this[0].getBoundingClientRect();return{left:e.left+window.pageXOffset,top:e.top+window.pageYOffset,width:Math.round(e.width),height:Math.round(e.height)}},css:function(t,i){if(arguments.length<2){var r,o=this[0];if(!o)return;if(r=getComputedStyle(o,""),"string"==typeof t)return o.style[N(t)]||r.getPropertyValue(t);if(A(t)){var s={};return n.each(t,function(t,e){s[e]=o.style[N(e)]||r.getPropertyValue(e)}),s}}var a="";if("string"==D(t))i||0===i?a=z(t)+":"+_(t,i):this.each(function(){this.style.removeProperty(z(t))});else for(e in t)t[e]||0===t[e]?a+=z(e)+":"+_(e,t[e])+";":this.each(function(){this.style.removeProperty(z(e))});return this.each(function(){this.style.cssText+=";"+a})},index:function(t){return t?this.indexOf(n(t)[0]):this.parent().children().indexOf(this[0])},hasClass:function(t){return t?r.some.call(this,function(t){return this.test(G(t))},H(t)):!1},addClass:function(t){return t?this.each(function(e){if("className"in this){i=[];var r=G(this),o=Y(this,t,e,r);o.split(/\s+/g).forEach(function(t){n(this).hasClass(t)||i.push(t)},this),i.length&&G(this,r+(r?" ":"")+i.join(" "))}}):this},removeClass:function(e){return this.each(function(n){if("className"in this){if(e===t)return G(this,"");i=G(this),Y(this,e,n,i).split(/\s+/g).forEach(function(t){i=i.replace(H(t)," ")}),G(this,i.trim())}})},toggleClass:function(e,i){return e?this.each(function(r){var o=n(this),s=Y(this,e,r,G(this));s.split(/\s+/g).forEach(function(e){(i===t?!o.hasClass(e):i)?o.addClass(e):o.removeClass(e)})}):this},scrollTop:function(e){if(this.length){var n="scrollTop"in this[0];return e===t?n?this[0].scrollTop:this[0].pageYOffset:this.each(n?function(){this.scrollTop=e}:function(){this.scrollTo(this.scrollX,e)})}},scrollLeft:function(e){if(this.length){var n="scrollLeft"in this[0];return e===t?n?this[0].scrollLeft:this[0].pageXOffset:this.each(n?function(){this.scrollLeft=e}:function(){this.scrollTo(e,this.scrollY)})}},position:function(){if(this.length){var t=this[0],e=this.offsetParent(),i=this.offset(),r=m.test(e[0].nodeName)?{top:0,left:0}:e.offset();return i.top-=parseFloat(n(t).css("margin-top"))||0,i.left-=parseFloat(n(t).css("margin-left"))||0,r.top+=parseFloat(n(e[0]).css("border-top-width"))||0,r.left+=parseFloat(n(e[0]).css("border-left-width"))||0,{top:i.top-r.top,left:i.left-r.left}}},offsetParent:function(){return this.map(function(){for(var t=this.offsetParent||u.body;t&&!m.test(t.nodeName)&&"static"==n(t).css("position");)t=t.offsetParent;return t})}},n.fn.detach=n.fn.remove,["width","height"].forEach(function(e){var i=e.replace(/./,function(t){return t[0].toUpperCase()});n.fn[e]=function(r){var o,s=this[0];return r===t?k(s)?s["inner"+i]:Z(s)?s.documentElement["scroll"+i]:(o=this.offset())&&o[e]:this.each(function(t){s=n(this),s.css(e,Y(this,r,t,s[e]()))})}}),y.forEach(function(t,e){var i=e%2;n.fn[t]=function(){var t,o,r=n.map(arguments,function(e){return t=D(e),"object"==t||"array"==t||null==e?e:C.fragment(e)}),s=this.length>1;return r.length<1?this:this.each(function(t,a){o=i?a:a.parentNode,a=0==e?a.nextSibling:1==e?a.firstChild:2==e?a:null;var f=n.contains(u.documentElement,o);r.forEach(function(t){if(s)t=t.cloneNode(!0);else if(!o)return n(t).remove();o.insertBefore(t,a),f&&Q(t,function(t){null==t.nodeName||"SCRIPT"!==t.nodeName.toUpperCase()||t.type&&"text/javascript"!==t.type||t.src||window.eval.call(window,t.innerHTML)})})})},n.fn[i?t+"To":"insert"+(e?"Before":"After")]=function(e){return n(e)[t](this),this}}),C.Z.prototype=X.prototype=n.fn,C.uniq=P,C.deserializeValue=K,n.zepto=C,n}();window.Zepto=Zepto,void 0===window.$&&(window.$=Zepto),function(t){function l(t){return t._zid||(t._zid=e++)}function h(t,e,n,i){if(e=p(e),e.ns)var r=d(e.ns);return(s[l(t)]||[]).filter(function(t){return!(!t||e.e&&t.e!=e.e||e.ns&&!r.test(t.ns)||n&&l(t.fn)!==l(n)||i&&t.sel!=i)})}function p(t){var e=(""+t).split(".");return{e:e[0],ns:e.slice(1).sort().join(" ")}}function d(t){return new RegExp("(?:^| )"+t.replace(" "," .* ?")+"(?: |$)")}function m(t,e){return t.del&&!u&&t.e in f||!!e}function g(t){return c[t]||u&&f[t]||t}function v(e,i,r,o,a,u,f){var h=l(e),d=s[h]||(s[h]=[]);i.split(/\s/).forEach(function(i){if("ready"==i)return t(document).ready(r);var s=p(i);s.fn=r,s.sel=a,s.e in c&&(r=function(e){var n=e.relatedTarget;return!n||n!==this&&!t.contains(this,n)?s.fn.apply(this,arguments):void 0}),s.del=u;var l=u||r;s.proxy=function(t){if(t=T(t),!t.isImmediatePropagationStopped()){t.data=o;var i=l.apply(e,t._args==n?[t]:[t].concat(t._args));return i===!1&&(t.preventDefault(),t.stopPropagation()),i}},s.i=d.length,d.push(s),"addEventListener"in e&&e.addEventListener(g(s.e),s.proxy,m(s,f))})}function y(t,e,n,i,r){var o=l(t);(e||"").split(/\s/).forEach(function(e){h(t,e,n,i).forEach(function(e){delete s[o][e.i],"removeEventListener"in t&&t.removeEventListener(g(e.e),e.proxy,m(e,r))})})}function T(e,i){return(i||!e.isDefaultPrevented)&&(i||(i=e),t.each(E,function(t,n){var r=i[t];e[t]=function(){return this[n]=w,r&&r.apply(i,arguments)},e[n]=x}),(i.defaultPrevented!==n?i.defaultPrevented:"returnValue"in i?i.returnValue===!1:i.getPreventDefault&&i.getPreventDefault())&&(e.isDefaultPrevented=w)),e}function j(t){var e,i={originalEvent:t};for(e in t)b.test(e)||t[e]===n||(i[e]=t[e]);return T(i,t)}var n,e=1,i=Array.prototype.slice,r=t.isFunction,o=function(t){return"string"==typeof t},s={},a={},u="onfocusin"in window,f={focus:"focusin",blur:"focusout"},c={mouseenter:"mouseover",mouseleave:"mouseout"};a.click=a.mousedown=a.mouseup=a.mousemove="MouseEvents",t.event={add:v,remove:y},t.proxy=function(e,n){var s=2 in arguments&&i.call(arguments,2);if(r(e)){var a=function(){return e.apply(n,s?s.concat(i.call(arguments)):arguments)};return a._zid=l(e),a}if(o(n))return s?(s.unshift(e[n],e),t.proxy.apply(null,s)):t.proxy(e[n],e);throw new TypeError("expected function")},t.fn.bind=function(t,e,n){return this.on(t,e,n)},t.fn.unbind=function(t,e){return this.off(t,e)},t.fn.one=function(t,e,n,i){return this.on(t,e,n,i,1)};var w=function(){return!0},x=function(){return!1},b=/^([A-Z]|returnValue$|layer[XY]$)/,E={preventDefault:"isDefaultPrevented",stopImmediatePropagation:"isImmediatePropagationStopped",stopPropagation:"isPropagationStopped"};t.fn.delegate=function(t,e,n){return this.on(e,t,n)},t.fn.undelegate=function(t,e,n){return this.off(e,t,n)},t.fn.live=function(e,n){return t(document.body).delegate(this.selector,e,n),this},t.fn.die=function(e,n){return t(document.body).undelegate(this.selector,e,n),this},t.fn.on=function(e,s,a,u,f){var c,l,h=this;return e&&!o(e)?(t.each(e,function(t,e){h.on(t,s,a,e,f)}),h):(o(s)||r(u)||u===!1||(u=a,a=s,s=n),(u===n||a===!1)&&(u=a,a=n),u===!1&&(u=x),h.each(function(n,r){f&&(c=function(t){return y(r,t.type,u),u.apply(this,arguments)}),s&&(l=function(e){var n,o=t(e.target).closest(s,r).get(0);return o&&o!==r?(n=t.extend(j(e),{currentTarget:o,liveFired:r}),(c||u).apply(o,[n].concat(i.call(arguments,1)))):void 0}),v(r,e,u,a,s,l||c)}))},t.fn.off=function(e,i,s){var a=this;return e&&!o(e)?(t.each(e,function(t,e){a.off(t,i,e)}),a):(o(i)||r(s)||s===!1||(s=i,i=n),s===!1&&(s=x),a.each(function(){y(this,e,s,i)}))},t.fn.trigger=function(e,n){return e=o(e)||t.isPlainObject(e)?t.Event(e):T(e),e._args=n,this.each(function(){e.type in f&&"function"==typeof this[e.type]?this[e.type]():"dispatchEvent"in this?this.dispatchEvent(e):t(this).triggerHandler(e,n)})},t.fn.triggerHandler=function(e,n){var i,r;return this.each(function(s,a){i=j(o(e)?t.Event(e):e),i._args=n,i.target=a,t.each(h(a,e.type||e),function(t,e){return r=e.proxy(i),i.isImmediatePropagationStopped()?!1:void 0})}),r},"focusin focusout focus blur load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select keydown keypress keyup error".split(" ").forEach(function(e){t.fn[e]=function(t){return 0 in arguments?this.bind(e,t):this.trigger(e)}}),t.Event=function(t,e){o(t)||(e=t,t=e.type);var n=document.createEvent(a[t]||"Events"),i=!0;if(e)for(var r in e)"bubbles"==r?i=!!e[r]:n[r]=e[r];return n.initEvent(t,i,!0),T(n)}}(Zepto),function(t){function h(e,n,i){var r=t.Event(n);return t(e).trigger(r,i),!r.isDefaultPrevented()}function p(t,e,i,r){return t.global?h(e||n,i,r):void 0}function d(e){e.global&&0===t.active++&&p(e,null,"ajaxStart")}function m(e){e.global&&!--t.active&&p(e,null,"ajaxStop")}function g(t,e){var n=e.context;return e.beforeSend.call(n,t,e)===!1||p(e,n,"ajaxBeforeSend",[t,e])===!1?!1:void p(e,n,"ajaxSend",[t,e])}function v(t,e,n,i){var r=n.context,o="success";n.success.call(r,t,o,e),i&&i.resolveWith(r,[t,o,e]),p(n,r,"ajaxSuccess",[e,n,t]),w(o,e,n)}function y(t,e,n,i,r){var o=i.context;i.error.call(o,n,e,t),r&&r.rejectWith(o,[n,e,t]),p(i,o,"ajaxError",[n,i,t||e]),w(e,n,i)}function w(t,e,n){var i=n.context;n.complete.call(i,e,t),p(n,i,"ajaxComplete",[e,n]),m(n)}function x(){}function b(t){return t&&(t=t.split(";",2)[0]),t&&(t==f?"html":t==u?"json":s.test(t)?"script":a.test(t)&&"xml")||"text"}function E(t,e){return""==e?t:(t+"&"+e).replace(/[&?]{1,2}/,"?")}function T(e){e.processData&&e.data&&"string"!=t.type(e.data)&&(e.data=t.param(e.data,e.traditional)),!e.data||e.type&&"GET"!=e.type.toUpperCase()||(e.url=E(e.url,e.data),e.data=void 0)}function j(e,n,i,r){return t.isFunction(n)&&(r=i,i=n,n=void 0),t.isFunction(i)||(r=i,i=void 0),{url:e,data:n,success:i,dataType:r}}function C(e,n,i,r){var o,s=t.isArray(n),a=t.isPlainObject(n);t.each(n,function(n,u){o=t.type(u),r&&(n=i?r:r+"["+(a||"object"==o||"array"==o?n:"")+"]"),!r&&s?e.add(u.name,u.value):"array"==o||!i&&"object"==o?C(e,u,i,n):e.add(n,u)})}var i,r,e=0,n=window.document,o=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,s=/^(?:text|application)\/javascript/i,a=/^(?:text|application)\/xml/i,u="application/json",f="text/html",c=/^\s*$/,l=n.createElement("a");l.href=window.location.href,t.active=0,t.ajaxJSONP=function(i,r){if(!("type"in i))return t.ajax(i);var f,h,o=i.jsonpCallback,s=(t.isFunction(o)?o():o)||"jsonp"+ ++e,a=n.createElement("script"),u=window[s],c=function(e){t(a).triggerHandler("error",e||"abort")},l={abort:c};return r&&r.promise(l),t(a).on("load error",function(e,n){clearTimeout(h),t(a).off().remove(),"error"!=e.type&&f?v(f[0],l,i,r):y(null,n||"error",l,i,r),window[s]=u,f&&t.isFunction(u)&&u(f[0]),u=f=void 0}),g(l,i)===!1?(c("abort"),l):(window[s]=function(){f=arguments},a.src=i.url.replace(/\?(.+)=\?/,"?$1="+s),n.head.appendChild(a),i.timeout>0&&(h=setTimeout(function(){c("timeout")},i.timeout)),l)},t.ajaxSettings={type:"GET",beforeSend:x,success:x,error:x,complete:x,context:null,global:!0,xhr:function(){return new window.XMLHttpRequest},accepts:{script:"text/javascript, application/javascript, application/x-javascript",json:u,xml:"application/xml, text/xml",html:f,text:"text/plain"},crossDomain:!1,timeout:0,processData:!0,cache:!0},t.ajax=function(e){var a,u,o=t.extend({},e||{}),s=t.Deferred&&t.Deferred();for(i in t.ajaxSettings)void 0===o[i]&&(o[i]=t.ajaxSettings[i]);d(o),o.crossDomain||(a=n.createElement("a"),a.href=o.url,a.href=a.href,o.crossDomain=l.protocol+"//"+l.host!=a.protocol+"//"+a.host),o.url||(o.url=window.location.toString()),(u=o.url.indexOf("#"))>-1&&(o.url=o.url.slice(0,u)),T(o);var f=o.dataType,h=/\?.+=\?/.test(o.url);if(h&&(f="jsonp"),o.cache!==!1&&(e&&e.cache===!0||"script"!=f&&"jsonp"!=f)||(o.url=E(o.url,"_="+Date.now())),"jsonp"==f)return h||(o.url=E(o.url,o.jsonp?o.jsonp+"=?":o.jsonp===!1?"":"callback=?")),t.ajaxJSONP(o,s);var N,p=o.accepts[f],m={},w=function(t,e){m[t.toLowerCase()]=[t,e]},j=/^([\w-]+:)\/\//.test(o.url)?RegExp.$1:window.location.protocol,S=o.xhr(),C=S.setRequestHeader;if(s&&s.promise(S),o.crossDomain||w("X-Requested-With","XMLHttpRequest"),w("Accept",p||"*/*"),(p=o.mimeType||p)&&(p.indexOf(",")>-1&&(p=p.split(",",2)[0]),S.overrideMimeType&&S.overrideMimeType(p)),(o.contentType||o.contentType!==!1&&o.data&&"GET"!=o.type.toUpperCase())&&w("Content-Type",o.contentType||"application/x-www-form-urlencoded"),o.headers)for(r in o.headers)w(r,o.headers[r]);if(S.setRequestHeader=w,S.onreadystatechange=function(){if(4==S.readyState){S.onreadystatechange=x,clearTimeout(N);var e,n=!1;if(S.status>=200&&S.status<300||304==S.status||0==S.status&&"file:"==j){f=f||b(o.mimeType||S.getResponseHeader("content-type")),e=S.responseText;try{"script"==f?(1,eval)(e):"xml"==f?e=S.responseXML:"json"==f&&(e=c.test(e)?null:t.parseJSON(e))}catch(i){n=i}n?y(n,"parsererror",S,o,s):v(e,S,o,s)}else y(S.statusText||null,S.status?"error":"abort",S,o,s)}},g(S,o)===!1)return S.abort(),y(null,"abort",S,o,s),S;if(o.xhrFields)for(r in o.xhrFields)S[r]=o.xhrFields[r];var P="async"in o?o.async:!0;S.open(o.type,o.url,P,o.username,o.password);for(r in m)C.apply(S,m[r]);return o.timeout>0&&(N=setTimeout(function(){S.onreadystatechange=x,S.abort(),y(null,"timeout",S,o,s)},o.timeout)),S.send(o.data?o.data:null),S},t.get=function(){return t.ajax(j.apply(null,arguments))},t.post=function(){var e=j.apply(null,arguments);return e.type="POST",t.ajax(e)},t.getJSON=function(){var e=j.apply(null,arguments);return e.dataType="json",t.ajax(e)},t.fn.load=function(e,n,i){if(!this.length)return this;var a,r=this,s=e.split(/\s/),u=j(e,n,i),f=u.success;return s.length>1&&(u.url=s[0],a=s[1]),u.success=function(e){r.html(a?t("<div>").html(e.replace(o,"")).find(a):e),f&&f.apply(r,arguments)},t.ajax(u),this};var S=encodeURIComponent;t.param=function(e,n){var i=[];return i.add=function(e,n){t.isFunction(n)&&(n=n()),null==n&&(n=""),this.push(S(e)+"="+S(n))},C(i,e,n),i.join("&").replace(/%20/g,"+")}}(Zepto),function(t){t.Callbacks=function(e){e=t.extend({},e);var n,i,r,o,s,a,u=[],f=!e.once&&[],c=function(t){for(n=e.memory&&t,i=!0,a=o||0,o=0,s=u.length,r=!0;u&&s>a;++a)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}r=!1,u&&(f?f.length&&c(f.shift()):n?u.length=0:l.disable())},l={add:function(){if(u){var i=u.length,a=function(n){t.each(n,function(t,n){"function"==typeof n?e.unique&&l.has(n)||u.push(n):n&&n.length&&"string"!=typeof n&&a(n)})};a(arguments),r?s=u.length:n&&(o=i,c(n))}return this},remove:function(){return u&&t.each(arguments,function(e,n){for(var i;(i=t.inArray(n,u,i))>-1;)u.splice(i,1),r&&(s>=i&&--s,a>=i&&--a)}),this},has:function(e){return!(!u||!(e?t.inArray(e,u)>-1:u.length))},empty:function(){return s=u.length=0,this},disable:function(){return u=f=n=void 0,this},disabled:function(){return!u},lock:function(){return f=void 0,n||l.disable(),this},locked:function(){return!f},fireWith:function(t,e){return!u||i&&!f||(e=e||[],e=[t,e.slice?e.slice():e],r?f.push(e):c(e)),this},fire:function(){return l.fireWith(this,arguments)},fired:function(){return!!i}};return l}}(Zepto),function(t){function n(e){var i=[["resolve","done",t.Callbacks({once:1,memory:1}),"resolved"],["reject","fail",t.Callbacks({once:1,memory:1}),"rejected"],["notify","progress",t.Callbacks({memory:1})]],r="pending",o={state:function(){return r},always:function(){return s.done(arguments).fail(arguments),this},then:function(){var e=arguments;return n(function(n){t.each(i,function(i,r){var a=t.isFunction(e[i])&&e[i];s[r[1]](function(){var e=a&&a.apply(this,arguments);if(e&&t.isFunction(e.promise))e.promise().done(n.resolve).fail(n.reject).progress(n.notify);else{var i=this===o?n.promise():this,s=a?[e]:arguments;n[r[0]+"With"](i,s)}})}),e=null}).promise()},promise:function(e){return null!=e?t.extend(e,o):o}},s={};return t.each(i,function(t,e){var n=e[2],a=e[3];o[e[1]]=n.add,a&&n.add(function(){r=a},i[1^t][2].disable,i[2][2].lock),s[e[0]]=function(){return s[e[0]+"With"](this===s?o:this,arguments),this},s[e[0]+"With"]=n.fireWith}),o.promise(s),e&&e.call(s,s),s}var e=Array.prototype.slice;t.when=function(i){var f,c,l,r=e.call(arguments),o=r.length,s=0,a=1!==o||i&&t.isFunction(i.promise)?o:0,u=1===a?i:n(),h=function(t,n,i){return function(r){n[t]=this,i[t]=arguments.length>1?e.call(arguments):r,i===f?u.notifyWith(n,i):--a||u.resolveWith(n,i)}};if(o>1)for(f=new Array(o),c=new Array(o),l=new Array(o);o>s;++s)r[s]&&t.isFunction(r[s].promise)?r[s].promise().done(h(s,l,r)).fail(u.reject).progress(h(s,c,f)):--a;return a||u.resolveWith(l,r),u.promise()},t.Deferred=n}(Zepto),function(t){function u(t,e,n,i){return Math.abs(t-e)>=Math.abs(n-i)?t-e>0?"Left":"Right":n-i>0?"Up":"Down"}function f(){o=null,e.last&&(e.el.trigger("longTap"),e={})}function c(){o&&clearTimeout(o),o=null}function l(){n&&clearTimeout(n),i&&clearTimeout(i),r&&clearTimeout(r),o&&clearTimeout(o),n=i=r=o=null,e={}}function h(t){return("touch"==t.pointerType||t.pointerType==t.MSPOINTER_TYPE_TOUCH)&&t.isPrimary}function p(t,e){return t.type=="pointer"+e||t.type.toLowerCase()=="mspointer"+e}var n,i,r,o,a,e={},s=750;t(document).ready(function(){var d,m,y,w,g=0,v=0;"MSGesture"in window&&(a=new MSGesture,a.target=document.body),t(document).bind("MSGestureEnd",function(t){var n=t.velocityX>1?"Right":t.velocityX<-1?"Left":t.velocityY>1?"Down":t.velocityY<-1?"Up":null;n&&(e.el.trigger("swipe"),e.el.trigger("swipe"+n))}).on("touchstart MSPointerDown pointerdown",function(i){(!(w=p(i,"down"))||h(i))&&(y=w?i:i.touches[0],i.touches&&1===i.touches.length&&e.x2&&(e.x2=void 0,e.y2=void 0),d=Date.now(),m=d-(e.last||d),e.el=t("tagName"in y.target?y.target:y.target.parentNode),n&&clearTimeout(n),e.x1=y.pageX,e.y1=y.pageY,m>0&&250>=m&&(e.isDoubleTap=!0),e.last=d,o=setTimeout(f,s),a&&w&&a.addPointer(i.pointerId))}).on("touchmove MSPointerMove pointermove",function(t){(!(w=p(t,"move"))||h(t))&&(y=w?t:t.touches[0],c(),e.x2=y.pageX,e.y2=y.pageY,g+=Math.abs(e.x1-e.x2),v+=Math.abs(e.y1-e.y2))}).on("touchend MSPointerUp pointerup",function(o){(!(w=p(o,"up"))||h(o))&&(c(),e.x2&&Math.abs(e.x1-e.x2)>30||e.y2&&Math.abs(e.y1-e.y2)>30?r=setTimeout(function(){e.el.trigger("swipe"),e.el.trigger("swipe"+u(e.x1,e.x2,e.y1,e.y2)),e={}},0):"last"in e&&(30>g&&30>v?i=setTimeout(function(){var i=t.Event("tap");i.cancelTouch=l,e.el.trigger(i),e.isDoubleTap?(e.el&&e.el.trigger("doubleTap"),e={}):n=setTimeout(function(){n=null,e.el&&e.el.trigger("singleTap"),e={}},250)},0):e={}),g=v=0)}).on("touchcancel MSPointerCancel pointercancel",l),t(window).on("scroll",l)}),["swipe","swipeLeft","swipeRight","swipeUp","swipeDown","doubleTap","tap","singleTap","longTap"].forEach(function(e){t.fn[e]=function(t){return this.on(e,t)}})}(Zepto),function(t){function r(e){return e=t(e),!(!e.width()&&!e.height())&&"none"!==e.css("display")}function f(t,e){t=t.replace(/=#\]/g,'="#"]');var n,i,r=s.exec(t);if(r&&r[2]in o&&(n=o[r[2]],i=r[3],t=r[1],i)){var a=Number(i);i=isNaN(a)?i.replace(/^["']|["']$/g,""):a}return e(t,n,i)}var e=t.zepto,n=e.qsa,i=e.matches,o=t.expr[":"]={visible:function(){return r(this)?this:void 0},hidden:function(){return r(this)?void 0:this},selected:function(){return this.selected?this:void 0},checked:function(){return this.checked?this:void 0},parent:function(){return this.parentNode},first:function(t){return 0===t?this:void 0},last:function(t,e){return t===e.length-1?this:void 0},eq:function(t,e,n){return t===n?this:void 0},contains:function(e,n,i){return t(this).text().indexOf(i)>-1?this:void 0},has:function(t,n,i){return e.qsa(this,i).length?this:void 0}},s=new RegExp("(.*):(\\w+)(?:\\(([^)]+)\\))?$\\s*"),a=/^\s*>/,u="Zepto"+ +new Date;e.qsa=function(i,r){return f(r,function(o,s,f){try{var c;!o&&s?o="*":a.test(o)&&(c=t(i).addClass(u),o="."+u+" "+o);var l=n(i,o)}catch(h){throw console.error("error performing selector: %o",r),h}finally{c&&c.removeClass(u)}return s?e.uniq(t.map(l,function(t,e){return s.call(t,e,l,f)})):l})},e.matches=function(t,e){return f(e,function(e,n,r){return!(e&&!i(t,e)||n&&n.call(t,null,r)!==t)})}}(Zepto),function(){try{getComputedStyle(void 0)}catch(t){var e=getComputedStyle;window.getComputedStyle=function(t){try{return e(t)}catch(n){return null}}}}();
	module.exports = Zepto;


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	// Simple JavaScript Templating
	// Paul Miller (http://paulmillr.com)
	// http://underscorejs.org
	// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors

	// By default, Underscore uses ERB-style template delimiters, change the
	// following template settings to use alternative delimiters.
	var settings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	};

	// When customizing `templateSettings`, if you don't want to define an
	// interpolation, evaluation or escaping regex, we need one that is
	// guaranteed not to match.
	var noMatch = /(.)^/;

	// Certain characters need to be escaped so that they can be put into a
	// string literal.
	var escapes = {
	    '\'': '\'',
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\t': 't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	};

	var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

	// List of HTML entities for escaping.
	var htmlEntities = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    '\'': '&#x27;'
	};

	var entityRe = new RegExp('[&<>"\']', 'g');

	var escapeExpr = function escapeExpr(string) {
	    if (string === null) {
	        return '';
	    }
	    return ('' + string).replace(entityRe, function (match) {
	        return htmlEntities[match];
	    });
	};

	var counter = 0;

	// JavaScript micro-templating, similar to John Resig's implementation.
	// Underscore templating handles arbitrary delimiters, preserves whitespace,
	// and correctly escapes quotes within interpolated code.
	var tmpl = function tmpl(text, data) {
	    var render;

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = '__p+=\'';
	    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
	        source += text.slice(index, offset).replace(escaper, function (match) {
	            return '\\' + escapes[match];
	        });

	        if (escape) {
	            source += '\'+\n((__t=(' + escape + '))==null?\'\':escapeExpr(__t))+\n\'';
	        }
	        if (interpolate) {
	            source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
	        }
	        if (evaluate) {
	            source += '\';\n' + evaluate + '\n__p+=\'';
	        }
	        index = offset + match.length;
	        return match;
	    });
	    source += '\';\n';

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) {
	        source = 'with(obj||{}){\n' + source + '}\n';
	    }

	    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n//# sourceURL=/microtemplates/source[' + counter++ + ']';

	    try {

	        // TODO: find a way to avoid eval
	        render = new Function(settings.variable || 'obj', 'escapeExpr', source);
	    } catch (e) {
	        e.source = source;
	        throw e;
	    }

	    if (data) {
	        return render(data, escapeExpr);
	    }
	    var template = function template(data) {
	        return render.call(this, data, escapeExpr);
	    };

	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

	    return template;
	};
	tmpl.settings = settings;

	module.exports = tmpl;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _lodash = __webpack_require__(19);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	var UIObject = function (_BaseObject) {
	    _inherits(UIObject, _BaseObject);

	    _createClass(UIObject, [{
	        key: 'tagName',
	        get: function get() {
	            return 'div';
	        }
	    }, {
	        key: 'events',
	        get: function get() {
	            return {};
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return {};
	        }
	    }]);

	    function UIObject(options) {
	        _classCallCheck(this, UIObject);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this, options));

	        _this.cid = (0, _utils.uniqueId)('c');
	        _this._ensureElement();
	        _this.delegateEvents();
	        return _this;
	    }

	    UIObject.prototype.$ = function $(selector) {
	        return this.$el.find(selector);
	    };

	    UIObject.prototype.render = function render() {
	        return this;
	    };

	    UIObject.prototype.remove = function remove() {
	        this.$el.remove();
	        this.stopListening();
	        this.undelegateEvents();
	        return this;
	    };

	    UIObject.prototype.setElement = function setElement(element, delegate) {
	        if (this.$el) {
	            this.undelegateEvents();
	        }
	        this.$el = element instanceof _clapprZepto2.default ? element : (0, _clapprZepto2.default)(element);
	        this.el = this.$el[0];
	        if (delegate !== false) {
	            this.delegateEvents();
	        }
	        return this;
	    };

	    UIObject.prototype.delegateEvents = function delegateEvents(events) {
	        if (!(events || (events = (0, _lodash2.default)(this, 'events')))) {
	            return this;
	        }
	        // this.undelegateEvents()
	        for (var key in events) {
	            var method = events[key];
	            if (method && method.constructor !== Function) {
	                method = this[events[key]];
	            }
	            if (!method) {
	                continue;
	            }

	            var match = key.match(delegateEventSplitter);
	            var eventName = match[1],
	                selector = match[2];
	            //method = _.bind(method, this)
	            eventName += '.delegateEvents' + this.cid;
	            if (selector === '') {
	                this.$el.on(eventName, method.bind(this));
	            } else {
	                this.$el.on(eventName, selector, method.bind(this));
	            }
	        }
	        return this;
	    };

	    UIObject.prototype.undelegateEvents = function undelegateEvents() {
	        this.$el.off('.delegateEvents' + this.cid);
	        return this;
	    };

	    UIObject.prototype._ensureElement = function _ensureElement() {
	        if (!this.el) {
	            var attrs = _clapprZepto2.default.extend({}, (0, _lodash2.default)(this, 'attributes'));
	            if (this.id) {
	                attrs.id = (0, _lodash2.default)(this, 'id');
	            }
	            if (this.className) {
	                attrs['class'] = (0, _lodash2.default)(this, 'className');
	            }
	            if ((0, _lodash2.default)(this, 'tagName') == 'audio' && (0, _clapprZepto2.default)('#zplayerjs').length > 0) {
	                var $el = (0, _clapprZepto2.default)('#zplayerjs').attr(attrs);
	                this.setElement($el, false);
	            } else {
	                var _$el = (0, _clapprZepto2.default)('<' + (0, _lodash2.default)(this, 'tagName') + '>').attr(attrs);
	                this.setElement(_$el, false);
	            }
	        } else {
	            this.setElement((0, _lodash2.default)(this, 'el'), false);
	        }
	    };

	    return UIObject;
	}(_base_object2.default);

	exports.default = UIObject;
	module.exports = exports['default'];

/***/ },
/* 19 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    symbolTag = '[object Symbol]';

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    splice = arrayProto.splice;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);

	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * This method is like `_.get` except that if the resolved value is a
	 * function it's invoked with the `this` binding of its parent object and
	 * its result is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to resolve.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	 *
	 * _.result(object, 'a[0].b.c1');
	 * // => 3
	 *
	 * _.result(object, 'a[0].b.c2');
	 * // => 4
	 *
	 * _.result(object, 'a[0].b.c3', 'default');
	 * // => 'default'
	 *
	 * _.result(object, 'a[0].b.c3', _.constant('default'));
	 * // => 'default'
	 */
	function result(object, path, defaultValue) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = -1,
	      length = path.length;

	  // Ensure the loop is entered when path is empty.
	  if (!length) {
	    object = undefined;
	    length = 1;
	  }
	  while (++index < length) {
	    var value = object == null ? undefined : object[toKey(path[index])];
	    if (value === undefined) {
	      index = length;
	      value = defaultValue;
	    }
	    object = isFunction(value) ? value.call(object) : value;
	  }
	  return object;
	}

	module.exports = result;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(21);

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _container = __webpack_require__(22);

	var _container2 = _interopRequireDefault(_container);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _lodash = __webpack_require__(52);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// import find from 'lodash.find'


	var ContainerFactory = function (_BaseObject) {
	    _inherits(ContainerFactory, _BaseObject);

	    _createClass(ContainerFactory, [{
	        key: 'options',
	        get: function get() {
	            return this._options;
	        },
	        set: function set(options) {
	            this._options = options;
	        }
	    }]);

	    function ContainerFactory(options, loader, i18n) {
	        _classCallCheck(this, ContainerFactory);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this, options));

	        _this._i18n = i18n;
	        _this.loader = loader;

	        return _this;
	    }

	    ContainerFactory.prototype.createContainers = function createContainers() {
	        var _this2 = this;

	        return _clapprZepto2.default.Deferred(function (promise) {
	            promise.resolve(_this2.options.sources.map(function (source) {
	                return _this2.createContainer(source);
	            }));
	        });
	    };

	    ContainerFactory.prototype.findPlaybackPlugin = function findPlaybackPlugin(source, mimeType) {
	        return (0, _arrayPrototype2.default)(this.loader.playbackPlugins, function (p) {
	            return p != undefined && p.canPlay(source, mimeType);
	        });
	    };

	    ContainerFactory.prototype.createContainer = function createContainer(source) {
	        var resolvedSource = null,
	            mimeType = this.options.mimeType || 'audio/mp3';
	        if ((0, _lodash2.default)(source)) {
	            resolvedSource = source.source.toString();
	            if (source.mimeType) {
	                mimeType = source.mimeType;
	            }
	        } else {
	            resolvedSource = source.toString();
	        }

	        if (resolvedSource.match(/^\/\//)) resolvedSource = window.location.protocol + resolvedSource;

	        var options = _clapprZepto2.default.extend({}, this.options, {
	            src: resolvedSource,
	            mimeType: mimeType
	        });

	        if (!resolvedSource) {
	            mimeType = '';
	        }
	        var playbackPlugin = this.findPlaybackPlugin(resolvedSource, mimeType);
	        var playback = new playbackPlugin(options, this._i18n);

	        options = _clapprZepto2.default.extend({}, options, { playback: playback });
	        var container = new _container2.default(options, this._i18n);

	        playback.container = container;

	        var defer = _clapprZepto2.default.Deferred();
	        defer.promise(container);
	        this.addContainerPlugins(container);
	        this.listenToOnce(container, _events2.default.CT_READY, function () {
	            return defer.resolve(container);
	        });
	        return container;
	    };

	    ContainerFactory.prototype.addContainerPlugins = function addContainerPlugins(container) {
	        this.loader.containerPlugins.forEach(function (Plugin) {
	            Plugin != undefined && container.addPlugin(new Plugin(container));
	        });
	    };

	    return ContainerFactory;
	}(_base_object2.default);

	exports.default = ContainerFactory;
	module.exports = exports['default'];

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(23);

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _style = __webpack_require__(24);

	var _style2 = _interopRequireDefault(_style);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.


	var Container = function (_UIObject) {
	    _inherits(Container, _UIObject);

	    _createClass(Container, [{
	        key: 'name',
	        get: function get() {
	            return 'Container';
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return { class: 'zcontainer', 'data-container': '' };
	        }
	    }, {
	        key: 'events',
	        get: function get() {
	            return {
	                'click': 'clicked',
	                'dblclick': 'dblClicked',
	                'doubleTap': 'dblClicked',
	                'contextmenu': 'onContextMenu',
	                'mouseenter': 'mouseEnter',
	                'mouseleave': 'mouseLeave'
	            };
	        }
	    }, {
	        key: 'ended',
	        get: function get() {
	            return this.playback.ended;
	        }
	    }, {
	        key: 'buffering',
	        get: function get() {
	            return this.playback.buffering;
	        }
	    }, {
	        key: 'i18n',
	        get: function get() {
	            return this._i18n;
	        }
	    }]);

	    function Container(options, i18n) {
	        _classCallCheck(this, Container);

	        var _this = _possibleConstructorReturn(this, _UIObject.call(this, options));

	        _this._i18n = i18n;
	        _this.currentTime = 0;
	        _this.volume = 100;
	        _this.playback = options.playback;
	        _this.settings = _clapprZepto2.default.extend({}, _this.playback.settings);
	        _this.isReady = false;
	        _this.mediaControlDisabled = false;
	        _this.plugins = [_this.playback];
	        _this.bindEvents();

	        return _this;
	    }

	    Container.prototype.bindEvents = function bindEvents() {
	        this.listenTo(this.playback, _events2.default.PB_PROGRESS, this.progress);
	        this.listenTo(this.playback, _events2.default.PB_TIMEUPDATE, this.timeUpdated);
	        this.listenTo(this.playback, _events2.default.PB_READY, this.ready);
	        this.listenTo(this.playback, _events2.default.PB_BUFFERING, this.onBuffering);
	        this.listenTo(this.playback, _events2.default.PB_BUFFERFULL, this.bufferfull);
	        this.listenTo(this.playback, _events2.default.PB_SETTINGSUPDATE, this.settingsUpdate);
	        this.listenTo(this.playback, _events2.default.PB_LOADSTART, this.onLoadStart);
	        this.listenTo(this.playback, _events2.default.PB_LOADEDMETADATA, this.loadedMetadata);
	        this.listenTo(this.playback, _events2.default.PB_SEEKING, this.onSeeking);
	        this.listenTo(this.playback, _events2.default.PB_CANPLAY, this.onCanPlay);
	        this.listenTo(this.playback, _events2.default.PB_CANPLAYTHROUGH, this.onCanPlayThrough);
	        this.listenTo(this.playback, _events2.default.PB_WAITING, this.onWaiting);
	        this.listenTo(this.playback, _events2.default.PB_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate);
	        this.listenTo(this.playback, _events2.default.PB_BITRATE, this.updateBitrate);
	        this.listenTo(this.playback, _events2.default.PB_PLAYBACKSTATE, this.playbackStateChanged);
	        this.listenTo(this.playback, _events2.default.PB_DVR, this.playbackDvrStateChanged);
	        this.listenTo(this.playback, _events2.default.PB_MEDIACONTROL_DISABLE, this.disableMediaControl);
	        this.listenTo(this.playback, _events2.default.PB_MEDIACONTROL_ENABLE, this.enableMediaControl);
	        this.listenTo(this.playback, _events2.default.PB_ENDED, this.onEnded);
	        this.listenTo(this.playback, _events2.default.PB_PLAY, this.playing);
	        this.listenTo(this.playback, _events2.default.PB_PAUSE, this.paused);
	        this.listenTo(this.playback, _events2.default.PB_STOP, this.stopped);
	        this.listenTo(this.playback, _events2.default.PB_ERROR, this.error);
	        this.listenTo(this.playback, _events2.default.PB_CHECK_ONLINE, this.onCheckOnline);
	        this.listenTo(this.playback, _events2.default.PB_LEVELS_AVAILABLE, this.onLevelAvailable);
	    };

	    Container.prototype.playbackStateChanged = function playbackStateChanged(state) {
	        this.trigger(_events2.default.CT_PLAYBACKSTATE, state);
	    };

	    Container.prototype.playbackDvrStateChanged = function playbackDvrStateChanged(dvrInUse) {
	        this.settings = this.playback.settings;
	        this.dvrInUse = dvrInUse;
	        this.trigger(_events2.default.CT_PLAYBACKDVRSTATECHANGED, dvrInUse);
	    };

	    Container.prototype.onBitrate = function onBitrate(data) {
	        this.trigger(_events2.default.CT_LEVEL_SWITCH, data);
	    };

	    Container.prototype.updateBitrate = function updateBitrate(newBitrate) {
	        this.trigger(_events2.default.CT_BITRATE, newBitrate);
	    };

	    Container.prototype.statsReport = function statsReport(metrics) {
	        this.trigger(_events2.default.CT_STATS_REPORT, metrics);
	    };

	    Container.prototype.getPlaybackType = function getPlaybackType() {
	        return this.playback.getPlaybackType();
	    };

	    Container.prototype.isDvrEnabled = function isDvrEnabled() {
	        return !!this.playback.dvrEnabled;
	    };

	    Container.prototype.isDvrInUse = function isDvrInUse() {
	        return !!this.dvrInUse;
	    };

	    Container.prototype.destroy = function destroy() {
	        this.trigger(_events2.default.CT_DESTROYED, this, this.name);
	        this.stopListening();
	        this.plugins.forEach(function (plugin) {
	            return plugin.destroy();
	        });
	        this.$el.remove();
	    };

	    Container.prototype.setStyle = function setStyle(style) {
	        this.$el.css(style);
	    };

	    Container.prototype.animate = function animate(style, duration) {
	        return this.$el.animate(style, duration).promise();
	    };

	    Container.prototype.ready = function ready() {
	        this.isReady = true;
	        this.trigger(_events2.default.CT_READY, this.name);
	    };

	    Container.prototype.isPlaying = function isPlaying() {
	        return this.playback.isPlaying();
	    };

	    Container.prototype.getStartTimeOffset = function getStartTimeOffset() {
	        return this.playback.getStartTimeOffset();
	    };

	    Container.prototype.getCurrentTime = function getCurrentTime() {
	        return this.currentTime;
	    };

	    Container.prototype.getDuration = function getDuration() {
	        return this.playback.getDuration();
	    };

	    Container.prototype.error = function error(errorObj) {
	        if (!this.isReady) {
	            this.ready();
	        }
	        this.trigger(_events2.default.CT_ERROR, { error: errorObj, container: this }, this.name);
	    };

	    Container.prototype.onLevelAvailable = function onLevelAvailable(levels) {
	        this.trigger(_events2.default.CT_LEVEl_AVAILABLE, levels);
	    };

	    Container.prototype.onCheckOnline = function onCheckOnline(e) {
	        this.trigger(_events2.default.CT_CHECK_ONLINE, e);
	    };

	    Container.prototype.onLoadStart = function onLoadStart(e) {
	        this.trigger(_events2.default.CT_LOADSTART, e);
	    };

	    Container.prototype.onCanPlay = function onCanPlay(e) {
	        this.trigger(_events2.default.CT_CANPLAY, e);
	    };

	    Container.prototype.onCanPlayThrough = function onCanPlayThrough(e) {
	        this.trigger(_events2.default.CT_CANPLAYTHROUGH, e);
	    };

	    Container.prototype.onSeeking = function onSeeking(e) {
	        this.currentTime = e.data.target.currentTime;
	        this.trigger(_events2.default.CT_SEEKING, e);
	    };

	    Container.prototype.onWaiting = function onWaiting(e) {
	        this.trigger(_events2.default.CT_WAITING, e);
	    };

	    Container.prototype.loadedMetadata = function loadedMetadata(metadata) {
	        this.trigger(_events2.default.CT_LOADEDMETADATA, metadata);
	    };

	    Container.prototype.timeUpdated = function timeUpdated(timeProgress) {
	        this.currentTime = timeProgress.current;
	        this.trigger(_events2.default.CT_TIMEUPDATE, timeProgress, this.name);
	    };

	    Container.prototype.progress = function progress() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        this.trigger.apply(this, [_events2.default.CT_PROGRESS].concat(args, [this.name]));
	    };

	    Container.prototype.playing = function playing(e) {
	        this.trigger(_events2.default.CT_PLAY, { type: 'main' });
	    };

	    Container.prototype.paused = function paused() {
	        this.trigger(_events2.default.CT_PAUSE, this.name);
	    };

	    Container.prototype.play = function play() {
	        this.playback.play();
	    };

	    Container.prototype.stop = function stop() {
	        this.playback.stop();
	        this.currentTime = 0;
	    };

	    Container.prototype.pause = function pause() {
	        this.playback.pause();
	    };

	    Container.prototype.onEnded = function onEnded() {
	        this.trigger(_events2.default.CT_ENDED, this, this.name);
	        this.currentTime = 0;
	    };

	    Container.prototype.stopped = function stopped() {
	        this.trigger(_events2.default.CT_STOP);
	    };

	    Container.prototype.clicked = function clicked() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.trigger(_events2.default.CT_CLICK, this, this.name);
	        }
	    };

	    Container.prototype.dblClicked = function dblClicked() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.trigger(_events2.default.CT_DBLCLICK, this, this.name);
	        }
	    };

	    Container.prototype.onContextMenu = function onContextMenu() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.trigger(_events2.default.CT_CONTEXTMENU, this, this.name);
	        }
	    };

	    Container.prototype.seek = function seek(time) {
	        this.trigger(_events2.default.CT_SEEK, time, this.name);
	        this.playback.seek(time);
	    };

	    Container.prototype.seekPercentage = function seekPercentage(percentage) {
	        var duration = this.getDuration();
	        if (percentage >= 0 && percentage <= 100) {
	            var time = duration * (percentage / 100);
	            this.seek(time);
	        }
	    };

	    Container.prototype.setVolume = function setVolume(value) {
	        this.volume = parseInt(value, 10);
	        this.trigger(_events2.default.CT_VOLUME, value, this.name);
	        this.playback.volume(value);
	    };

	    Container.prototype.setSpeed = function setSpeed(value) {
	        if (value < 0) {
	            return;
	        }
	        this.trigger(_events2.default.CT_CHANGESPEED, value, this.name);
	        this.playback.el.playbackRate = value;
	    };

	    Container.prototype.fullscreen = function fullscreen() {
	        this.trigger(_events2.default.CT_FULLSCREEN, this.name);
	    };

	    Container.prototype.onBuffering = function onBuffering() {
	        this.trigger(_events2.default.CT_STATE_BUFFERING, this.name);
	    };

	    Container.prototype.bufferfull = function bufferfull() {
	        this.trigger(_events2.default.CT_STATE_BUFFERFULL, this.name);
	    };

	    Container.prototype.addPlugin = function addPlugin(plugin) {
	        this.plugins.push(plugin);
	    };

	    Container.prototype.hasPlugin = function hasPlugin(name) {
	        return !!this.getPlugin(name);
	    };

	    Container.prototype.getPlugin = function getPlugin(name) {
	        return (0, _arrayPrototype2.default)(this.plugins, function (plugin) {
	            return plugin.name === name;
	        });
	    };

	    Container.prototype.mouseEnter = function mouseEnter() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.trigger(_events2.default.CT_MOUSE_ENTER);
	        }
	    };

	    Container.prototype.mouseLeave = function mouseLeave() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.trigger(_events2.default.CT_MOUSE_LEAVE);
	        }
	    };

	    Container.prototype.settingsUpdate = function settingsUpdate() {
	        this.settings = this.playback.settings;
	        this.trigger(_events2.default.CT_SETTINGSUPDATE);
	    };

	    Container.prototype.highDefinitionUpdate = function highDefinitionUpdate(isHD) {
	        this.trigger(_events2.default.CT_HIGHDEFINITIONUPDATE, isHD);
	    };

	    Container.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
	        return this.playback.isHighDefinitionInUse();
	    };

	    Container.prototype.disableMediaControl = function disableMediaControl() {
	        if (!this.mediaControlDisabled) {
	            this.mediaControlDisabled = true;
	            this.trigger(_events2.default.CT_MEDIACONTROL_DISABLE);
	        }
	    };

	    Container.prototype.enableMediaControl = function enableMediaControl() {
	        if (this.mediaControlDisabled) {
	            this.mediaControlDisabled = false;
	            this.trigger(_events2.default.CT_MEDIACONTROL_ENABLE);
	        }
	    };

	    Container.prototype.updateStyle = function updateStyle() {
	        if (!this.options.chromeless || this.options.allowUserInteraction) {
	            this.$el.removeClass('chromeless');
	        } else {
	            this.$el.addClass('chromeless');
	        }
	    };

	    Container.prototype.configure = function configure(options) {
	        this._options = _clapprZepto2.default.extend(this._options, options);
	        this.updateStyle();
	        this.trigger(_events2.default.CT_OPTIONS_CHANGE);
	    };

	    Container.prototype.render = function render() {
	        var s = _styler2.default.getStyleFor(_style2.default, { customCSS: this.options.customCSS });
	        !this.options.hasAnPlayerInstance && this.$el.append(s);
	        if (this.playback.name == 'html5_video' && this.options.mimeType == 'audio/mp3') {
	            if ((0, _clapprZepto2.default)('#zplayerjs').length == 0) {
	                (0, _clapprZepto2.default)((0, _clapprZepto2.default)('#zplayerjs-wrapper')[0].parentElement).append(this.playback.render().el);
	            } else {
	                this.playback.render();
	            }
	        } else {
	            this.$el.append(this.playback.render().el);
	        }

	        this.updateStyle();
	        return this;
	    };

	    return Container;
	}(_ui_object2.default);

	exports.default = Container;
	module.exports = exports['default'];

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".zcontainer[data-container] {\n  position: absolute;\n  background-color: black;\n  height: 100%;\n  width: 100%; }\n  .zcontainer[data-container] .chromeless {\n    cursor: default; }\n\n[data-player]:not(.nocursor) .zcontainer[data-container]:not(.chromeless).pointer-enabled {\n  cursor: auto; }\n", ""]);

	// exports


/***/ },
/* 25 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(27);
	var ES = __webpack_require__(31);

	var implementation = __webpack_require__(49);
	var getPolyfill = __webpack_require__(50);
	var shim = __webpack_require__(51);

	var slice = Array.prototype.slice;

	var boundFindShim = function find(array, predicate) { // eslint-disable-line no-unused-vars
		ES.RequireObjectCoercible(array);
		var args = slice.call(arguments, 1);
		return implementation.apply(array, args);
	};

	define(boundFindShim, {
		getPolyfill: getPolyfill,
		implementation: implementation,
		shim: shim
	});

	module.exports = boundFindShim;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys = __webpack_require__(28);
	var foreach = __webpack_require__(30);
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	var toStr = Object.prototype.toString;

	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};

	var arePropertyDescriptorsSupported = function () {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        /* eslint-disable no-unused-vars, no-restricted-syntax */
	        for (var _ in obj) { return false; }
	        /* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) { /* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

	var defineProperty = function (object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};

	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};

	defineProperties.supportsDescriptors = !!supportsDescriptors;

	module.exports = defineProperties;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(29);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};

	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2));
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	module.exports = keysShim;


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;

	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;

	module.exports = function forEach (obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};



/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
	var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

	var $isNaN = __webpack_require__(32);
	var $isFinite = __webpack_require__(33);
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

	var assign = __webpack_require__(34);
	var sign = __webpack_require__(35);
	var mod = __webpack_require__(36);
	var isPrimitive = __webpack_require__(37);
	var toPrimitive = __webpack_require__(38);
	var parseInteger = parseInt;
	var bind = __webpack_require__(43);
	var strSlice = bind.call(Function.call, String.prototype.slice);
	var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
	var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
	var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
	var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
	var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
	var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
	var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

	// whitespace from: http://es5.github.io/#x15.5.4.20
	// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	var ws = [
		'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
		'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
		'\u2029\uFEFF'
	].join('');
	var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	var replace = bind.call(Function.call, String.prototype.replace);
	var trim = function (value) {
		return replace(value, trimRegex, '');
	};

	var ES5 = __webpack_require__(45);

	var hasRegExpMatcher = __webpack_require__(47);

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
	var ES6 = assign(assign({}, ES5), {

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
		Call: function Call(F, V) {
			var args = arguments.length > 2 ? arguments[2] : [];
			if (!this.IsCallable(F)) {
				throw new TypeError(F + ' is not a function');
			}
			return F.apply(V, args);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
		ToPrimitive: toPrimitive,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
		// ToBoolean: ES5.ToBoolean,

		// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
		ToNumber: function ToNumber(argument) {
			var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
			if (typeof value === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a number');
			}
			if (typeof value === 'string') {
				if (isBinary(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 2));
				} else if (isOctal(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 8));
				} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
					return NaN;
				} else {
					var trimmed = trim(value);
					if (trimmed !== value) {
						return this.ToNumber(trimmed);
					}
				}
			}
			return Number(value);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
		// ToInteger: ES5.ToNumber,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
		// ToInt32: ES5.ToInt32,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
		// ToUint32: ES5.ToUint32,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
		ToInt16: function ToInt16(argument) {
			var int16bit = this.ToUint16(argument);
			return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
		// ToUint16: ES5.ToUint16,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
		ToInt8: function ToInt8(argument) {
			var int8bit = this.ToUint8(argument);
			return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
		ToUint8: function ToUint8(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x100);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
		ToUint8Clamp: function ToUint8Clamp(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number <= 0) { return 0; }
			if (number >= 0xFF) { return 0xFF; }
			var f = Math.floor(argument);
			if (f + 0.5 < number) { return f + 1; }
			if (number < f + 0.5) { return f; }
			if (f % 2 !== 0) { return f + 1; }
			return f;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
		ToString: function ToString(argument) {
			if (typeof argument === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a string');
			}
			return String(argument);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
		ToObject: function ToObject(value) {
			this.RequireObjectCoercible(value);
			return Object(value);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
		ToPropertyKey: function ToPropertyKey(argument) {
			var key = this.ToPrimitive(argument, String);
			return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
		ToLength: function ToLength(argument) {
			var len = this.ToInteger(argument);
			if (len <= 0) { return 0; } // includes converting -0 to +0
			if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
			return len;
		},

		// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
		CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
			if (toStr.call(argument) !== '[object String]') {
				throw new TypeError('must be a string');
			}
			if (argument === '-0') { return -0; }
			var n = this.ToNumber(argument);
			if (this.SameValue(this.ToString(n), argument)) { return n; }
			return void 0;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
		RequireObjectCoercible: ES5.CheckObjectCoercible,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
		IsArray: Array.isArray || function IsArray(argument) {
			return toStr.call(argument) === '[object Array]';
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
		// IsCallable: ES5.IsCallable,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
		IsConstructor: function IsConstructor(argument) {
			return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
		IsExtensible: function IsExtensible(obj) {
			if (!Object.preventExtensions) { return true; }
			if (isPrimitive(obj)) {
				return false;
			}
			return Object.isExtensible(obj);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
		IsInteger: function IsInteger(argument) {
			if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
				return false;
			}
			var abs = Math.abs(argument);
			return Math.floor(abs) === abs;
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
		IsPropertyKey: function IsPropertyKey(argument) {
			return typeof argument === 'string' || typeof argument === 'symbol';
		},

		// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
		IsRegExp: function IsRegExp(argument) {
			if (!argument || typeof argument !== 'object') {
				return false;
			}
			if (hasSymbols) {
				var isRegExp = argument[Symbol.match];
				if (typeof isRegExp !== 'undefined') {
					return ES5.ToBoolean(isRegExp);
				}
			}
			return hasRegExpMatcher(argument);
		},

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
		// SameValue: ES5.SameValue,

		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
		SameValueZero: function SameValueZero(x, y) {
			return (x === y) || ($isNaN(x) && $isNaN(y));
		},

		/**
		 * 7.3.2 GetV (V, P)
		 * 1. Assert: IsPropertyKey(P) is true.
		 * 2. Let O be ToObject(V).
		 * 3. ReturnIfAbrupt(O).
		 * 4. Return O.[[Get]](P, V).
		 */
		GetV: function GetV(V, P) {
			// 7.3.2.1
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}

			// 7.3.2.2-3
			var O = this.ToObject(V);

			// 7.3.2.4
			return O[P];
		},

		/**
		 * 7.3.9 - http://www.ecma-international.org/ecma-262/6.0/#sec-getmethod
		 * 1. Assert: IsPropertyKey(P) is true.
		 * 2. Let func be GetV(O, P).
		 * 3. ReturnIfAbrupt(func).
		 * 4. If func is either undefined or null, return undefined.
		 * 5. If IsCallable(func) is false, throw a TypeError exception.
		 * 6. Return func.
		 */
		GetMethod: function GetMethod(O, P) {
			// 7.3.9.1
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}

			// 7.3.9.2
			var func = this.GetV(O, P);

			// 7.3.9.4
			if (func == null) {
				return undefined;
			}

			// 7.3.9.5
			if (!this.IsCallable(func)) {
				throw new TypeError(P + 'is not a function');
			}

			// 7.3.9.6
			return func;
		},

		/**
		 * 7.3.1 Get (O, P) - http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p
		 * 1. Assert: Type(O) is Object.
		 * 2. Assert: IsPropertyKey(P) is true.
		 * 3. Return O.[[Get]](P, O).
		 */
		Get: function Get(O, P) {
			// 7.3.1.1
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			// 7.3.1.2
			if (!this.IsPropertyKey(P)) {
				throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
			}
			// 7.3.1.3
			return O[P];
		},

		Type: function Type(x) {
			if (typeof x === 'symbol') {
				return 'Symbol';
			}
			return ES5.Type(x);
		},

		// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
		SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			var C = O.constructor;
			if (typeof C === 'undefined') {
				return defaultConstructor;
			}
			if (this.Type(C) !== 'Object') {
				throw new TypeError('O.constructor is not an Object');
			}
			var S = hasSymbols && Symbol.species ? C[Symbol.species] : undefined;
			if (S == null) {
				return defaultConstructor;
			}
			if (this.IsConstructor(S)) {
				return S;
			}
			throw new TypeError('no constructor found');
		}
	});

	delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

	module.exports = ES6;


/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = Number.isNaN || function isNaN(a) {
		return a !== a;
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	var $isNaN = Number.isNaN || function (a) { return a !== a; };

	module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ },
/* 34 */
/***/ function(module, exports) {

	var has = Object.prototype.hasOwnProperty;
	module.exports = Object.assign || function assign(target, source) {
		for (var key in source) {
			if (has.call(source, key)) {
				target[key] = source[key];
			}
		}
		return target;
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = function sign(number) {
		return number >= 0 ? 1 : -1;
	};


/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = function mod(number, modulo) {
		var remain = number % modulo;
		return Math.floor(remain >= 0 ? remain : remain + modulo);
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

	var isPrimitive = __webpack_require__(39);
	var isCallable = __webpack_require__(40);
	var isDate = __webpack_require__(41);
	var isSymbol = __webpack_require__(42);

	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
		if (typeof O === 'undefined' || O === null) {
			throw new TypeError('Cannot call method on ' + O);
		}
		if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
			throw new TypeError('hint must be "string" or "number"');
		}
		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
		var method, result, i;
		for (i = 0; i < methodNames.length; ++i) {
			method = O[methodNames[i]];
			if (isCallable(method)) {
				result = method.call(O);
				if (isPrimitive(result)) {
					return result;
				}
			}
		}
		throw new TypeError('No default value');
	};

	var GetMethod = function GetMethod(O, P) {
		var func = O[P];
		if (func !== null && typeof func !== 'undefined') {
			if (!isCallable(func)) {
				throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
			}
			return func;
		}
	};

	// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		var hint = 'default';
		if (arguments.length > 1) {
			if (PreferredType === String) {
				hint = 'string';
			} else if (PreferredType === Number) {
				hint = 'number';
			}
		}

		var exoticToPrim;
		if (hasSymbols) {
			if (Symbol.toPrimitive) {
				exoticToPrim = GetMethod(input, Symbol.toPrimitive);
			} else if (isSymbol(input)) {
				exoticToPrim = Symbol.prototype.valueOf;
			}
		}
		if (typeof exoticToPrim !== 'undefined') {
			var result = exoticToPrim.call(input, hint);
			if (isPrimitive(result)) {
				return result;
			}
			throw new TypeError('unable to convert exotic object to primitive');
		}
		if (hint === 'default' && (isDate(input) || isSymbol(input))) {
			hint = 'string';
		}
		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';

	var fnToStr = Function.prototype.toString;

	var constructorRegex = /^\s*class /;
	var isES6ClassFn = function isES6ClassFn(value) {
		try {
			var fnStr = fnToStr.call(value);
			var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
			var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
			var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
			return constructorRegex.test(spaceStripped);
		} catch (e) {
			return false; // not a function
		}
	};

	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};

	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) { return false; }
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') { return false; }
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') { return true; }
			if (toStr.call(value) !== '[object Symbol]') { return false; }
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var implementation = __webpack_require__(44);

	module.exports = Function.prototype.bind || implementation;


/***/ },
/* 44 */
/***/ function(module, exports) {

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $isNaN = __webpack_require__(32);
	var $isFinite = __webpack_require__(33);

	var sign = __webpack_require__(35);
	var mod = __webpack_require__(36);

	var IsCallable = __webpack_require__(40);
	var toPrimitive = __webpack_require__(46);

	// https://es5.github.io/#x9
	var ES5 = {
		ToPrimitive: toPrimitive,

		ToBoolean: function ToBoolean(value) {
			return Boolean(value);
		},
		ToNumber: function ToNumber(value) {
			return Number(value);
		},
		ToInteger: function ToInteger(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number)) { return 0; }
			if (number === 0 || !$isFinite(number)) { return number; }
			return sign(number) * Math.floor(Math.abs(number));
		},
		ToInt32: function ToInt32(x) {
			return this.ToNumber(x) >> 0;
		},
		ToUint32: function ToUint32(x) {
			return this.ToNumber(x) >>> 0;
		},
		ToUint16: function ToUint16(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x10000);
		},
		ToString: function ToString(value) {
			return String(value);
		},
		ToObject: function ToObject(value) {
			this.CheckObjectCoercible(value);
			return Object(value);
		},
		CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
			/* jshint eqnull:true */
			if (value == null) {
				throw new TypeError(optMessage || 'Cannot call method on ' + value);
			}
			return value;
		},
		IsCallable: IsCallable,
		SameValue: function SameValue(x, y) {
			if (x === y) { // 0 === -0, but they are not identical.
				if (x === 0) { return 1 / x === 1 / y; }
				return true;
			}
			return $isNaN(x) && $isNaN(y);
		},

		// http://www.ecma-international.org/ecma-262/5.1/#sec-8
		Type: function Type(x) {
			if (x === null) {
				return 'Null';
			}
			if (typeof x === 'undefined') {
				return 'Undefined';
			}
			if (typeof x === 'function' || typeof x === 'object') {
				return 'Object';
			}
			if (typeof x === 'number') {
				return 'Number';
			}
			if (typeof x === 'boolean') {
				return 'Boolean';
			}
			if (typeof x === 'string') {
				return 'String';
			}
		}
	};

	module.exports = ES5;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var toStr = Object.prototype.toString;

	var isPrimitive = __webpack_require__(39);

	var isCallable = __webpack_require__(40);

	// https://es5.github.io/#x8.12
	var ES5internalSlots = {
		'[[DefaultValue]]': function (O, hint) {
			var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

			if (actualHint === String || actualHint === Number) {
				var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
				var value, i;
				for (i = 0; i < methods.length; ++i) {
					if (isCallable(O[methods[i]])) {
						value = O[methods[i]]();
						if (isPrimitive(value)) {
							return value;
						}
					}
				}
				throw new TypeError('No default value');
			}
			throw new TypeError('invalid [[DefaultValue]] hint supplied');
		}
	};

	// https://es5.github.io/#x9
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var has = __webpack_require__(48);
	var regexExec = RegExp.prototype.exec;
	var gOPD = Object.getOwnPropertyDescriptor;

	var tryRegexExecCall = function tryRegexExec(value) {
		try {
			var lastIndex = value.lastIndex;
			value.lastIndex = 0;

			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		} finally {
			value.lastIndex = lastIndex;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}
		if (!hasToStringTag) {
			return toStr.call(value) === regexClass;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		return tryRegexExecCall(value);
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var bind = __webpack_require__(43);

	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ES = __webpack_require__(31);

	module.exports = function find(predicate) {
		var list = ES.ToObject(this);
		var length = ES.ToInteger(ES.ToLength(list.length));
		if (!ES.IsCallable(predicate)) {
			throw new TypeError('Array#find: predicate must be a function');
		}
		if (length === 0) {
			return undefined;
		}
		var thisArg = arguments[1];
		for (var i = 0, value; i < length; i++) {
			value = list[i];
			if (ES.Call(predicate, thisArg, [value, i, list])) {
				return value;
			}
		}
		return undefined;
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function getPolyfill() {
		// Detect if an implementation exists
		// Detect early implementations which skipped holes in sparse arrays
	  // eslint-disable-next-line no-sparse-arrays
		var implemented = Array.prototype.find && [, 1].find(function () {
			return true;
		}) !== 1;

	  // eslint-disable-next-line global-require
		return implemented ? Array.prototype.find : __webpack_require__(49);
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(27);
	var getPolyfill = __webpack_require__(50);

	module.exports = function shimArrayPrototypeFind() {
		var polyfill = getPolyfill();

		define(Array.prototype, { find: polyfill }, {
			find: function () {
				return Array.prototype.find !== polyfill;
			}
		});

		return polyfill;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}

	module.exports = isPlainObject;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.


	var events = new _events2.default();

	var Mediator = function Mediator() {
	    _classCallCheck(this, Mediator);
	};

	exports.default = Mediator;


	Mediator.on = function (name, callback, context) {
	    events.on(name, callback, context);
	    return;
	};

	Mediator.once = function (name, callback, context) {
	    events.once(name, callback, context);
	    return;
	};

	Mediator.off = function (name, callback, context) {
	    events.off(name, callback, context);
	    return;
	};

	Mediator.trigger = function (name) {
	    for (var _len = arguments.length, opts = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        opts[_key - 1] = arguments[_key];
	    }

	    events.trigger.apply(events, [name].concat(opts));
	    return;
	};

	Mediator.stopListening = function (obj, name, callback) {
	    events.stopListening(obj, name, callback);
	    return;
	};
	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var PlayerInfo = function PlayerInfo() {
	  _classCallCheck(this, PlayerInfo);

	  this.options = {};
	  this.playbackPlugins = [];
	  this.currentSize = { width: 0, height: 0 };
	};

	PlayerInfo._players = {};

	PlayerInfo.getInstance = function (playerId) {
	  return PlayerInfo._players[playerId] || (PlayerInfo._players[playerId] = new PlayerInfo());
	};

	exports.default = PlayerInfo;
	module.exports = exports["default"];

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, "@font-face {\n  font-family: \"Roboto\";\n  font-style: normal;\n  font-weight: 400;\n  src: local(\"Roboto\"), local(\"Roboto\"), url(" + __webpack_require__(56) + ") format(\"truetype\"); }\n\n[data-player] {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-transform: translate3d(0, 0, 0);\n  -moz-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  -o-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n  position: relative;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-style: normal;\n  font-weight: normal;\n  text-align: center;\n  font-size: 100%;\n  font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n  text-shadow: 0 0 0;\n  box-sizing: border-box;\n  overflow: visible; }\n  [data-player]:focus {\n    outline: 0; }\n  [data-player] * {\n    max-width: none;\n    box-sizing: inherit;\n    float: none; }\n  [data-player] div {\n    display: block; }\n  [data-player].fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    top: 0;\n    left: 0; }\n  [data-player].nocursor {\n    cursor: none; }\n\n.zplayer-style {\n  display: none !important; }\n\npre {\n  z-index: 9999999;\n  background-color: #f5e79e;\n  outline: 1px solid #ccc;\n  padding: 5px;\n  margin: 5px; }\n\n.string {\n  color: green; }\n\n.number {\n  color: darkorange; }\n\n.boolean {\n  color: blue; }\n\n.null {\n  color: magenta; }\n\n.key {\n  color: red; }\n", ""]);

	// exports


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "38861cba61c66739c1452c3a71e39852.ttf";

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(58);

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _vendor = __webpack_require__(8);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _mediator = __webpack_require__(53);

	var _mediator2 = _interopRequireDefault(_mediator);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _mediaControl = __webpack_require__(61);

	var _mediaControl2 = _interopRequireDefault(_mediaControl);

	var _mediaControl3 = __webpack_require__(64);

	var _mediaControl4 = _interopRequireDefault(_mediaControl3);

	var _play = __webpack_require__(65);

	var _play2 = _interopRequireDefault(_play);

	var _pause = __webpack_require__(66);

	var _pause2 = _interopRequireDefault(_pause);

	var _stop = __webpack_require__(67);

	var _stop2 = _interopRequireDefault(_stop);

	var _volumeLow = __webpack_require__(68);

	var _volumeLow2 = _interopRequireDefault(_volumeLow);

	var _volumeHigh = __webpack_require__(69);

	var _volumeHigh2 = _interopRequireDefault(_volumeHigh);

	var _mute = __webpack_require__(70);

	var _mute2 = _interopRequireDefault(_mute);

	var _fullscreen = __webpack_require__(71);

	var _fullscreen2 = _interopRequireDefault(_fullscreen);

	var _exitFullscreen = __webpack_require__(72);

	var _exitFullscreen2 = _interopRequireDefault(_exitFullscreen);

	var _hd = __webpack_require__(73);

	var _hd2 = _interopRequireDefault(_hd);

	var _setting = __webpack_require__(74);

	var _setting2 = _interopRequireDefault(_setting);

	var _cc = __webpack_require__(75);

	var _cc2 = _interopRequireDefault(_cc);

	var _pre = __webpack_require__(76);

	var _pre2 = _interopRequireDefault(_pre);

	var _next = __webpack_require__(77);

	var _next2 = _interopRequireDefault(_next);

	var _replay = __webpack_require__(78);

	var _replay2 = _interopRequireDefault(_replay);

	var _noRepeat = __webpack_require__(79);

	var _noRepeat2 = _interopRequireDefault(_noRepeat);

	var _repeatAll = __webpack_require__(80);

	var _repeatAll2 = _interopRequireDefault(_repeatAll);

	var _repeatOne = __webpack_require__(81);

	var _repeatOne2 = _interopRequireDefault(_repeatOne);

	var _shuffle = __webpack_require__(82);

	var _shuffle2 = _interopRequireDefault(_shuffle);

	var _expand = __webpack_require__(83);

	var _expand2 = _interopRequireDefault(_expand);

	var _shrink = __webpack_require__(84);

	var _shrink2 = _interopRequireDefault(_shrink);

	var _karaoke = __webpack_require__(85);

	var _karaoke2 = _interopRequireDefault(_karaoke);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Zalo Web Platform @ 2017

	var assign = Object.assign || __webpack_require__(86);
	var SUB_CHANGE_TIMEOUT = 2000;

	var MediaControl = function (_UIObject) {
	  _inherits(MediaControl, _UIObject);

	  _createClass(MediaControl, [{
	    key: 'name',
	    get: function get() {
	      return 'MediaControl';
	    }
	  }, {
	    key: 'subColorText',
	    get: function get() {
	      return 'Màu chữ';
	    }
	  }, {
	    key: 'subSizeText',
	    get: function get() {
	      return 'Cỡ chữ';
	    }
	  }, {
	    key: 'subPosText',
	    get: function get() {
	      return 'Vị trí';
	    }
	  }, {
	    key: 'nonLinearTimeout',
	    get: function get() {
	      return 12000;
	    }
	  }, {
	    key: 'attributes',
	    get: function get() {
	      return {
	        'class': 'media-control',
	        'data-media-control': ''
	      };
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return {
	        'click [data-play]': 'play',
	        'click [data-next]': 'next',
	        'click [data-prev]': 'prev',
	        'click [data-pause]': 'pause',
	        'click [data-playpause]': 'togglePlayPause',
	        'touch [data-playpause]': 'togglePlayPause',
	        'click [data-expandshrink]': 'toggleExpandShrink',
	        'click .zm-jump-lyric': 'toggleKaraoke',
	        'click [data-stop]': 'stop',
	        'click [data-playstop]': 'togglePlayStop',
	        'click [data-setting]': 'toggleSettingOption',
	        'click [data-cc]': 'toggleSubtitleOption',
	        'click [data-fullscreen]': 'toggleFullscreen',
	        'click .bar-container[data-seekbar]': 'seek',
	        'click .bar-container[data-volume]': 'onVolumeClick',
	        'click .drawer-icon[data-volume]': 'toggleMute',
	        'click .zm-quanlity-display': 'toggleLevel',
	        'click .zm-list-quanlity li': 'selectLevel',
	        'click #zm-repeat-album': 'playModeToggle',
	        'click #zm-repeat-song': 'playModeSongToggle',
	        'mouseenter .zm-jump-lyric': 'showKaraokeTooltip',
	        'mouseleave .zm-jump-lyric': 'hideKaraokeTooltip',
	        'mouseenter #zm-repeat-album': 'showRepeatTooltip',
	        'mouseleave #zm-repeat-album': 'hideRepeatTooltip',
	        'mouseenter #zm-repeat-song': 'showSongRepeatTooltip',
	        'mouseleave #zm-repeat-song': 'hideSongRepeatTooltip',
	        'mouseenter .zm-jump-mv': 'showMVTooltip',
	        'mouseleave .zm-jump-mv': 'hideMVTooltip',
	        'mouseenter .drawer-icon[data-volume]': 'showVolumeTooltip',
	        'mouseleave .drawer-icon[data-volume]': 'hideVolumeTooltip',
	        'mouseenter [data-fullscreen]': 'showFullScreenTooltip',
	        'mouseleave [data-fullscreen]': 'hideFullScreenTooltip',
	        'mouseenter [data-expandshrink]': 'showExpandShrinkTooltip',
	        'mouseleave [data-expandshrink]': 'hideExpandShrinkTooltip',
	        'mousedown .bar-container[data-volume]': 'startVolumeDrag',
	        'mousemove .bar-container[data-volume]': 'mousemoveOnVolumeBar',
	        'mousedown .bar-scrubber[data-seekbar]': 'startSeekDrag',
	        'touchstart .bar-scrubber[data-seekbar]': 'startSeekDrag',
	        'mousemove .bar-container[data-seekbar]': 'mousemoveOnSeekBar',
	        'touchmove .bar-container[data-seekbar]': 'mousemoveOnSeekBar',
	        'mouseleave .bar-container[data-seekbar]': 'mouseleaveOnSeekBar',
	        'touchleave .bar-container[data-seekbar]': 'mouseleaveOnSeekBar',
	        'mouseenter .media-control-layer[data-controls]': 'setUserKeepVisible',
	        'mouseleave .media-control-layer[data-controls]': 'resetUserKeepVisible',
	        'touchmove .media-control-layer[data-controls]': 'resetUserKeepVisible',

	        // Ad events
	        'click #non-linear-ad-image': 'openNonLinearAd',
	        'click #close-non-linear-ad': 'closeNonLinearAd',
	        'click #pause-ad-image': 'openPauseAd',
	        'click #close-pause-ad': 'closePauseAd',
	        'click .ad-detail-text': 'openPauseAd',

	        // Setting events
	        'click #li-config-ad': 'openAdModeSetting',
	        'click #li-config-speed': 'openSpeedSetting',
	        'click #li-config-quality': 'openQualitySetting',
	        'click .zm-ad-mode-setting li .right-cap-content': 'selectAdMode',
	        'click .zm-play-speed-setting li .right-cap-content': 'selectSpeed',
	        'click .zm-quality-setting li .right-cap-content': 'selectQuality',

	        // Subtitle events
	        'click #li-config-sub-color': 'openSubColorSetting',
	        'click #li-config-sub-size': 'openSubSizeSetting',
	        'click #li-config-sub-pos': 'openSubPosSetting',
	        'click #li-config-sub #sub-switcher': 'toggleSub',
	        'click #li-config-bg #sub-bg-switcher': 'toggleSubBackground',
	        'click .zm-subcolor-setting li .right-cap-content': 'selectSubColor',
	        'click .zm-subsize-setting li .right-cap-content': 'selectSubSize',
	        'click .zm-subpos-setting li .right-cap-content ': 'selectSubPos'
	      };
	    }
	  }, {
	    key: 'template',
	    get: function get() {
	      return (0, _template2.default)(_mediaControl4.default);
	    }
	  }, {
	    key: 'stylesheet',
	    get: function get() {
	      return _styler2.default.getStyleFor(_mediaControl2.default, { baseUrl: this.options.baseUrl, customCSS: this.options.customCSS });
	    }
	  }, {
	    key: 'volume',
	    get: function get() {
	      return this.container && this.container.isReady ? this.container.volume : this.intendedVolume;
	    }
	  }, {
	    key: 'muted',
	    get: function get() {
	      return this.volume === 0;
	    }
	  }]);

	  function MediaControl(options) {
	    _classCallCheck(this, MediaControl);

	    var _this = _possibleConstructorReturn(this, _UIObject.call(this, options));

	    _this.isEnded = false;
	    _this.playMode = 0;
	    _this.playModeSong = 0;
	    _this.loadPlayModeSetting();
	    _this.speed = 1;
	    _this.karaoke = true;
	    _this.isExpanded = false;
	    _this.persistConfig = _this.options.persistConfig;
	    _this.container = options.container;
	    _this.currentPositionValue = null;
	    _this.currentDurationValue = null;
	    var initialVolume = _this.persistConfig ? _utils.Config.restore('volume') : 100;
	    _this.setVolume(_this.options.mute ? 0 : initialVolume);
	    _this.keepVisible = false;
	    _this.fullScreenOnVideoTagSupported = null; // unknown
	    _this.loadAdModeSetting();

	    _this.levels = _this.options.playlist[0].sourceLevel || [];
	    _this.adMarks = [];
	    _this.adMarksFlag = [];
	    _this.adModes = ['Tắt', 'Gián đoạn video', 'Không gián đoạn video'];
	    _this.adTooltips = ['', 'Tùy chọn này giúp giảm số lượng quảng cáo ban đầu, tuy nhiên trong lúc xem sẽ bị gián đoạn bởi các quảng cáo khác.', 'Tuỳ chọn này giúp trải nghiệm trong lúc xem của bạn tốt hơn, tuy nhiên số lượng quảng cáo phải xem trước video có thể sẽ gây phiền.'];
	    _this.playSpeeds = ['0.25x', '0.5x', 'Bình thường', '1.25x', '1.5x', '2x', '3x'];
	    _this.currentSpeed = 'Bình thường';
	    _this.subColors = ['Trắng', 'Vàng', 'Xanh'];
	    _this.subSizes = ['1x', '2x', '3x'];
	    _this.subPosistions = ['5%', '10%', '15%'];

	    if (_this.options.subtitleUrl) {
	      _this.loadSubSetting();
	    }

	    _this.addEventListeners();
	    _this.settings = {
	      left: ['prev', 'playpause', 'next', 'volume', 'position', 'duration'],
	      right: ['fullscreen'],
	      default: ['seekbar']
	    };
	    if (_this.container) {
	      if (!_clapprZepto2.default.isEmptyObject(_this.container.settings)) {
	        _this.settings = _clapprZepto2.default.extend({}, _this.container.settings);
	      }
	    } else {
	      _this.settings = {};
	    }

	    _this.disabled = false;
	    if (_this.container && _this.container.mediaControlDisabled || _this.options.chromeless) {
	      _this.disable();
	    }
	    _this.stopDragHandler = function (event) {
	      return _this.stopDrag(event);
	    };
	    _this.updateDragHandler = function (event) {
	      return _this.updateDrag(event);
	    };
	    (0, _clapprZepto2.default)(document).bind('mouseup', _this.stopDragHandler);
	    (0, _clapprZepto2.default)(document).bind('touchend', _this.stopDragHandler);
	    (0, _clapprZepto2.default)(document).bind('mousemove', _this.updateDragHandler);
	    (0, _clapprZepto2.default)(document).bind('touchmove', _this.updateDragHandler);

	    if (!_browser2.default.isMobile) {
	      _this.$el.css('z-index', '10012 !important');
	    }
	    return _this;
	  }

	  MediaControl.prototype.loadAdModeSetting = function loadAdModeSetting() {
	    if (window.localStorage != null) {
	      var currentAdMode = window.localStorage.getItem("currentAdMode");
	      this.currentAdModeIndex = currentAdMode ? currentAdMode : 2; // default: not interrupt video
	    } else {
	      this.currentAdModeIndex = 2;
	    }
	  };

	  MediaControl.prototype.loadPlayModeSetting = function loadPlayModeSetting() {
	    if (window.localStorage != null) {
	      var playMode = window.localStorage.getItem("playmode"),
	          playModeSong = window.localStorage.getItem("playmodesong");

	      this.playMode = playMode ? playMode : 0;
	      this.playModeSong = playModeSong ? playModeSong : 0;
	    } else {
	      this.playMode = 0;
	      this.playModeSong = 0;
	    }
	  };

	  MediaControl.prototype.loadSubSetting = function loadSubSetting() {
	    if (window.localStorage) {
	      var isSubOn = window.localStorage.getItem("isSubOn"),
	          isSubBackgroundOn = window.localStorage.getItem("isSubBackgroundOn"),
	          subColor = window.localStorage.getItem("subColor"),
	          subSize = window.localStorage.getItem("subSize"),
	          subPos = window.localStorage.getItem("subPos");

	      this.isSubOn = isSubOn !== 'false';
	      this.isSubBackgroundOn = isSubBackgroundOn !== 'false';

	      this.currentSubColor = subColor ? subColor : 'Trắng';
	      this.currentSubSize = subSize ? subSize : '1x';
	      this.currentSubPos = subPos ? subPos : '5%';
	    } else {
	      this.isSubOn = true;
	      this.isSubBackgroundOn = true;
	      this.currentSubColor = 'Trắng';
	      this.currentSubSize = '1x';
	      this.currentSubPos = '5%';
	    }
	  };

	  MediaControl.prototype.addEventListeners = function addEventListeners() {
	    if (this.container) {
	      _mediator2.default.on(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, this.playerResize, this);
	      this.listenTo(this.container, _events2.default.CT_PLAY, this.changeTogglePlay);
	      this.listenTo(this.container, _events2.default.CT_PAUSE, this.onPause);
	      this.listenTo(this.container, _events2.default.CT_STOP, this.changeTogglePlay);
	      this.listenTo(this.container, _events2.default.CT_CLICK, this.onScreenClick);
	      this.listenTo(this.container, _events2.default.CT_DBLCLICK, this.onDblClick);
	      this.listenTo(this.container, _events2.default.CT_TIMEUPDATE, this.onTimeUpdate);
	      this.listenTo(this.container, _events2.default.CT_PROGRESS, this.updateProgressBar);
	      this.listenTo(this.container, _events2.default.CT_SETTINGSUPDATE, this.updateSettting);
	      this.listenTo(this.container, _events2.default.CT_PLAYBACKDVRSTATECHANGED, this.updateSettting);
	      this.listenTo(this.container, _events2.default.CT_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate);
	      this.listenTo(this.container, _events2.default.CT_MEDIACONTROL_DISABLE, this.disable);
	      this.listenTo(this.container, _events2.default.CT_MEDIACONTROL_ENABLE, this.enable);
	      this.listenTo(this.container, _events2.default.CT_OPTIONS_CHANGE, this.optionsUpdate);
	      this.listenTo(this.container, _events2.default.CT_ENDED, this.ended);
	      this.listenTo(this.container, _events2.default.CT_VOLUME, this.onVolumeChanged);

	      // wait until the metadata has loaded and then check if fullscreen on video tag is supported
	      if (this.container.playback.el.nodeName.toLowerCase() === 'video') {
	        this.listenToOnce(this.container, _events2.default.CT_LOADEDMETADATA, this.onLoadedMetadataOnVideoTag);
	      }

	      this.listenToOnce(this.container, _events2.default.CT_LOADED_ADS, this.onLoadedAds);
	      this.listenToOnce(this.container, _events2.default.CT_LOADED_PAUSE_AD, this.onLoadedPauseAd);
	      this.listenToOnce(this.container, _events2.default.CT_FINISH_PREROLL_AD, this.onFinishPrerollAds);

	      this.listenTo(this.container, _events2.default.CT_START_NON_LINEAR_AD, this.onStartNonLinearAd);
	      this.listenTo(this.container, _events2.default.CT_START_LINEAR_AD, this.onStartLinearAd);
	      this.listenTo(this.container, _events2.default.CT_FINISH_LINEAR_AD, this.onFinishLinearAd);
	      this.listenTo(this.container, _events2.default.CT_START_AUDIO_AD, this.onStartAudioAd);
	      this.listenTo(this.container, _events2.default.CT_FINISH_AUDIO_AD, this.onFinishAudioAd);
	      this.listenTo(this.container, _events2.default.SUB_READY, this.setSubSetting());
	      this.listenTo(this.container, _events2.default.CT_LEVEl_AVAILABLE, this.onLevelAvailable);
	      this.listenTo(this.container, _events2.default.CT_BITRATE, this.onNewBitRate);

	      this.listenToOutsideClickEvent();
	    }
	  };

	  MediaControl.prototype.onNewBitRate = function onNewBitRate(data) {
	    var level = 0;
	    if (window.localStorage) {
	      level = parseInt(window.localStorage.getItem("currentLevel"));
	    }

	    if (this.currentLevel == 0 || level == 0) {
	      var autoLevel = this.levels[data.level + 1];
	      this.levels[0].label = 'T\u1EF1 \u0111\u1ED9ng (' + autoLevel.label + ')';
	      this.render();
	    }
	  };

	  MediaControl.prototype.onLevelAvailable = function onLevelAvailable(levels) {
	    if (!this.hasLevelInfo && levels && levels.length > 0) {
	      this.levels = levels;
	      this.levels.unshift({ label: 'Tự động' });
	      this.hasLevelInfo = true;
	    }
	  };

	  MediaControl.prototype.listenToOutsideClickEvent = function listenToOutsideClickEvent() {
	    var _this2 = this;

	    (0, _clapprZepto2.default)(document).click(function () {
	      if (_this2.options.subtitleUrl) {
	        _this2.hideSubtitleSettingOption();
	        _this2.hideDetailSubtitleOption();
	      }
	      _this2.hideSettingOptions();
	      _this2.hideDetailSettingOption();
	    });
	  };

	  MediaControl.prototype.getPlugin = function getPlugin(name) {
	    var plugins = this.container.plugins;
	    return find(plugins, function (plugin) {
	      return plugin.name === name;
	    });
	  };

	  MediaControl.prototype.showVolumeTooltip = function showVolumeTooltip() {
	    var volumeTooltip = this.$volumeIcon.find(".zm-hv-tooltip");
	    if (_browser2.default.isMobile) {
	      volumeTooltip.hide();
	    } else {
	      volumeTooltip.show();
	      volumeTooltip.html(this.muted ? 'Mở âm thanh' : 'Tắt âm thanh');
	    }
	  };

	  MediaControl.prototype.hideVolumeTooltip = function hideVolumeTooltip() {
	    this.$volumeIcon.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showFullScreenTooltip = function showFullScreenTooltip() {
	    var fullScreenTooltip = this.$fullscreenToggle.find(".zm-hv-tooltip");
	    if (_browser2.default.isMobile) {
	      fullScreenTooltip.hide();
	    } else {
	      fullScreenTooltip.show();
	      fullScreenTooltip.html(_utils.Fullscreen.isFullscreen() ? 'Thu nhỏ màn hình' : 'Toàn màn hình');
	    }
	  };

	  MediaControl.prototype.hideFullScreenTooltip = function hideFullScreenTooltip() {
	    this.$fullscreenToggle.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showExpandShrinkTooltip = function showExpandShrinkTooltip() {
	    var expandShrinkTooltip = this.$expandshrinkToggle.find(".zm-hv-tooltip");
	    if (_browser2.default.isMobile) {
	      expandShrinkTooltip.hide();
	    } else {
	      expandShrinkTooltip.show();
	      expandShrinkTooltip.html(this.isExpanded ? 'Thu nhỏ' : 'Mở rộng');
	    }
	  };

	  MediaControl.prototype.hideExpandShrinkTooltip = function hideExpandShrinkTooltip() {
	    this.$expandshrinkToggle.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showMVTooltip = function showMVTooltip() {
	    this.$mvButton.find(".zm-hv-tooltip").show();
	  };

	  MediaControl.prototype.hideMVTooltip = function hideMVTooltip() {
	    this.$mvButton.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showKaraokeTooltip = function showKaraokeTooltip() {
	    this.$karaokeButton.find(".zm-hv-tooltip").show();
	    this.$karaokeButton.find(".zm-hv-tooltip").html(this.karaoke ? 'Tắt Karaoke' : 'Bật Karaoke');
	  };

	  MediaControl.prototype.hideKaraokeTooltip = function hideKaraokeTooltip() {
	    this.$karaokeButton.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showSongRepeatTooltip = function showSongRepeatTooltip() {
	    this.$playmodeSongButton.find(".zm-hv-tooltip").show();
	    if (this.playModeSong == 0) {
	      this.$playmodeSongButton.find(".zm-hv-tooltip").html('Lặp lại');
	    } else if (this.playModeSong == 1) {
	      this.$playmodeSongButton.find(".zm-hv-tooltip").html('Không lặp');
	    }
	  };

	  MediaControl.prototype.hideSongRepeatTooltip = function hideSongRepeatTooltip() {
	    this.$playmodeSongButton.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.showRepeatTooltip = function showRepeatTooltip() {
	    this.$playmodeButton.find(".zm-hv-tooltip").show();
	    if (this.playMode == 0) {
	      this.$playmodeButton.find(".zm-hv-tooltip").html('Lặp tất cả');
	    } else if (this.playMode == 1) {
	      this.$playmodeButton.find(".zm-hv-tooltip").html('Play ngẫu nhiên');
	    } else if (this.playMode == 2) {
	      this.$playmodeButton.find(".zm-hv-tooltip").html('Không lặp');
	    } else if (this.playMode == 3) {
	      this.$playmodeButton.find(".zm-hv-tooltip").html('Lặp 1 bài');
	    }
	  };

	  MediaControl.prototype.hideRepeatTooltip = function hideRepeatTooltip() {
	    this.$playmodeButton.find(".zm-hv-tooltip").hide();
	  };

	  MediaControl.prototype.setSongMode = function setSongMode(index) {
	    this.playModeSong = index;
	    if (this.playModeSong >= 2) {
	      this.playModeSong = 0;
	    }
	    this.setPlayModeSongIcon();

	    this.$playmodeSongButton.removeClass('all');
	    this.$playmodeSongButton.removeClass('shuffle');
	    this.$playmodeSongButton.removeClass('not');
	    this.$playmodeSongButton.removeClass('one');

	    if (this.playModeSong == 0) {
	      this.$nextButton.hide();
	      this.$playmodeSongButton.addClass('all');
	    } else if (this.playModeSong == 1) {
	      this.$nextButton.show();
	      this.$playmodeSongButton.addClass('not');
	    }

	    if (window.localStorage) {
	      window.localStorage.setItem("playmodesong", this.playModeSong);
	    }

	    this.container.trigger(_events2.default.CT_UPDATE_SONG_MODE, { playModeSong: this.playModeSong });
	  };

	  MediaControl.prototype.playModeSongToggle = function playModeSongToggle() {
	    this.playModeSong++;
	    if (this.playModeSong >= 2) {
	      this.playModeSong = 0;
	    }

	    this.setPlayModeSongIcon();

	    if (this.playModeSong == 1) {
	      // this.$nextButton.html('<span class="zm-icon zm-icon-prev fn-next"></span>');
	      this.$nextButton.show();
	    } else {
	      this.$nextButton.hide();
	    }

	    window.localStorage && window.localStorage.setItem("playmodesong", this.playModeSong);
	    this.container.trigger(_events2.default.CT_UPDATE_SONG_MODE, { playModeSong: this.playModeSong });
	    this.showSongRepeatTooltip();
	  };

	  MediaControl.prototype.setPlayModeSongIcon = function setPlayModeSongIcon() {
	    var currentIcons = this.$playmodeSongButton.find('svg');
	    currentIcons.remove();
	    if (this.playModeSong == 0) {
	      this.$playmodeSongButton.append(_repeatAll2.default);
	    } else if (this.playModeSong == 1) {
	      this.$playmodeSongButton.append(_noRepeat2.default);
	    }
	  };

	  MediaControl.prototype.playModeToggle = function playModeToggle() {
	    this.playMode++;
	    if (this.playMode >= 4) {
	      this.playMode = 0;
	    }

	    this.setPlayModeIcon();
	    window.localStorage && window.localStorage.setItem("playmode", this.playMode);
	    this.container.trigger(_events2.default.CT_UPDATE_SONG_MODE, this.playMode);
	    this.showRepeatTooltip();
	  };

	  MediaControl.prototype.toggleKaraoke = function toggleKaraoke() {
	    var karaokeIcon = this.$karaokeButton;
	    if (this.karaoke) {
	      this.karaoke = false;
	      karaokeIcon.find('svg path').css('fill', 'white');
	    } else {
	      this.karaoke = true;
	      karaokeIcon.find('svg path').css('fill', '#721799');
	    }
	    this.container.trigger(_events2.default.CT_KARAOKE, this.karaoke);
	    this.showKaraokeTooltip();
	  };

	  MediaControl.prototype.next = function next() {
	    this.container.trigger(_events2.default.CT_NEXT);
	  };

	  MediaControl.prototype.prev = function prev() {
	    this.container.trigger(_events2.default.CT_PREV);
	  };

	  MediaControl.prototype.playNext = function playNext(item) {
	    this.container.trigger(_events2.default.CT_SHOWNEXT, item);
	  };

	  MediaControl.prototype.disable = function disable() {
	    if (this.isPaused && this.isFinishPreroll && !this.isPlayingLinear) {
	      return;
	    }
	    if (!this.options.alwaysShowControl) {
	      this.disabled = true;
	      this.hide();
	      this.$el.hide();
	    }
	  };

	  MediaControl.prototype.enable = function enable() {
	    if (this.options.chromeless) return;
	    this.disabled = false;
	    this.show();
	  };

	  MediaControl.prototype.play = function play() {
	    this.container.play();
	  };

	  MediaControl.prototype.pause = function pause() {
	    this.container.pause();
	  };

	  MediaControl.prototype.stop = function stop() {
	    this.container.stop();
	  };

	  MediaControl.prototype.onVolumeChanged = function onVolumeChanged() {
	    this.updateVolumeUI();
	  };

	  MediaControl.prototype.onLoadedMetadataOnVideoTag = function onLoadedMetadataOnVideoTag(metadata) {
	    this.videoDuration = metadata.duration;
	    this.renderAdMark(this.adMarks);

	    var video = this.container.playback.el;
	    if (!_utils.Fullscreen.fullscreenEnabled() && video.webkitSupportsFullscreen) {
	      this.fullScreenOnVideoTagSupported = true;
	      this.updateSettting();
	    }
	  };

	  MediaControl.prototype.onLoadedPauseAd = function onLoadedPauseAd(data) {
	    this.pauseAdData = data.vast.ads[0].creatives[0];
	    this.pauseAdImpressions = data.vast.ads[0].impressions;
	    this.pauseAdEvents = this.getNonLinearAdEvents(this.pauseAdData);
	  };

	  MediaControl.prototype.onStartNonLinearAd = function onStartNonLinearAd(data) {
	    var _this3 = this;

	    var adData = data.vast.ads[0].creatives[0];
	    var impressions = data.vast.ads[0].impressions;
	    this.nonLinearAdEvents = this.getNonLinearAdEvents(adData);

	    if (this.isValidImageAd(adData.ads[0].resources)) {
	      this.$nonLinearAdImage.attr("src", adData.ads[0].resources);
	      var nonLinearAdWidth = adData.ads[0].width;
	      var nonLinearAdHeight = adData.ads[0].height;

	      this.$nonLinearAdImage.attr("width", nonLinearAdWidth);
	      this.$nonLinearAdImage.attr("height", nonLinearAdHeight);
	      if (nonLinearAdWidth > this.container.playback.el.clientWidth) {
	        this.$nonLinearAdImage.css('max-width', this.container.playback.el.clientWidth - 40);
	        this.$nonLinearAdImage.attr("width", 'auto');
	        this.$nonLinearAdImage.attr("height", 'auto');
	      }
	      this.$adContainer.removeClass('none');

	      // Tracking impressions
	      if (impressions.length > 0) {
	        for (var i = 0; i < impressions.length; i++) {
	          _clapprZepto2.default.get(impressions[i].uri);
	        }
	      }

	      if (this.nonLinearAdEvents.start) {
	        _clapprZepto2.default.get(this.nonLinearAdEvents.start);
	      }

	      this.stopTimer = setTimeout(function () {
	        _this3.closeNonLinearAd();
	        clearTimeout(_this3.stopTimer);
	      }, this.nonLinearTimeout);
	    }
	  };

	  MediaControl.prototype.isValidImageAd = function isValidImageAd(src) {
	    var SWFtype = "swf";
	    return src.indexOf(SWFtype) === -1;
	  };

	  MediaControl.prototype.onFinishPrerollAds = function onFinishPrerollAds() {
	    this.isFinishPreroll = true;
	    if (!this.options.disableKeyboardShortcuts) {
	      this.bindKeyEvents();
	    }
	  };

	  MediaControl.prototype.onStartLinearAd = function onStartLinearAd() {
	    this.isPlayingLinear = true;
	  };

	  MediaControl.prototype.onStartAudioAd = function onStartAudioAd() {
	    this.isPlayingAudioAd = true;
	  };

	  MediaControl.prototype.onFinishAudioAd = function onFinishAudioAd() {
	    this.isPlayingAudioAd = false;
	  };

	  MediaControl.prototype.onFinishLinearAd = function onFinishLinearAd() {
	    this.isPlayingLinear = false;
	  };

	  MediaControl.prototype.getNonLinearAdEvents = function getNonLinearAdEvents(adData) {
	    var adUrl = {};
	    adUrl.clickThrough = adData.ads[0].clickThrough;
	    adData.trackingEvents.forEach(function (event) {
	      if (event.event === 'start') {
	        adUrl.start = event.uri;
	      } else if (event.event === 'close') {
	        adUrl.close = event.uri;
	      }
	    });
	    return adUrl;
	  };

	  MediaControl.prototype.openNonLinearAd = function openNonLinearAd() {
	    if (this.nonLinearAdEvents.clickThrough) {
	      window.open(this.nonLinearAdEvents.clickThrough, '_blank');
	    }
	  };

	  MediaControl.prototype.closeNonLinearAd = function closeNonLinearAd() {
	    if (!this.$adContainer.hasClass('none')) {
	      this.$adContainer.addClass('none');
	      if (this.nonLinearAdEvents.close) {
	        _clapprZepto2.default.get(this.nonLinearAdEvents.close);
	      }
	    }
	  };

	  MediaControl.prototype.openPauseAd = function openPauseAd() {
	    if (this.pauseAdEvents.clickThrough) {
	      window.open(this.pauseAdEvents.clickThrough, '_blank');
	      this.closePauseAd();
	    }
	  };

	  MediaControl.prototype.closePauseAd = function closePauseAd() {
	    if (!this.$pauseAdContainer.hasClass('none')) {
	      this.$pauseAdContainer.addClass('none');
	      if (this.pauseAdEvents.close) {
	        _clapprZepto2.default.get(this.pauseAdEvents.close);
	      }
	    }
	  };

	  MediaControl.prototype.onLoadedAds = function onLoadedAds(e) {
	    var _this4 = this;

	    this.adMarks = this.getAdMarks(e.data);
	    this.adMarks.forEach(function () {
	      _this4.adMarksFlag.push(false);
	    });
	  };

	  MediaControl.prototype.renderAdMark = function renderAdMark(adMarks) {
	    var _this5 = this;

	    if (!adMarks.length) {
	      return;
	    }

	    adMarks.forEach(function (adMark) {
	      var adMarkEl = (0, _clapprZepto2.default)("<div data-seekbar></div>").text(''),
	          position = adMark / _this5.videoDuration * 100;

	      if (position < 100) {
	        adMarkEl.addClass('bar-ad-mark');
	        adMarkEl.css({ left: position + '%' });
	        _this5.$adMarksContainer.append(adMarkEl);
	      }
	    });
	  };

	  MediaControl.prototype.getAdMarks = function getAdMarks(schedule) {
	    if (!schedule.length) {
	      return [];
	    }

	    var adMarks = [];
	    schedule.forEach(function (adData) {
	      var startTime = adData.startTime;
	      if (startTime) {
	        adMarks.push((0, _utils.convertToSecond)(startTime));
	      }
	    });

	    return adMarks;
	  };

	  MediaControl.prototype.updateVolumeUI = function updateVolumeUI() {
	    if (this.options.hideVolumeIcon) {
	      return;
	    }
	    if (!this.rendered) {
	      // this will be called after a render
	      return;
	    }
	    // update volume bar scrubber/fill on bar mode
	    this.$volumeBarContainer.find('.bar-fill-2').css({});
	    var containerWidth = this.$volumeBarContainer.width();
	    var barWidth = this.$volumeBarBackground.width();
	    var offset = (containerWidth - barWidth) / 2.0;
	    var pos = barWidth * this.volume / 100.0 + offset;
	    this.$volumeBarFill.css({ width: this.volume + '%' });
	    this.$volumeBarScrubber.css({ left: pos });

	    // update volume bar segments on segmented bar mode
	    this.$volumeBarContainer.find('.segmented-bar-element').removeClass('fill');
	    var item = Math.ceil(this.volume / 10.0);
	    this.$volumeBarContainer.find('.segmented-bar-element').slice(0, item).addClass('fill');
	    var currentVolumeIcon = this.$volumeIcon.find('svg');
	    currentVolumeIcon.remove();
	    // this.$volumeIcon.html('')
	    this.$volumeIcon.removeClass('muted');
	    if (!this.muted) {
	      this.setVolumeIcon();
	    } else {
	      this.$volumeIcon.append(_mute2.default);
	      this.$volumeIcon.addClass('muted');
	    }
	    this.applyButtonStyle(this.$volumeIcon);
	  };

	  MediaControl.prototype.setVolumeIcon = function setVolumeIcon() {
	    var volumeIcon = this.volume > 50 ? _volumeHigh2.default : _volumeLow2.default;
	    this.$volumeIcon.append(volumeIcon);
	  };

	  MediaControl.prototype.showPauseAd = function showPauseAd() {
	    if (this.isValidPauseAd()) {
	      this.$pauseAdImage.attr("src", this.pauseAdData.ads[0].resources);
	      this.$pauseAdImage.attr("width", this.pauseAdData.ads[0].width);
	      this.$pauseAdImage.attr("height", this.pauseAdData.ads[0].height);

	      this.$pauseAdContainer.css('margin-top', -parseInt(this.pauseAdData.ads[0].height) / 2);
	      this.$pauseAdContainer.css('margin-left', -parseInt(this.pauseAdData.ads[0].width) / 2);
	      this.$pauseAdContainer.css('margin-right', 0);
	      this.$pauseAdContainer.css('margin-bottom', 0);

	      if (this.pauseAdData.ads[0].width > this.container.playback.el.clientWidth) {
	        this.$nonLinearAdImage.css('max-width', this.container.playback.el.clientWidth - 40);
	        this.$nonLinearAdImage.css('max-height', this.container.playback.el.clientHeight - 40);
	        this.$nonLinearAdImage.attr("width", 'auto');
	        this.$nonLinearAdImage.attr("height", 'auto');
	      }

	      this.$pauseAdContainer.removeClass('none');
	      this.trackingPauseAd();
	    }
	  };

	  MediaControl.prototype.trackingPauseAd = function trackingPauseAd() {
	    if (this.pauseAdImpressions.length > 0) {
	      for (var i = 0; i < this.pauseAdImpressions.length; i++) {
	        _clapprZepto2.default.get(this.pauseAdImpressions[i].uri);
	      }
	    }
	    if (this.pauseAdEvents.start) {
	      _clapprZepto2.default.get(this.pauseAdEvents.start);
	    }
	  };

	  MediaControl.prototype.isValidPauseAd = function isValidPauseAd() {
	    if (this.pauseAdData && this.isFinishPreroll) {
	      var pauseAdUri = this.pauseAdData.ads[0].resources;
	      var SWFtype = "swf";
	      return pauseAdUri.indexOf(SWFtype) === -1;
	    }
	    return false;
	  };

	  MediaControl.prototype.onPause = function onPause() {
	    if (!this.isSelectingQuality && !this.isPlayingLinear) {
	      this.showPauseAd();
	    }
	    this.changeTogglePlay();
	  };

	  MediaControl.prototype.changeTogglePlay = function changeTogglePlay() {
	    this.$playPauseToggle.html('');
	    this.$playStopToggle.html('');
	    if (this.container && this.container.isPlaying()) {
	      this.$suggestions.addClass('none');
	      this.$playPauseToggle.removeClass('zp-button-replay');
	      this.isEnded = false;
	      this.isPaused = false;
	      this.$pauseAdContainer.addClass('none');
	      this.$playPauseToggle.append(_pause2.default);
	      this.$playStopToggle.append(_stop2.default);
	      this.trigger(_events2.default.MC_PLAYING);
	    } else {
	      if (this.isEnded && this.settings.left.includes('replay')) {
	        this.$playPauseToggle.addClass('zp-button-replay');
	        this.$playPauseToggle.append(_replay2.default);
	        this.$playStopToggle.append(_replay2.default);
	      } else {
	        this.$playPauseToggle.removeClass('zp-button-replay');
	        this.$playPauseToggle.append(_play2.default);
	        this.$playStopToggle.append(_play2.default);
	      }
	      this.isPaused = true;

	      this.trigger(_events2.default.MC_NOTPLAYING);
	    }
	    this.applyButtonStyle(this.$playPauseToggle);
	    this.applyButtonStyle(this.$playStopToggle);
	    this.show();
	  };

	  MediaControl.prototype.mousemoveOnSeekBar = function mousemoveOnSeekBar(event) {
	    if (this.isPlayingLinear || this.isPlayingAudioAd || _browser2.default.isMobile) return;

	    if (this.container.settings.seekEnabled) {
	      var offsetX = event.pageX - this.$seekBarContainer.offset().left - this.$seekBarHover.width() / 2;
	      this.$seekBarHover.css({ left: offsetX });
	    }
	    this.trigger(_events2.default.MC_MOUSEMOVE_SEEKBAR, event);
	  };

	  MediaControl.prototype.mouseleaveOnSeekBar = function mouseleaveOnSeekBar(event) {
	    this.trigger(_events2.default.MC_MOUSELEAVE_SEEKBAR, event);
	  };

	  MediaControl.prototype.onVolumeClick = function onVolumeClick(event) {
	    var newVolume = this.getVolumeFromUIEvent(event);
	    this.setVolume(newVolume);
	  };

	  MediaControl.prototype.mousemoveOnVolumeBar = function mousemoveOnVolumeBar(event) {
	    if (this.draggingVolumeBar) {
	      var newVolume = this.getVolumeFromUIEvent(event);
	      this.setVolume(newVolume);
	    }
	  };

	  MediaControl.prototype.playerResize = function playerResize(size) {
	    var currentFullScreenIcon = this.$fullscreenToggle.find('svg');
	    currentFullScreenIcon.remove();
	    if (_utils.Fullscreen.isFullscreen()) {
	      this.$expandshrinkToggle.hide();
	      this.$fullscreenToggle.append(_exitFullscreen2.default);
	    } else {
	      this.$expandshrinkToggle.show();
	      this.$fullscreenToggle.append(_fullscreen2.default);
	    }
	    this.hideFullScreenTooltip();
	    this.applyButtonStyle(this.$fullscreenToggle);
	    this.$el.removeClass('w320');
	    if (size.width <= 320 || this.options.hideVolumeBar) {
	      this.$el.addClass('w320');
	    }
	  };

	  MediaControl.prototype.toggleExpandShrink = function toggleExpandShrink() {
	    var currentIcon = this.$expandshrinkToggle.find('svg');
	    currentIcon.remove();

	    if (!this.isExpanded) {
	      this.$expandshrinkToggle.append(_shrink2.default);
	    } else {
	      this.$expandshrinkToggle.append(_expand2.default);
	    }
	    this.isExpanded = !this.isExpanded;

	    this.container.trigger(_events2.default.MC_TOGGLE_EXPAND, this.isExpanded);
	    if (this.container._options.onToggleExpandShrink(this.isExpanded)) {
	      this.hideExpandShrinkTooltip();
	    }
	  };

	  MediaControl.prototype.togglePlayPause = function togglePlayPause() {
	    if (this.container.isPlaying()) {
	      this.container.pause();
	      this.container.trigger(_events2.default.CT_PRESS_PAUSE);
	    } else {
	      this.container.play();
	      this.container.trigger(_events2.default.CT_PRESS_PLAY);
	      this.closePauseAd();
	    }

	    return false;
	  };

	  MediaControl.prototype.togglePlayStop = function togglePlayStop() {
	    if (window.zplayer_alreadyPlay) {
	      window.zplayer_alreadyPlay = false;
	      return;
	    }

	    if (this.container.isPlaying()) {
	      this.isPaused = true;
	      this.container.stop();
	    } else {
	      this.isPaused = false;
	      this.container.play();
	    }
	  };

	  MediaControl.prototype.startSeekDrag = function startSeekDrag(event) {
	    this.draggingSeekBar = true;

	    if (this.container.settings.seekEnabled || _browser2.default.isMobile) {
	      this.draggingSeekBar = true;
	      this.$el.addClass('dragging');
	      this.$seekBarLoaded.addClass('media-control-notransition');
	      this.$seekBarPosition.addClass('media-control-notransition');
	      this.$seekBarScrubber.addClass('media-control-notransition');

	      if (event) {
	        event.preventDefault();
	      }
	    }
	  };

	  MediaControl.prototype.startVolumeDrag = function startVolumeDrag(event) {
	    this.draggingVolumeBar = true;
	    this.$el.addClass('dragging');
	    if (event) {
	      event.preventDefault();
	    }
	  };

	  MediaControl.prototype.stopDrag = function stopDrag(event) {
	    if (this.draggingSeekBar) {
	      this.seek(event);
	    }
	    this.$el.removeClass('dragging');
	    this.$seekBarLoaded.removeClass('media-control-notransition');
	    this.$seekBarPosition.removeClass('media-control-notransition');
	    this.$seekBarScrubber.removeClass('media-control-notransition dragging');
	    this.draggingSeekBar = false;
	    this.draggingVolumeBar = false;
	  };

	  MediaControl.prototype.updateDrag = function updateDrag(event) {
	    if (this.draggingSeekBar) {
	      event.preventDefault();
	      var pageX = event.pageX || event.targetTouches[0].pageX;
	      var offsetX = pageX - this.$seekBarContainer.offset().left;
	      var pos = offsetX / this.$seekBarContainer.width() * 100;
	      pos = Math.min(100, Math.max(pos, 0));
	      this.container.playback.seek(pos);
	      this.setSeekPercentage(pos);
	      this.seek(event);
	    } else if (this.draggingVolumeBar) {
	      event.preventDefault();
	      this.setVolume(this.getVolumeFromUIEvent(event));
	    }
	  };

	  MediaControl.prototype.getVolumeFromUIEvent = function getVolumeFromUIEvent(event) {
	    var offsetY = event.pageX - this.$volumeBarContainer.offset().left;
	    var volumeFromUI = offsetY / this.$volumeBarContainer.width() * 100;
	    return volumeFromUI;
	  };

	  MediaControl.prototype.toggleMute = function toggleMute() {
	    if (this.muted) {
	      this.setVolume(this.currentVolume ? this.currentVolume : 100);
	    } else {
	      this.setVolume(0);
	    }
	    this.$volumeIcon.find(".zm-hv-tooltip").html(this.muted ? 'Mở âm thanh' : 'Tắt âm thanh');
	  };

	  MediaControl.prototype.setVolume = function setVolume(value) {
	    var _this6 = this;

	    value = Math.min(100, Math.max(value, 0));
	    // this will hold the intended volume
	    // it may not actually get set to this straight away
	    // if the container is not ready etc
	    this.intendedVolume = value;
	    if (value > 0) {
	      this.currentVolume = value;
	    }
	    this.persistConfig && _utils.Config.persist('volume', value);
	    var setWhenContainerReady = function setWhenContainerReady() {
	      if (_this6.container.isReady) {
	        _this6.container.setVolume(value);
	      } else {
	        _this6.listenToOnce(_this6.container, _events2.default.CT_READY, function () {
	          _this6.container.setVolume(value);
	        });
	      }
	    };

	    if (!this.container) {
	      this.listenToOnce(this, _events2.default.MC_CONTAINERCHANGED, function () {
	        setWhenContainerReady();
	      });
	    } else {
	      setWhenContainerReady();
	    }
	  };

	  MediaControl.prototype.onDblClick = function onDblClick() {
	    if (_browser2.default.isMobile || this.options.mimeType == 'audio/mp3') {
	      return;
	    }
	    this.toggleFullscreen();
	  };

	  MediaControl.prototype.toggleFullscreen = function toggleFullscreen() {
	    var shouldFullScreen = this.options.shouldFullScreen;
	    shouldFullScreen ? shouldFullScreen() && this.fullScreen() : this.fullScreen();
	  };

	  MediaControl.prototype.fullScreen = function fullScreen() {
	    this.trigger(_events2.default.MC_FULLSCREEN, this.name);
	    this.container.fullscreen();
	    this.resetUserKeepVisible();
	    this.show();
	  };

	  MediaControl.prototype.toggleSettingOption = function toggleSettingOption(e) {
	    this.hideDetailSettingOption();
	    if (this.options.subtitleUrl) {
	      this.hideDetailSubtitleOption();
	      if (!this.$subtitleOptions.hasClass('none')) {
	        this.toggleSubtitleOption(e);
	      }
	    }

	    var $settingOptions = this.$settingOptions;

	    if ($settingOptions.hasClass('none')) {
	      // $settingIcon.addClass('active');
	      $settingOptions.removeClass('none');
	    } else {
	      // $settingIcon.removeClass('active');
	      $settingOptions.addClass('none');
	    }

	    e.stopPropagation();
	  };

	  MediaControl.prototype.openAdModeSetting = function openAdModeSetting(e) {
	    this.showOption(this.$adOption);
	    this.hideSettingOptions();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.openSpeedSetting = function openSpeedSetting(e) {
	    this.showOption(this.$speedOption);
	    this.hideSettingOptions();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.openQualitySetting = function openQualitySetting(e) {
	    this.showOption(this.$qualityOption);
	    this.hideSettingOptions();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.selectAdMode = function selectAdMode(e) {
	    var adModeSelected = e.currentTarget.children[0].innerText;
	    if (adModeSelected === 'Quảng cáo') {
	      this.toggleSettingOption(e);
	      return;
	    }

	    if (adModeSelected === this.adModes[0]) {
	      // Off
	      var isVip = this.container._options.isVip;
	      if (isVip) {
	        this.currentAdModeIndex = 0;
	      } else {
	        this.container._options.requireVip();
	        return;
	      }
	    } else if (adModeSelected === this.adModes[1]) {
	      // Interrupt video
	      this.currentAdModeIndex = 1;
	    } else if (adModeSelected === this.adModes[2]) {
	      // Non-interrupt video
	      this.currentAdModeIndex = 2;
	    }

	    window.localStorage && window.localStorage.setItem("currentAdMode", this.currentAdModeIndex);
	    this.render();
	    this.renderAdMark(this.adMarks);
	    this.toggleSettingOption(e);
	    this.container.trigger(_events2.default.CT_CHANGE_AD_MODE, this.currentAdModeIndex);
	  };

	  MediaControl.prototype.selectSpeed = function selectSpeed(target) {
	    var selectedSpeed = target.currentTarget.innerText;
	    if (selectedSpeed === 'Tốc độ' || selectedSpeed === this.currentSpeed) {
	      this.toggleSettingOption(target);
	      return;
	    }
	    var speed = 1;
	    this.currentSpeed = selectedSpeed;
	    this.container.playback.render();

	    if (selectedSpeed !== 'Bình thường') {
	      var speedString = selectedSpeed.slice(0, -1);
	      speed = parseFloat(speedString);
	    }

	    this.container.setSpeed(speed);
	    this.render();
	    this.renderAdMark(this.adMarks);
	    this.toggleSettingOption(target);
	  };

	  MediaControl.prototype.selectQuality = function selectQuality(e) {
	    this.isSelectingQuality = true;
	    var level = 0;
	    if (window.localStorage) {
	      level = parseInt(window.localStorage.getItem("currentLevel"));
	    }
	    var qualitySelected = e.currentTarget.innerText;
	    if (qualitySelected === 'Chất lượng') {
	      this.toggleSettingOption(e);
	      return;
	    }
	    var selectedLevel = -1;
	    for (var i = 0; i < this.levels.length; i++) {
	      if (qualitySelected === this.levels[i].label) {
	        selectedLevel = i;
	      }
	    }

	    if (level == selectedLevel) {
	      return;
	    } else {
	      level = selectedLevel;
	    }

	    if (this.options.mimeType == 'application/x-mpegURL') {
	      this.handleHLSLevelSelect(level);
	    } else if (this.options.mimeType == 'video/mp4') {
	      this.handleMP4QualitySelect(level);
	    }
	    this.toggleSettingOption(e);
	    this.isSelectingQuality = false;
	  };

	  MediaControl.prototype.handleHLSLevelSelect = function handleHLSLevelSelect(selectedLevel) {
	    if (selectedLevel !== 0 && this.isVipLevel(selectedLevel) && !this.options.isVip) {
	      this.options.requireVip();
	    } else {
	      this.isSelectLevel = true;
	      if (selectedLevel !== 0) {
	        this.levels[0].label = 'Tự động';
	      } else {
	        this.levels[0].label = 'T\u1EF1 \u0111\u1ED9ng (' + this.levels[this.currentLevel].label + ')';
	      }
	      window.localStorage && window.localStorage.setItem("currentLevel", selectedLevel);
	      this.currentLevel = selectedLevel;
	      this.render();
	      this.container.playback.currentLevel = selectedLevel - 1;
	    }
	  };

	  MediaControl.prototype.isVipLevel = function isVipLevel(selectedLevel) {
	    return this.levels[selectedLevel].label.indexOf('VIP') !== -1;
	  };

	  MediaControl.prototype.handleMP4QualitySelect = function handleMP4QualitySelect(level) {
	    if (this.container._options.sourceLevel[level].source) {
	      window.localStorage && window.localStorage.setItem("currentLevel", level);
	      this.currentLevel = level;
	      this.render();
	      var currentTime = this.container.playback.el.currentTime;
	      this.container.playback.stop();
	      this.container.playback._setupSrc(this.container._options.sourceLevel[level].source);
	      this.container.playback.render();
	      this.container.playback.seek(currentTime);
	      this.container.playback.play();
	      this.container.trigger(_events2.default.CT_SELECTLEVEL, level);
	      this.renderAdMark(this.adMarks);
	    } else {
	      this.container._options.requireVip();
	    }
	  };

	  MediaControl.prototype.showOption = function showOption(element) {
	    if (!element) {
	      return;
	    }
	    if (element.hasClass('none')) {
	      element.removeClass('none');
	    }
	  };

	  MediaControl.prototype.hideSettingOptions = function hideSettingOptions() {
	    if (!this.$settingOptions.hasClass('none')) {
	      this.$settingOptions.addClass('none');
	      this.$settingButton.removeClass('active');
	    }
	  };

	  MediaControl.prototype.hideDetailSettingOption = function hideDetailSettingOption() {
	    this.hideElement(this.$adOption);
	    this.hideElement(this.$speedOption);
	    this.hideElement(this.$qualityOption);
	  };

	  MediaControl.prototype.hideElement = function hideElement(el) {
	    if (!el.hasClass('none')) {
	      el.addClass('none');
	    }
	  };

	  MediaControl.prototype.showElement = function showElement(el) {
	    if (el.hasClass('none')) {
	      el.removeClass('none');
	    }
	  };

	  MediaControl.prototype.hideNextButton = function hideNextButton() {
	    this.hideElement(this.$nextButton);
	  };

	  MediaControl.prototype.hidePrevButton = function hidePrevButton() {
	    this.hideElement(this.$prevButton);
	  };

	  MediaControl.prototype.showPrevButton = function showPrevButton() {
	    this.showElement(this.$prevButton);
	  };

	  MediaControl.prototype.showNextButton = function showNextButton() {
	    this.showElement(this.$nextButton);
	  };

	  MediaControl.prototype.toggleSubtitleOption = function toggleSubtitleOption(e) {
	    this.hideDetailSubtitleOption();
	    this.hideDetailSettingOption();
	    if (!this.$settingOptions.hasClass('none')) {
	      this.toggleSettingOption(e);
	    }

	    if (this.$subtitleOptions.hasClass('none')) {
	      this.$subtitleButton.addClass('active');
	      this.$subtitleOptions.removeClass('none');
	    } else {
	      this.$subtitleButton.removeClass('active');
	      this.$subtitleOptions.addClass('none');
	    }
	    e.stopPropagation();
	  };

	  MediaControl.prototype.openSubColorSetting = function openSubColorSetting(e) {
	    this.showOption(this.$subColorOption);
	    this.hideSubtitleSettingOption();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.openSubSizeSetting = function openSubSizeSetting(e) {
	    this.showOption(this.$subSizeOption);
	    this.hideSubtitleSettingOption();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.openSubPosSetting = function openSubPosSetting(e) {
	    this.showOption(this.$subPosOption);
	    this.hideSubtitleSettingOption();
	    e.stopPropagation();
	  };

	  MediaControl.prototype.toggleSub = function toggleSub(e) {
	    this.isSubOn = !this.isSubOn;
	    window.localStorage && window.localStorage.setItem("isSubOn", this.isSubOn);
	    this.subtitlePlugin.toggleSub(this.isSubOn);
	    this.toggleSubtitleOption(e);
	    e.stopPropagation();
	  };

	  MediaControl.prototype.toggleSubBackground = function toggleSubBackground(e) {
	    this.isSubBackgroundOn = !this.isSubBackgroundOn;
	    window.localStorage && window.localStorage.setItem("isSubBackgroundOn", this.isSubBackgroundOn);
	    // this.container.playback.toggleSubBackground(this.isSubBackgroundOn);
	    this.subtitlePlugin.toggleSubBackground(this.isSubBackgroundOn);
	    this.toggleSubtitleOption(e);
	    e.stopPropagation();
	  };

	  MediaControl.prototype.hideDetailSubtitleOption = function hideDetailSubtitleOption() {
	    this.hideElement(this.$subColorOption);
	    this.hideElement(this.$subSizeOption);
	    this.hideElement(this.$subPosOption);
	  };

	  MediaControl.prototype.hideSubtitleSettingOption = function hideSubtitleSettingOption() {
	    if (!this.$subtitleButton.hasClass('none')) {
	      this.$subtitleOptions.addClass('none');
	    }
	  };

	  MediaControl.prototype.selectSubColor = function selectSubColor(e) {
	    var selectedColor = this.getOptionValue(e, this.subColorText);
	    if (!selectedColor) {
	      return;
	    }

	    // Update current sub-color
	    this.subtitlePlugin.setColor(selectedColor);
	    this.currentSubColor = selectedColor;
	    window.localStorage && window.localStorage.setItem("subColor", this.currentSubColor);

	    this.render();
	    this.toggleSubtitleOption(e);
	  };

	  MediaControl.prototype.selectSubSize = function selectSubSize(e) {
	    var selectedSize = this.getOptionValue(e, this.subSizeText);
	    if (!selectedSize) {
	      return;
	    }

	    // Update current sub-size
	    this.subtitlePlugin.setSize(selectedSize);
	    this.currentSubSize = selectedSize;
	    window.localStorage && window.localStorage.setItem("subSize", this.currentSubSize);

	    this.render();
	    this.toggleSubtitleOption(e);
	  };

	  MediaControl.prototype.selectSubPos = function selectSubPos(e) {
	    var selectedPos = this.getOptionValue(e, this.subPosText);
	    if (!selectedPos) {
	      return;
	    }

	    // Update current sub-position
	    this.subtitlePlugin.setPos(selectedPos);
	    this.currentSubPos = selectedPos;
	    window.localStorage && window.localStorage.setItem("subPos", this.currentSubPos);

	    this.render();
	    this.toggleSubtitleOption(e);
	  };

	  MediaControl.prototype.getOptionValue = function getOptionValue(e, header) {
	    var selectedSize = e.currentTarget.innerText;
	    if (selectedSize === header || selectedSize === this.currentSubSize) {
	      this.toggleSubtitleOption(e);
	      return '';
	    }
	    return selectedSize;
	  };

	  MediaControl.prototype.setContainer = function setContainer(container) {
	    if (this.container) {
	      this.stopListening(this.container);
	      this.fullScreenOnVideoTagSupported = null;
	    }
	    _mediator2.default.off(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, this.playerResize, this);
	    this.container = container;
	    // set the new container to match the volume of the last one
	    this.setVolume(this.intendedVolume);
	    this.changeTogglePlay();
	    this.addEventListeners();
	    this.updateSettting();
	    this.container.trigger(_events2.default.CT_PLAYBACKDVRSTATECHANGED, this.container.isDvrInUse());
	    if (this.container.mediaControlDisabled) {
	      this.disable();
	    }
	    this.trigger(_events2.default.MC_CONTAINERCHANGED);
	  };

	  MediaControl.prototype.hideVolumeBar = function hideVolumeBar() {
	    var _this7 = this;

	    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;

	    if (!this.$volumeBarContainer) return;
	    if (this.draggingVolumeBar) {
	      this.hideVolumeId = setTimeout(function () {
	        return _this7.hideVolumeBar();
	      }, timeout);
	    } else {
	      if (this.hideVolumeId) {
	        clearTimeout(this.hideVolumeId);
	      }
	      this.hideVolumeId = setTimeout(function () {
	        return _this7.$volumeBarContainer.addClass('volume-bar-hide');
	      }, timeout);
	    }
	  };

	  MediaControl.prototype.ended = function ended() {
	    this.isEnded = true;
	    this.show();
	    if (this.shouldShowSuggestion()) {
	      this.$suggestions.removeClass('none');
	    }
	    this.changeTogglePlay();
	  };

	  MediaControl.prototype.shouldShowSuggestion = function shouldShowSuggestion() {
	    return this.options.suggestions && this.options.suggestions.length > 0 && this.playModeSong == 1;
	  };

	  MediaControl.prototype.updateProgressBar = function updateProgressBar(progress) {
	    var loadedStart = progress.start / progress.total * 100;
	    var loadedEnd = progress.current / progress.total * 100;

	    this.$seekBarLoaded.css({ left: loadedStart + '%', width: loadedEnd - loadedStart + '%' });
	  };

	  MediaControl.prototype.onTimeUpdate = function onTimeUpdate(timeProgress) {
	    if (this.draggingSeekBar) return;
	    var position = timeProgress.current < 0 ? timeProgress.total : timeProgress.current;

	    this.currentPositionValue = position;
	    this.currentDurationValue = timeProgress.total;

	    var adIndex = this.shouldRenderAd(timeProgress);
	    if (adIndex !== -1) {
	      this.container.trigger(_events2.default.CT_START_MID_AD, adIndex);
	    } else {
	      this.renderSeekBar();
	    }
	  };

	  MediaControl.prototype.shouldRenderAd = function shouldRenderAd(timeprogress) {
	    var length = this.adMarks.length;
	    for (var i = length - 1; i >= 0; i--) {
	      var adMark = this.adMarks[i];
	      if (timeprogress.current >= adMark && !this.adMarksFlag[i]) {
	        this.adMarksFlag[i] = true;
	        return i;
	      }
	    }
	    return -1;
	  };

	  MediaControl.prototype.renderSeekBar = function renderSeekBar() {
	    if (this.container.getPlaybackType() === _playback2.default.LIVE) {
	      this.$seekBarContainer.hide();
	      return;
	    }

	    if (this.currentPositionValue === null || this.currentDurationValue === null) {
	      // this will be triggered as soon as these become available
	      return;
	    }

	    // default to 100%
	    this.currentSeekBarPercentage = 100;
	    if (this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrInUse()) {
	      this.currentSeekBarPercentage = this.currentPositionValue / this.currentDurationValue * 100;
	    }
	    this.setSeekPercentage(this.currentSeekBarPercentage);

	    var newPosition = (0, _utils.formatTime)(this.currentPositionValue);
	    var newDuration = (0, _utils.formatTime)(this.currentDurationValue);
	    if (newPosition !== this.displayedPosition) {
	      this.$position.text(newPosition);
	      this.displayedPosition = newPosition;
	    }
	    if (newDuration !== this.displayedDuration) {
	      this.$duration.text(newDuration);
	      this.displayedDuration = newDuration;
	    }
	    this.$duration.show();
	  };

	  MediaControl.prototype.seek = function seek(event) {
	    var pageX = event.pageX || event.targetTouches.length > 0 && event.targetTouches[0].pageX || event.changedTouches[0].pageX;
	    var offsetX = pageX - this.$seekBarContainer.offset().left;

	    var pos = offsetX / this.$seekBarContainer.width() * 100;
	    pos = Math.min(100, Math.max(pos, 0));

	    this.container.seekPercentage(pos);
	    this.setSeekPercentage(pos);
	    var currentTime = this.container.getCurrentTime();
	    this.$position.text((0, _utils.formatTime)(currentTime));
	    if (this.isEnded) {
	      this.play();
	    }
	  };

	  MediaControl.prototype.setKeepVisible = function setKeepVisible() {
	    this.keepVisible = true;
	  };

	  MediaControl.prototype.resetKeepVisible = function resetKeepVisible() {
	    this.keepVisible = false;
	  };

	  MediaControl.prototype.setUserKeepVisible = function setUserKeepVisible() {
	    this.userKeepVisible = true;
	  };

	  MediaControl.prototype.resetUserKeepVisible = function resetUserKeepVisible() {
	    this.userKeepVisible = false;
	  };

	  MediaControl.prototype.isVisible = function isVisible() {
	    return !this.$el.hasClass('media-control-hide');
	  };

	  MediaControl.prototype.show = function show(event) {
	    var _this8 = this;

	    if (this.isPlayingLinear || this.isPlayingAudioAd) {
	      return;
	    }

	    if (this.disabled) return;
	    var timeout = 3000;
	    if (!event || event.clientX !== this.lastMouseX && event.clientY !== this.lastMouseY || navigator.userAgent.match(/firefox/i)) {
	      clearTimeout(this.hideId);
	      this.$el.show();
	      this.trigger(_events2.default.MC_SHOW, this.name);
	      this.container && this.container.trigger(_events2.default.CT_SHOW);
	      this.$el.removeClass('media-control-hide');
	      if (!this.options.alwaysShowControl) {
	        this.hideId = setTimeout(function () {
	          return _this8.hide();
	        }, timeout);
	      }
	      if (event) {
	        this.lastMouseX = event.clientX;
	        this.lastMouseY = event.clientY;
	      }
	    }
	  };

	  MediaControl.prototype.hide = function hide() {
	    var _this9 = this;

	    var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    // Don't hide media control at the end of video
	    if (this.isEnded && this.options.mimeType == 'video/mp4') {
	      return;
	    }

	    if (!this.options.alwaysShowControl || this.options.audioAdUrl && this.isPlayingAudioAd || this.isPlayingLinear) {
	      var timeout = delay || 2000;
	      clearTimeout(this.hideId);
	      if (!this.isVisible() || this.options.hideMediaControl === false) return;
	      if (delay || this.userKeepVisible && !this.isPlayingAudioAd || this.keepVisible || this.draggingSeekBar || this.draggingVolumeBar) {
	        this.hideId = setTimeout(function () {
	          return _this9.hide();
	        }, timeout);
	      } else {
	        this.trigger(_events2.default.MC_HIDE, this.name);
	        this.container && this.container.trigger(_events2.default.CT_HIDE);
	        this.$el.addClass('media-control-hide');
	        this.hideVolumeBar(0);
	      }
	    }
	  };

	  MediaControl.prototype.optionsUpdate = function optionsUpdate() {
	    this.render();
	  };

	  MediaControl.prototype.updateSettting = function updateSettting() {
	    var newSettings = assign({}, this.container.settings);
	    var settingsChanged = JSON.stringify(this.settings) != JSON.stringify(newSettings);
	    var playBackType = this.container.getPlaybackType();
	    var mimeType = this.options.mimeType;

	    if (mimeType === 'audio/mp3') {
	      // remove fullscreen from settings if it is present
	      newSettings.default && (0, _utils.removeArrayItem)(newSettings.default, 'fullscreen');
	      newSettings.left && (0, _utils.removeArrayItem)(newSettings.left, 'fullscreen');
	      newSettings.right && (0, _utils.removeArrayItem)(newSettings.right, 'fullscreen');
	    }

	    if (playBackType && settingsChanged) {
	      this.settings = newSettings;
	      this.updateSettingByMimeType(mimeType);
	      this.render();
	    }
	  };

	  MediaControl.prototype.updateSettingByMimeType = function updateSettingByMimeType(mimeType) {
	    if (mimeType === 'audio/mp3') {
	      this.settings = {
	        left: ['prev', 'playpause', 'next', 'volume', 'position', 'duration'],
	        right: [],
	        default: ['seekbar']
	      };
	    } else if (this.options.playerType === 'song' || this.options.playerType === 'album') {
	      this.settings = {
	        left: ['prev', 'playpause', 'next', 'replay', 'volume', 'position', 'duration'],
	        right: ['fullscreen', 'expandshrink', 'hd-indicator'],
	        default: ['seekbar']
	      };

	      if (!this.options.enableTheaterMode) {
	        var theaterModeIndex = this.settings.right.indexOf("expandshrink");
	        this.settings.right.splice(theaterModeIndex, 1);
	      }
	      if (this.options.showSetting) {
	        this.settings.right.push('setting');
	      }
	      if (this.options.subtitleUrl) {
	        this.settings.right.push('cc');
	      }
	    }
	  };

	  MediaControl.prototype.highDefinitionUpdate = function highDefinitionUpdate(isHD) {
	    var method = isHD ? 'addClass' : 'removeClass';
	    // this.$hdIndicator[method]('enabled')
	  };

	  MediaControl.prototype.createCachedElements = function createCachedElements() {
	    var $layer = this.$el.find('.media-control-layer');

	    this.$duration = $layer.find('.media-control-indicator[data-duration]');
	    this.$position = $layer.find('.media-control-indicator[data-position]');
	    this.$expandshrinkToggle = $layer.find('button.media-control-button[data-expandshrink]');
	    this.$fullscreenToggle = $layer.find('button.media-control-button[data-fullscreen]');
	    this.$playPauseToggle = $layer.find('button.media-control-button[data-playpause]');
	    this.$playStopToggle = $layer.find('button.media-control-button[data-playstop]');
	    this.$nextButton = $layer.find('button.media-control-button[data-next]');
	    this.$prevButton = $layer.find('button.media-control-button[data-prev]');
	    this.$seekBarContainer = $layer.find('.bar-container[data-seekbar]');
	    this.$adMarksContainer = $layer.find('#ad-marks-container');
	    this.$seekBarHover = $layer.find('.bar-hover[data-seekbar]');
	    this.$seekBarLoaded = $layer.find('.bar-fill-1[data-seekbar]');
	    this.$seekBarPosition = $layer.find('.bar-fill-2[data-seekbar]');
	    this.$seekBarScrubber = $layer.find('.bar-scrubber[data-seekbar]');
	    this.$volumeBarContainer = $layer.find('.bar-container[data-volume]');
	    this.$volumeContainer = $layer.find('.drawer-container[data-volume]');
	    this.$volumeIcon = $layer.find('.drawer-icon[data-volume]');
	    this.$volumeBarBackground = this.$el.find('.bar-background[data-volume]');
	    this.$volumeBarFill = this.$el.find('.bar-container[data-volume] .zm-volume-available');
	    this.$volumeBarScrubber = this.$el.find('.bar-scrubber[data-volume]');
	    this.$hdIndicator = this.$el.find('button.media-control-button[data-hd-indicator]');
	    this.$levelPopup = this.$el.find('.zm-tooltip');
	    this.$karaokeButton = this.$el.find('.zm-jump-lyric');
	    this.$playmodeButton = this.$el.find('#zm-repeat-album');
	    this.$playmodeSongButton = this.$el.find('#zm-repeat-song');
	    this.$mvButton = this.$el.find('.zm-jump-mv');
	    this.$suggestions = this.$el.find('.zm-endscreen-content');

	    // Ad Elements
	    this.$adContainer = this.$el.find('.non-linear-ad');
	    this.$nonLinearAdImage = this.$el.find('#non-linear-ad-image');
	    this.$pauseAdContainer = this.$el.find('.pause-ad');
	    this.$pauseAdImage = this.$el.find('#pause-ad-image');

	    // Video Setting Elements
	    this.$settingContainer = $layer.find('.zm-setting');
	    this.$settingButton = $layer.find('button.media-control-button[data-setting]');
	    this.$settingOptions = this.$settingContainer.find('#setting-options');
	    this.$adOption = this.$settingContainer.find('#zm-ad-option');
	    this.$speedOption = this.$settingContainer.find('#zm-speed-option');
	    this.$qualityOption = this.$settingContainer.find('#zm-quality-option');

	    // Subtitle Setting Element
	    this.$subtitleSettingContainer = $layer.find('.cc-setting');
	    this.$subtitleButton = $layer.find('button.media-control-button[data-cc]');
	    this.$subtitleOptions = this.$subtitleSettingContainer.find('#subtitle-options');
	    this.$subColorOption = this.$subtitleSettingContainer.find('#zm-subcolor-option');
	    this.$subSizeOption = this.$subtitleSettingContainer.find('#zm-subsize-option');
	    this.$subPosOption = this.$subtitleSettingContainer.find('#zm-subpos-option');

	    this.resetIndicators();
	    this.initializeIcons();
	  };

	  MediaControl.prototype.toggleLevel = function toggleLevel() {
	    if (this.$levelPopup.hasClass('none')) {
	      this.$levelPopup.removeClass('none');
	    } else {
	      this.$levelPopup.addClass('none');
	    }
	  };

	  MediaControl.prototype.selectLevel = function selectLevel(target) {
	    var level = 0;
	    if (window.localStorage) {
	      level = parseInt(window.localStorage.getItem("currentLevel"));
	    }
	    for (var i = 0; i < this.container._options.sourceLevel.length; i++) {
	      if (target.currentTarget.children[0].innerHTML == this.container._options.sourceLevel[i].label) {
	        level = i;
	      }
	    }

	    this.toggleLevel();
	    if (this.container._options.sourceLevel[level].source) {
	      window.localStorage && window.localStorage.setItem("currentLevel", level);
	      this.currentLevel = level;
	      this.render();
	      var currentTime = this.container.playback.el.currentTime;
	      this.container.playback._setupSrc(this.container._options.sourceLevel[level].source);
	      this.container.playback.render();
	      this.container.playback.seek(currentTime);
	      this.container.playback.play();
	      this.container.trigger(_events2.default.CT_SELECTLEVEL, level);
	    } else {
	      this.container._options.requireVip(level);
	    }
	    this.render();
	  };

	  MediaControl.prototype.resetIndicators = function resetIndicators() {
	    this.displayedPosition = this.$position.text();
	    this.displayedDuration = this.$duration.text();
	    this.$duration.hide();
	  };

	  MediaControl.prototype.initializeIcons = function initializeIcons() {
	    var $layer = this.$el.find('.media-control-layer');
	    $layer.find('button.media-control-button[data-play]').append(_play2.default);
	    $layer.find('button.media-control-button[data-pause]').append(_pause2.default);
	    $layer.find('button.media-control-button[data-stop]').append(_stop2.default);
	    this.$settingButton.append(_setting2.default);
	    this.$subtitleButton.append(_cc2.default);
	    this.$playPauseToggle.append(_play2.default);
	    this.$playStopToggle.append(_play2.default);
	    this.$expandshrinkToggle.append(_expand2.default);
	    this.$prevButton.addClass("zp-button-prev");
	    this.$prevButton.append(_pre2.default);
	    this.$nextButton.addClass("zp-button-next");
	    this.$nextButton.append(_next2.default);
	    this.$karaokeButton.append(_karaoke2.default);

	    if (!this.options.hideVolumeIcon) {
	      this.setVolumeIcon();
	      this.$volumeIcon.append(_volumeHigh2.default);
	    } else {
	      this.$volumeBarContainer.hide();
	    }

	    this.$hdIndicator.append(_hd2.default);
	    this.toggleControlButton(this.options.playerType);
	  };

	  MediaControl.prototype.toggleControlButton = function toggleControlButton(playerType) {
	    if (playerType == 'album') {
	      this.$nextButton.show();
	      this.$prevButton.show();
	    } else if (playerType == 'song') {
	      this.toggleSongControlButton();
	    }
	  };

	  MediaControl.prototype.toggleSongControlButton = function toggleSongControlButton() {
	    if (this.playModeSong == 1 || this.options.showNextButton) {
	      this.$nextButton.show();
	    } else {
	      this.$nextButton.hide();
	    }
	    if (this.options.showPrevButton) {
	      this.$prevButton.show();
	    } else {
	      this.$prevButton.hide();
	    }
	  };

	  MediaControl.prototype.setSeekPercentage = function setSeekPercentage(value) {
	    value = Math.max(Math.min(value, 100.0), 0);
	    if (this.displayedSeekBarPercentage === value) {
	      // Not changed since last update
	      return;
	    }
	    this.displayedSeekBarPercentage = value;

	    this.$seekBarPosition.removeClass('media-control-notransition');
	    this.$seekBarScrubber.removeClass('media-control-notransition');
	    this.$seekBarPosition.css({ width: value + '%' });
	    this.$seekBarScrubber.css({ left: value + '%' });
	  };

	  MediaControl.prototype.seekRelative = function seekRelative(delta) {
	    if (!this.container.settings.seekEnabled) return;
	    var currentTime = this.container.getCurrentTime();
	    var duration = this.container.getDuration();
	    var position = Math.min(Math.max(currentTime + delta, 0), duration);
	    position = Math.min(position * 100 / duration, 100);
	    this.container.seekPercentage(position);
	  };

	  MediaControl.prototype.bindKeyEvents = function bindKeyEvents() {
	    var _this10 = this;

	    this.unbindKeyEvents();
	    this.kibo = new _vendor.Kibo(this.options.focusElement);
	    this.kibo.down(['space'], function () {
	      return !_this10.isPlayingLinear && _this10.togglePlayPause();
	    });
	    this.kibo.down(['left'], function () {
	      return !_this10.isPlayingLinear && _this10.seekRelative(-15);
	    });
	    this.kibo.down(['right'], function () {
	      return !_this10.isPlayingLinear && _this10.seekRelative(15);
	    });
	    var keys = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
	    keys.forEach(function (i) {
	      _this10.kibo.down(i.toString(), function () {
	        return _this10.container.settings.seekEnabled && _this10.container.seekPercentage(i * 10);
	      });
	    });
	  };

	  MediaControl.prototype.unbindKeyEvents = function unbindKeyEvents() {
	    if (this.kibo) {
	      this.kibo.off('space');
	      this.kibo.off('left');
	      this.kibo.off('right');
	      this.kibo.off([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
	    }
	  };

	  MediaControl.prototype.parseColors = function parseColors() {
	    if (this.options.mediaControl) {
	      this.buttonsColor = this.options.mediaControl.buttons;
	      var seekbarColor = this.options.mediaControl.seekBar;
	      this.$el.find('.bar-fill-2[data-seekbar]').css('background-color', seekbarColor);
	      this.$el.find('.zm-volume-available').css('background', this.buttonsColor);
	      this.$el.find('.segmented-bar-element[data-volume]').css('boxShadow', 'inset 2px 0 0 ' + this.buttonsColor);
	    }
	  };

	  MediaControl.prototype.applyButtonStyle = function applyButtonStyle(element) {
	    var _this11 = this;

	    if (this.buttonsColor && element) {
	      element.mouseover(function () {
	        (0, _clapprZepto2.default)(element).find('svg path').css('fill', _this11.buttonsColor);
	      });
	      element.mouseleave(function () {
	        (0, _clapprZepto2.default)(element).find('svg path').css('fill', 'white');
	      });
	    }
	  };

	  MediaControl.prototype.destroy = function destroy() {
	    this.remove();

	    (0, _clapprZepto2.default)(document).unbind('mouseup', this.stopDragHandler);
	    (0, _clapprZepto2.default)(document).unbind('touchend', this.stopDragHandler);
	    (0, _clapprZepto2.default)(document).unbind('mousemove', this.updateDragHandler);
	    (0, _clapprZepto2.default)(document).unbind('touchmove', this.updateDragHandler);

	    this.unbindKeyEvents();
	  };

	  MediaControl.prototype.isHLS = function isHLS() {
	    var options = !this.container ? this.options : this.container._options;
	    return options.mimeType === 'application/x-mpegURL';
	  };

	  MediaControl.prototype.render = function render() {
	    var _this12 = this;

	    if (window.localStorage != null) {
	      this.currentLevel = parseInt(window.localStorage.getItem("currentLevel"));
	    } else {
	      this.currentLevel = 0;
	    }
	    if (!this.currentLevel || this.isHLS() && !this.isSelectLevel || this.container && this.container._options.sourceLevel && (!this.container._options.sourceLevel[this.currentLevel] || !this.container._options.sourceLevel[this.currentLevel].source)) {
	      this.currentLevel = 0;
	    }

	    var timeout = 1000;
	    if (!this.options.customMediaControl) {
	      this.$el.html(this.template({
	        adModes: this.adModes,
	        adTooltips: this.adTooltips,
	        currentAdMode: this.adModes[this.currentAdModeIndex],
	        currentSpeed: this.currentSpeed,
	        currentSubColor: this.currentSubColor,
	        currentSubSize: this.currentSubSize,
	        currentSubPos: this.currentSubPos,
	        subColors: this.subColors,
	        subSizes: this.subSizes,
	        subPositions: this.subPosistions,
	        playSpeeds: this.playSpeeds,
	        settings: this.settings,
	        options: !this.container ? this.options : this.container._options,
	        currentLevel: this.currentLevel,
	        isSubOn: this.isSubOn,
	        isSubBackgroundOn: this.isSubBackgroundOn,
	        levels: this.levels
	      }));
	      !this.options.hasAnPlayerInstance && this.$el.append(this.stylesheet);
	    }
	    this.createCachedElements();
	    this.$playPauseToggle.addClass('paused');
	    this.$playStopToggle.addClass('stopped');

	    this.changeTogglePlay();

	    this.hideId = setTimeout(function () {
	      return _this12.hide();
	    }, timeout);

	    if (_browser2.default.isMobile) {
	      this.$volumeBarContainer.css('display', 'none');
	      this.$volumeIcon.find(".zm-hv-tooltip").css('display', 'none');
	      this.$seekBarHover.hide();
	    }

	    this.$seekBarPosition.addClass('media-control-notransition');
	    this.$seekBarScrubber.addClass('media-control-notransition');

	    var previousSeekPercentage = 0;
	    if (this.currentSeekBarPercentage) {
	      previousSeekPercentage = this.currentSeekBarPercentage;
	    }
	    this.currentSeekBarPercentage = null;
	    this.setSeekPercentage(previousSeekPercentage);

	    process.nextTick(function () {
	      if (!_this12.container.settings.seekEnabled) {
	        _this12.$seekBarContainer.addClass('seek-disabled');
	      }
	      if (!_this12.options.disableKeyboardShortcuts) {
	        _this12.bindKeyEvents();
	      }
	      _this12.playerResize({ width: _this12.options.width, height: _this12.options.height });
	      _this12.hideVolumeBar(0);
	    });

	    this.parseColors();
	    this.highDefinitionUpdate();

	    this.rendered = true;
	    this.updateVolumeUI();
	    this.trigger(_events2.default.MC_RENDERED);

	    // render playmode album
	    this.playMode = 0;
	    if (window.localStorage) {
	      var savedPlayMode = window.localStorage.getItem("playmode");
	      this.playMode = savedPlayMode || 0;
	    }

	    this.setPlayModeIcon();

	    // render playmode song
	    this.playModeSong = 0;
	    if (window.localStorage) {
	      this.playModeSong = window.localStorage.getItem("playmodesong");
	    }

	    this.setPlayModeSongIcon();
	    this.renderAdMark(this.adMarks);

	    return this;
	  };

	  MediaControl.prototype.setPlayModeIcon = function setPlayModeIcon() {
	    var currentIcons = this.$playmodeButton.find('svg');
	    currentIcons.remove();

	    if (this.playMode == 0) {
	      this.$playmodeButton.append(_repeatAll2.default);
	    } else if (this.playMode == 1) {
	      this.$playmodeButton.append(_shuffle2.default);
	    } else if (this.playMode == 2) {
	      this.$playmodeButton.append(_noRepeat2.default);
	    } else if (this.playMode == 3) {
	      this.$playmodeButton.append(_repeatOne2.default);
	    }
	  };

	  MediaControl.prototype.setSubSetting = function setSubSetting() {
	    var _this13 = this;

	    if (this.options.subtitleUrl) {
	      this.subtitlePlugin = this.container.getPlugin('subtitle');
	      setTimeout(function () {
	        _this13.subtitlePlugin.toggleSub(_this13.isSubOn);
	        _this13.subtitlePlugin.toggleSubBackground(_this13.isSubBackgroundOn);
	        _this13.subtitlePlugin.setColor(_this13.currentSubColor);
	        _this13.subtitlePlugin.setSize(_this13.currentSubSize);
	        _this13.subtitlePlugin.setPos(_this13.currentSubPos);
	      }, SUB_CHANGE_TIMEOUT);
	    }
	  };

	  return MediaControl;
	}(_ui_object2.default);

	exports.default = MediaControl;


	MediaControl.extend = function (properties) {
	  return (0, _utils.extend)(MediaControl, properties);
	};
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Playback = function (_UIObject) {
	    _inherits(Playback, _UIObject);

	    _createClass(Playback, [{
	        key: 'ended',
	        get: function get() {
	            return false;
	        }
	    }, {
	        key: 'i18n',
	        get: function get() {
	            return this._i18n;
	        }
	    }, {
	        key: 'buffering',
	        get: function get() {
	            return false;
	        }
	    }]);

	    function Playback(options, i18n) {
	        _classCallCheck(this, Playback);

	        var _this = _possibleConstructorReturn(this, _UIObject.call(this, options));

	        _this.settings = {};
	        _this._i18n = i18n;
	        return _this;
	    }

	    Playback.prototype.toggleSub = function toggleSub(isSubOn) {};

	    Playback.prototype.toggleSubBackground = function toggleSubBackground(isSubBackgroundOn) {};

	    Playback.prototype.play = function play() {};

	    Playback.prototype.pause = function pause() {};

	    Playback.prototype.stop = function stop() {};

	    Playback.prototype.seek = function seek(time) {}; // eslint-disable-line no-unused-vars


	    Playback.prototype.seekPercentage = function seekPercentage(percentage) {}; // eslint-disable-line no-unused-vars


	    Playback.prototype.getStartTimeOffset = function getStartTimeOffset() {
	        return 0;
	    };

	    Playback.prototype.getDuration = function getDuration() {
	        return 0;
	    };

	    Playback.prototype.isPlaying = function isPlaying() {
	        return false;
	    };

	    Playback.prototype.getPlaybackType = function getPlaybackType() {
	        return Playback.NO_OP;
	    };

	    Playback.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
	        return false;
	    };

	    Playback.prototype.volume = function volume(value) {}; // eslint-disable-line no-unused-vars


	    Playback.prototype.destroy = function destroy() {
	        this.$el.remove();
	    };

	    _createClass(Playback, [{
	        key: 'isReady',
	        get: function get() {
	            return false;
	        }
	    }]);

	    return Playback;
	}(_ui_object2.default);

	exports.default = Playback;


	Playback.extend = function (properties) {
	    return (0, _utils.extend)(Playback, properties);
	};

	Playback.canPlay = function (source, mimeType) {
	    // eslint-disable-line no-unused-vars
	    return false;
	};

	Playback.VOD = 'vod';

	Playback.AOD = 'aod';

	Playback.LIVE = 'live';
	Playback.LIVE_END = 'live_end';

	Playback.NO_OP = 'no_op';

	Playback.type = 'playback';
	module.exports = exports['default'];

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".pull-left {\n  float: left !important; }\n\n.pull-right {\n  float: right !important; }\n\n.mr0 {\n  margin-right: 0 !important; }\n\n.group:after {\n  display: block;\n  visibility: hidden;\n  clear: both;\n  height: 0;\n  content: \" \";\n  font-size: 0; }\n\n.group:after {\n  content: \"\";\n  display: table;\n  clear: both; }\n\n.group {\n  display: block;\n  clear: both; }\n\n.media-control-notransition {\n  -webkit-transition: none !important;\n  -moz-transition: none !important;\n  -ms-transition: none !important;\n  -o-transition: none !important;\n  transition: none !important; }\n\n.media-control[data-media-control] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  bottom: 0;\n  z-index: 10012;\n  pointer-events: none;\n  overflow: hidden; }\n  .media-control[data-media-control].dragging {\n    cursor: -webkit-grabbing !important;\n    cursor: grabbing !important;\n    cursor: url(" + __webpack_require__(62) + "), move; }\n    .media-control[data-media-control].dragging * {\n      cursor: -webkit-grabbing !important;\n      cursor: grabbing !important;\n      cursor: url(" + __webpack_require__(62) + "), move; }\n  .media-control[data-media-control] .media-control-background[data-background] {\n    position: absolute;\n    height: 15%;\n    width: 100%;\n    bottom: 0;\n    background: -webkit-linear-gradient(transparent, rgba(0, 0, 0, 0.9));\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));\n    -webkit-transition: opacity 0.2s ease-out;\n    -moz-transition: opacity 0.2s ease-out;\n    -ms-transition: opacity 0.2s ease-out;\n    -o-transition: opacity 0.2s ease-out;\n    transition: opacity 0.2s ease-out; }\n  .media-control[data-media-control] .media-control-icon {\n    float: right;\n    line-height: 0;\n    letter-spacing: 0;\n    speak: none;\n    color: white;\n    vertical-align: middle;\n    text-align: left;\n    -webkit-transition: all 0.1s ease;\n    -moz-transition: all 0.1s ease;\n    -ms-transition: all 0.1s ease;\n    -o-transition: all 0.1s ease;\n    transition: all 0.1s ease; }\n  .media-control[data-media-control].media-control-hide .media-control-background[data-background] {\n    display: none;\n    opacity: 0; }\n  .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] {\n    display: none; }\n    .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n      opacity: 0; }\n  .media-control[data-media-control] .media-control-layer[data-controls] {\n    position: absolute;\n    bottom: 7px;\n    width: 100%;\n    height: 32px;\n    font-size: 0;\n    vertical-align: middle;\n    pointer-events: auto; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-left-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      left: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-center-panel[data-media-control] {\n      height: 100%;\n      text-align: center; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-right-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      right: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button {\n      background-color: transparent;\n      border: 0;\n      margin: 0 6px;\n      padding: 0;\n      cursor: pointer;\n      display: inline-block;\n      width: 30px;\n      height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg {\n        height: 33px;\n        top: -1px;\n        position: relative; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg path {\n          fill: white; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg:hover path {\n        fill: #fff; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button:focus {\n        outline: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-prev] {\n        float: left;\n        height: 100%;\n        margin-top: -2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-next] {\n        float: left;\n        height: 100%;\n        margin-top: -2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-play] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-pause] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-stop] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-fullscreen] {\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-setting] {\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator] {\n        cursor: default;\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%;\n        display: none; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled {\n          opacity: 1.0;\n          display: block; }\n          .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled:hover {\n            opacity: 1.0;\n            text-shadow: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playpause] {\n        float: left; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playstop] {\n        float: left; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position], .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      display: inline-block;\n      font-size: 14px;\n      color: white;\n      cursor: default;\n      line-height: 32px;\n      position: relative; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position] {\n      margin: 0 6px 0 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      color: rgba(255, 255, 255, 0.5);\n      margin-right: 6px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration]:before {\n        content: \"|\";\n        margin-right: 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] {\n      position: absolute;\n      top: -20px;\n      left: 0;\n      display: inline-block;\n      vertical-align: middle;\n      width: 100%;\n      height: 25px;\n      cursor: pointer; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-ad-mark[data-seekbar] {\n        z-index: 10016;\n        opacity: 1;\n        height: 2px;\n        width: 5px;\n        top: 0;\n        background-color: #d9cd28;\n        position: absolute;\n        display: inline; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] {\n        width: 100%;\n        height: 2px;\n        position: relative;\n        top: 12px;\n        background-color: #666666; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-1[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #c2c2c2;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          -ms-transition: all 0.1s ease-out;\n          -o-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #fff;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          -ms-transition: all 0.1s ease-out;\n          -o-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0;\n          position: absolute;\n          top: -3px;\n          width: 5px;\n          height: 12px;\n          background-color: rgba(255, 255, 255, 0.5);\n          -webkit-transition: opacity 0.1s ease;\n          -moz-transition: opacity 0.1s ease;\n          -ms-transition: opacity 0.1s ease;\n          -o-transition: opacity 0.1s ease;\n          transition: opacity 0.1s ease; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n        opacity: 1; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-scrubber[data-seekbar] {\n        display: block;\n        top: -2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-background[data-seekbar] {\n        height: 6px;\n        top: 8px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-ad-mark[data-seekbar] {\n        height: 6px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled {\n        cursor: default; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n        display: none;\n        position: absolute;\n        -webkit-transform: translateX(-50%);\n        -moz-transform: translateX(-50%);\n        -ms-transform: translateX(-50%);\n        -o-transform: translateX(-50%);\n        transform: translateX(-50%);\n        top: 2px;\n        left: 0;\n        width: 20px;\n        height: 20px;\n        opacity: 1;\n        z-index: 10017;\n        -webkit-transition: all 0.1s ease-out;\n        -moz-transition: all 0.1s ease-out;\n        -ms-transition: all 0.1s ease-out;\n        -o-transition: all 0.1s ease-out;\n        transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] .bar-scrubber-icon[data-seekbar] {\n          cursor: pointer;\n          overflow: auto;\n          display: block;\n          width: 16px;\n          height: 16px;\n          -webkit-border-radius: 8px;\n          -moz-border-radius: 8px;\n          -o-border-radius: 8px;\n          border-radius: 8px;\n          background-color: #fff;\n          position: absolute;\n          right: 6px;\n          top: -2px;\n          z-index: 9999; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] {\n      float: left;\n      display: inline-block;\n      height: 32px;\n      cursor: pointer;\n      margin: 0 6px;\n      box-sizing: border-box; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] {\n        float: left;\n        bottom: 0; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] {\n          background-color: transparent;\n          border: 0;\n          box-sizing: content-box;\n          width: 32px;\n          height: 32px;\n          opacity: 1; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume]:hover {\n            color: white;\n            opacity: 1; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg {\n            height: 38px;\n            position: relative;\n            top: -3px;\n            left: -5px; }\n            .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg path {\n              fill: white; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg:hover path {\n            fill: white; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume].muted svg {\n            margin-left: 2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] {\n        float: left;\n        position: relative;\n        top: -6px;\n        padding: 3px 0;\n        -webkit-transition: width 0.2s ease-out;\n        -moz-transition: width 0.2s ease-out;\n        -ms-transition: width 0.2s ease-out;\n        -o-transition: width 0.2s ease-out;\n        transition: width 0.2s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] {\n          height: 1px;\n          position: relative;\n          top: 7px;\n          margin: 0 3px;\n          background-color: #666666; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-1[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #c2c2c2;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            -ms-transition: all 0.1s ease-out;\n            -o-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-2[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #59daf7;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            -ms-transition: all 0.1s ease-out;\n            -o-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-hover[data-volume] {\n            opacity: 0;\n            position: absolute;\n            top: -3px;\n            width: 5px;\n            height: 7px;\n            background-color: rgba(255, 255, 255, 0.5);\n            -webkit-transition: opacity 0.1s ease;\n            -moz-transition: opacity 0.1s ease;\n            -ms-transition: opacity 0.1s ease;\n            -o-transition: opacity 0.1s ease;\n            transition: opacity 0.1s ease; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] {\n          position: absolute;\n          -webkit-transform: translateX(-50%);\n          -moz-transform: translateX(-50%);\n          -ms-transform: translateX(-50%);\n          -o-transform: translateX(-50%);\n          transform: translateX(-50%);\n          top: 0px;\n          left: 0;\n          width: 20px;\n          height: 20px;\n          opacity: 1;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          -ms-transition: all 0.1s ease-out;\n          -o-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] .bar-scrubber-icon[data-volume] {\n            position: absolute;\n            left: 6px;\n            top: 6px;\n            width: 8px;\n            height: 8px;\n            border-radius: 10px;\n            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n            background-color: white; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume] {\n          float: left;\n          width: 4px;\n          padding-left: 2px;\n          height: 12px;\n          opacity: 0.5;\n          box-shadow: inset 2px 0 0 white;\n          -webkit-transition: transform 0.2s ease-out;\n          -moz-transition: transform 0.2s ease-out;\n          -ms-transition: transform 0.2s ease-out;\n          -o-transition: transform 0.2s ease-out;\n          transition: transform 0.2s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume].fill {\n            box-shadow: inset 2px 0 0 #fff;\n            opacity: 1; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:nth-of-type(1) {\n            padding-left: 0; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:hover {\n            -webkit-transform: scaleY(0.5);\n            -moz-transform: scaleY(0.5);\n            -ms-transform: scaleY(0.5);\n            -o-transform: scaleY(0.5);\n            transform: scaleY(0.5); }\n  .media-control[data-media-control].w320 .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume].volume-bar-hide {\n    width: 0;\n    height: 12px;\n    top: 100px;\n    padding: 0; }\n\n.media-control:hover .bar-background[data-seekbar] {\n  height: 6px; }\n\n.zp-button-next svg,\n.zp-button-prev svg,\n.zp-button-lyric svg,\n.zp-button-replay svg {\n  display: block;\n  width: 40%;\n  margin: 2px auto 0; }\n\n.zp-button-replay svg {\n  width: 50%;\n  margin-left: 15px;\n  margin-top: -1px; }\n\n#zm-repeat-album {\n  margin-top: 6px; }\n\n.zm-ico {\n  width: 25px;\n  height: 25px;\n  display: inline-block;\n  float: left;\n  cursor: pointer;\n  margin-right: 6px;\n  margin-left: 20px;\n  margin-top: -5px; }\n  .zm-ico svg {\n    height: 18px;\n    top: 0px;\n    left: -8px; }\n    .zm-ico svg path {\n      fill: white; }\n  .zm-ico svg:hover path {\n    fill: #fff; }\n\n.zm-icon-volume-mute {\n  background-position: 0 -350px;\n  margin: 3px 0px 0 0px; }\n\n.zm-icon-volume {\n  background-position: 0 -50px;\n  margin: 3px 0px 0 0px; }\n\n.zm-icon-volume-mute:hover {\n  background-position: 0 -375px; }\n\n.zm-volume {\n  width: 100px;\n  height: 2px;\n  background-color: #4d4d4d;\n  float: left;\n  margin: 19px 20px 0 12px;\n  position: relative;\n  cursor: pointer; }\n\n.zm-volume .zm-volume-available {\n  background: #fff;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0; }\n\n.zm-volume .zm-volume-available .zm-volume-node {\n  display: block;\n  position: absolute;\n  width: 12px;\n  height: 12px;\n  -webkit-border-radius: 6px;\n  -moz-border-radius: 6px;\n  -o-border-radius: 6px;\n  border-radius: 6px;\n  background-color: #fff;\n  margin-left: -6px;\n  margin-top: -5px;\n  cursor: pointer;\n  right: -6px; }\n\n.zm-quanlity {\n  float: right;\n  position: relative;\n  margin-top: -5px; }\n\n.zm-quanlity .zm-quanlity-display {\n  font-size: 12px;\n  font-weight: bold;\n  color: #262626;\n  padding: 2px 7px;\n  cursor: pointer;\n  display: inline-block;\n  margin-top: 9px;\n  background-color: white;\n  -webkit-border-radius: 2px;\n  -moz-border-radius: 2px;\n  -o-border-radius: 2px;\n  border-radius: 2px; }\n\n.zm-quanlity .zm-tooltip {\n  width: auto;\n  left: 50%; }\n\n.zm-quanlity:hover .zm-quanlity-display {\n  color: #721799; }\n\n.zm-tooltip {\n  position: absolute;\n  background: rgba(0, 0, 0, 0.8);\n  bottom: 27px;\n  font-size: 12px;\n  font-weight: 500;\n  color: #c3c3c3;\n  padding: 5px;\n  bottom: 35px;\n  transform: translateX(-50%);\n  -webkit-transform: translateX(-50%);\n  -moz-transform: translateX(-50%);\n  -webkit-border-radius: 4px;\n  -moz-border-radius: 4px;\n  -o-border-radius: 4px;\n  border-radius: 4px; }\n\n.zm-tooltip .zm-list-quanlity {\n  padding: 2px;\n  margin: 0;\n  list-style: none; }\n\n.zm-tooltip .zm-list-quanlity li:first-child {\n  margin-top: 0; }\n\n.zm-tooltip .zm-list-quanlity li {\n  margin-top: 8px;\n  white-space: nowrap;\n  cursor: pointer; }\n\n.zm-tooltip .zm-list-quanlity li.active {\n  color: #fff; }\n\n.zm-jump-mv {\n  float: right;\n  margin-top: 5px;\n  margin-right: 20px; }\n\n.zm-jump-mv a {\n  font-size: 13px;\n  color: #fff;\n  font-weight: bold; }\n\n.zm-jump-mv .zm-hv-tooltip {\n  margin-left: -60px;\n  padding: 4px;\n  width: 100px;\n  top: -32px; }\n\n.zm-tooltip .zm-list-quanlity li:hover {\n  color: #fff; }\n\n.zm-setting .active {\n  color: white;\n  opacity: 1;\n  transform: rotate(10deg);\n  transform-origin: 50% 50%; }\n\n.none {\n  display: none !important; }\n\n.zm-icon-next {\n  background-position: 0 -400px; }\n\n.zm-icon-prev {\n  background-position: 0 -450px; }\n\n.zm-jump-lyric {\n  cursor: pointer;\n  float: right;\n  width: 25px;\n  height: 25px;\n  margin-top: 5px;\n  margin-right: 10px; }\n  .zm-jump-lyric svg {\n    height: 19px;\n    position: relative;\n    top: 0;\n    left: -5px; }\n    .zm-jump-lyric svg path {\n      fill: #721799; }\n\n.zm-jump-lyric a:hover, .zm-jump-lyric .active {\n  background-position: 0 -945px; }\n\n.zm-jump-lyric a {\n  display: block;\n  background: url(" + __webpack_require__(63) + ") 0 -920px;\n  width: 25px;\n  height: 25px;\n  text-indent: -9999px; }\n\n.zm-jump-lyric .zm-hv-tooltip {\n  margin-left: -36px;\n  padding: 4px;\n  width: 80px;\n  top: -32px; }\n\n.fn-lrc-switch + .zm-hv-tooltip {\n  width: 68px;\n  margin-left: -20px; }\n\n.zm-hv-tooltip {\n  position: absolute;\n  z-index: 99999;\n  top: -20px;\n  padding: 5px;\n  background: #272525;\n  color: #FFF;\n  display: none;\n  text-align: center;\n  font-size: 14px;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  -o-border-radius: 3px;\n  border-radius: 3px; }\n\n.zm-rp {\n  float: right;\n  position: relative; }\n\n.zm-hv-tooltip {\n  position: absolute;\n  z-index: 99999;\n  top: -20px;\n  padding: 3px;\n  background: rgba(0, 0, 0, 0.8);\n  color: #FFF;\n  display: none;\n  text-align: center;\n  font-size: 11px; }\n\n#zm-repeat-album .zm-hv-tooltip {\n  margin-left: -30px;\n  padding: 4px;\n  width: 90px;\n  top: -38px; }\n\n#zm-repeat-song {\n  margin-top: 6px; }\n\n#zm-repeat-song .zm-hv-tooltip {\n  margin-left: -22px;\n  padding: 4px;\n  width: 90px;\n  top: -38px; }\n\n.media-control-icon[data-fullscreen] .zm-hv-tooltip {\n  margin-left: -86px;\n  width: 120px;\n  top: -34px;\n  padding: 12px; }\n\n.media-control-icon[data-expandshrink] .zm-hv-tooltip {\n  width: 70px;\n  margin-left: -18px;\n  top: -34px;\n  padding: 12px; }\n\n.drawer-icon .zm-hv-tooltip {\n  margin-left: -24px;\n  width: 70px;\n  padding: 12px;\n  top: -34px; }\n\n.zm-info-song.otr {\n  position: absolute;\n  top: 40px;\n  left: 20px;\n  right: 20px;\n  text-align: center; }\n\n.zm-hv-tooltip {\n  position: absolute;\n  z-index: 99999;\n  top: -20px;\n  padding: 3px;\n  background: rgba(0, 0, 0, 0.8);\n  color: #FFF;\n  display: none;\n  text-align: center;\n  font-size: 11px; }\n\n.zm-setting .zm-tooltip {\n  bottom: 50px;\n  right: -120px; }\n\n#zm-ad-option {\n  bottom: 50px;\n  right: -100px; }\n\n#zm-speed-option, #zm-quality-option {\n  bottom: 50px;\n  right: -70px; }\n\n.zm-tooltip .zm-setting-option li {\n  list-style: none;\n  margin: 0;\n  padding: 4px;\n  height: 30px;\n  line-height: 1.8em;\n  font-size: 14px;\n  color: #9c9c9c;\n  font-weight: 100;\n  border-radius: 2px; }\n\n.zm-setting-option {\n  padding: 0;\n  margin: 0;\n  bottom: 50px;\n  list-style: none;\n  cursor: pointer; }\n\n.zm-list-setting {\n  width: 250px; }\n\n.zm-ad-mode-setting {\n  width: 200px; }\n\n.zm-play-speed-setting {\n  width: 160px; }\n\n.zm-quality-setting {\n  width: 150px; }\n\n.zm-cc-setting {\n  width: 170px; }\n\n.zm-subcolor-setting, .zm-subsize-setting, .zm-subpos-setting {\n  width: 150px; }\n\n.zm-cc-setting .left-cap-content {\n  width: 50%; }\n\n.zm-cc-setting .right-cap-content {\n  width: 50%; }\n\n.cc-setting .active {\n  color: white;\n  opacity: 1; }\n\n.cc-setting .zm-tooltip {\n  bottom: 50px;\n  right: -80px; }\n\n.zm-setting-option li:hover {\n  color: #fff;\n  background: rgba(0, 0, 0, 0.4); }\n\n.zm-setting-option .li-config-header:hover {\n  background: transparent; }\n\n.setting-label {\n  color: #ffffff;\n  font-weight: 500; }\n\n.left-cap-content {\n  display: inline-block;\n  color: white;\n  width: 30%;\n  float: left;\n  text-align: left;\n  cursor: default; }\n\n.right-cap-content {\n  position: relative;\n  display: inline-block;\n  width: 70%;\n  float: right;\n  text-align: right;\n  font-size: 13px; }\n\n.li-config-header {\n  border-bottom: 1px solid rgba(242, 242, 242, 0.19); }\n\n.tick-icon {\n  position: absolute;\n  left: 20px;\n  font-size: 18px; }\n\n.non-linear-ad {\n  z-index: 10;\n  position: absolute;\n  bottom: 55px;\n  left: 50%;\n  transform: translateX(-50%);\n  -webkit-transform: translateX(-50%);\n  -moz-transform: translateX(-50%);\n  cursor: pointer;\n  pointer-events: auto; }\n\n.pause-ad {\n  z-index: 10;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  cursor: pointer;\n  pointer-events: auto; }\n\n.zm-endscreen-content {\n  position: absolute;\n  left: 50%;\n  top: 50%; }\n\n.zm-videowall-still {\n  position: absolute;\n  display: block;\n  cursor: pointer;\n  vertical-align: top;\n  overflow: hidden;\n  pointer-events: all; }\n\n.zm-videowall-still-image {\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: cover;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  position: absolute; }\n\n.zm-videowall-still-info-content {\n  background-image: linear-gradient(to bottom, rgba(12, 12, 12, 0.8) 0, transparent 100px);\n  -moz-transition: opacity 0.3s ease;\n  -o-transition: opacity 0.3s ease;\n  -webkit-transition: opacity 0.3s ease;\n  transition: opacity 0.3s ease;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  padding: 10px;\n  opacity: 0; }\n\n.zm-videowall-still:focus .zm-videowall-still-info-content,\n.zm-videowall-still:hover .zm-videowall-still-info-content {\n  opacity: 1; }\n\n.zm-videowall-still-info-duration {\n  background: #000;\n  border-radius: 2px;\n  bottom: 2px;\n  right: 2px;\n  font-weight: 500;\n  line-height: 1;\n  opacity: .75;\n  padding: 2px;\n  position: absolute; }\n\n.zm-videowall-still-info-title {\n  display: block;\n  font-size: 13px;\n  font-weight: bold;\n  line-height: 1.2;\n  max-height: 32px;\n  overflow: hidden; }\n\n.zm-videowall-still-info-description {\n  margin-top: 2px;\n  font-size: 11px;\n  font-weight: 300; }\n\n.ad-detail-text {\n  position: absolute;\n  width: 200px;\n  line-height: 2.4em;\n  visibility: hidden;\n  left: 50%;\n  top: 50%;\n  color: #FFF;\n  background-color: rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  margin: -18px 0 0 -100px;\n  border-radius: 8px;\n  font-weight: 200;\n  font-size: 130%;\n  text-align: center;\n  vertical-align: middle;\n  pointer-events: auto; }\n\n.ad-detail-text:hover {\n  background-color: #6cd936; }\n\n.pause-ad:hover .ad-detail-text {\n  visibility: visible; }\n\n.close-ad {\n  position: absolute;\n  z-index: 999;\n  right: -8px;\n  background-position: 0 -895px;\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAOYCAYAAAAg7ViDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFOENCRUQxOEFEM0ZFNDExODYzOURGMkI1Qjk2OTdBMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3ODUwQkU5OTk2RTcxMUU0OEEwQ0FDNDdGNDY5NjBDNCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3ODUwQkU5ODk2RTcxMUU0OEEwQ0FDNDdGNDY5NjBDNCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3NTYxOUE0RTI5NkU0MTFBNzlERUEzNEJDM0I2MTg2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU4Q0JFRDE4QUQzRkU0MTE4NjM5REYyQjVCOTY5N0EzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+lnFr3QAAGVhJREFUeNrsXQm4FcWVrvt4gCyyyPKJAtFPGQ1BIy4EUJggoqho3A2LCUjkuaAyOupoCDxEUFGjjnFFtizghhCDLCKCjsoyZFQEXNAoqIDwWGXf7pzfPvWo11R3V3dX83hQ9X3/d/v2ra7/1n7qdJ06uXw+L7IOBWI/hHIjeZ1wvFUW1IkPCNsJDxBqan6PjSASGZYTehByWZLIMJtwatYkCLsJzxPqZ0kiwzpCP0JhliQyLCJ0zJpEhlcJx2RNgrCFMJhQLUsSGZYSrvanaXtY+YHwvWmPjxvQ4m4NanFpSdB3RhAaZlXxcwmts2rCqwnXEgqy6Iw7Cf9NqJPVsDKTcFJWA+QyQtes5hNMWkOynLReJxxvI3GJnBOJ4oRC9cuECz+3lvClr//bQSjc6UguICwiPEComWXFVyHcRUAl9SDksmxdjQh/IbxPODXrJtya8L+E5wn1s+wniNubsITQz9/8bXfGOoRHCR8ROmbd45sT3iS8Sjgm62HlUsJiwmBCtSzHLiTen/Ap4eqsB0itcGeLZD23uFMIs0JH4QRhD2E04W7CKqOhPmaYR7iVMCeLJlzCnbKNCUFckl2EJwjNCCO5qOLPjCEBlXkL4eMsBshvCN0IHZIShOVkB+Fhwv2ETVYFCQ6TudV8kYm0wuFC24KEkyAdyYFD0oJFo/FhLZbHtg5hGgkdsJy+jbBVWU8GxYVWYgZhhVTAmRA0IbypWRH749Ug3MXXDXm9/6wJCVa+awOW3f64nfn+Nfz9Vl7gHikj9CVs0iQSFuSzjQm1+fopwkrWe1UllBBulxF3BCRiQoIimczXR7CCTa79RxGmytZVOUULHUPoTGhLWEt4g/BLRQ5oYaOfYFmxkNCev2NN05ivvyM0tNUZt6M3aPoe+kzeBsnRhJMIM/n7iTxty9++lyS7U5BAwJjG5V+PcI5C2PpH2YBbwZ0pmnA9QnW+fprwHTfhatzH/iOqM3YjbDDsjFcS9hAuV/54mc4YBmiv3zUggUbvZr5uxLn4k+nYBVQi9GcVYdQAWYUwh9+9HBGHRKIVYYnSw4PwGOGXTt/lSA4WHaRNvePBL9wVxPgztzHB6YTLQuJWIvyEMFYq4ExImrBw8AjhsJB4NVhviaV4V17FDTEh6RpDedaONbDXsArkPkJPwpGSpC+vcvMKBGe5bkTikExqE6YSniY8xKqpZ1hr1F2S/JGzmyT8gTCOr6HzqkW4hCWYfxA6OeHuEBXuJMk9hM0JSYZxfxLcN9YQXuNm3AW64wIlYk0uQwmE7oSNESRIdAvhSkIR52wr4WbuFuOi6gSd8eeE9wxyNJ21Sxg88bbivwjDCStNKv5rwr9zp9sVobaF+hDvXiYQthEGxBmFd3N5n8l6sCkhcXewArQbd87YKtt5rOiMCv2cvsuROJLyJRmovWtzLwQvWAeabMRozrvQ0oSBUVuvIN40T1lsuajikuGchMVVHGcHTpI6KY67zSdNAxiYNclA//PG5RqzXiJJii30lUgSbblmQTIwYb10NCUZmE8fFkb1+FzK3r6ApcnIAbLYQl8pRZDcVWxz/HdylyOp6Jo7eZGFBk/uIDx4hDvbJMU6Ih0JZK5FPt2XKbRE+0W405GczJ+dfBoKEyAM8o/iYXXyZoIcDNJNE1lUvDCpExvN2Ki4BlnITSjJINvTb4FpuWYxrAxMmJuOoaNwAEFSKWNRVE6sC3eFEXWSs1En+0W4K4jT3p0E6UgcSaRgcLjm/uEmo0KBIQE2688mNFDuN+B7j0USGSwsa/OSWS6dGzDUe7XjmlDp4E9UvW6YxE7LhMiYwIZlptnAZ6G4GtgoLlTqxzErfmBcEkwHj2v+tSR63GcQvo+GyXQ+QT/AK8IfNJ1xk69u8n5ZIYtJax+Sgth690S0TnPnNHdujnckTnOXSnN34At3JhsxsF8LW3d+JrztO3LD3ky+J+NsSEOygROeqRAJvsZ6/ewwAlMShNU+IqEQrMq6Cedt9pMGSi4WMWTRNbBBgp2BbykEHRgqUe0wIcSEZCOTSILVSh3h3gxRdnvWPhqmQsNy76cR7kDURiPcFSdtXXmN9CgC7sWqE6e5c5o7p7lzIpEjcSQ+SbJPWi2RiZIHYZjuoCpdj8eU+ifhHRQSp0SOkbK78OwdNofl5D0LyoLfRC2xpfT+Z+FtlzYZ3CBkzOLrwfxsaJ0s4H9zVoI6eVyxbQzVrYBksbTgi0Eyiq2Y3zYheRGGjoRmbPVX3dAUsSoT5E1IjvNVPiwzfxejyCJJ0Mbn+yLm2awzavNlnSASf+v6BeE0RRzKKRLM9cJ7R9+MV1b+8CtTQeLIiOUDrDL+GbBIlWFPFMkHwrMGqOTLBXL1ofCsM6RUrwuwDphsMnYN1fTg79lE3drBbRjPbiDMI3xOGBN1qKQ7uM2ROBKnHrS/sS9UuCuwWOzPCs88rsBkYZpUuEO4Q3jnFpYR7nQkOL7p1DRVQbhclb2yEO7u8wt3YVoiWPDNN/z3UqmGP3W/acV/Iryz6+IEWM3ibLUpJiSfsJYUQkMrQnUDAijWinh+b29CAlNQGD6id84lrCD8LoIEwsdhOgIdCb6/KDxDYbmBEjLWc8LTcodqN0zlLifchQp3fpKvefy529cJoY+HSfq3POSkVqr9Xnhmzr14/JrNWrxvbWrukIOnGU6p5kgciSPRh8d4YM1McycUzwjV0hwlf6YS59yQeHP82+TikPxd0Qh9FKG5eyPJxr7ZrMRpzqfuI0wL+HNzTXKiw1WcwNV80tguwskakgmmmrugQwvxzwdxYiMCjtOqlFYj0YxlAASsbpZn0U9wiA6O0cBWhn6a3+9Iq+E+iesBR5jdzUXWzhcHDaN7mm2jUznh3ux2QXpI0PkeODtNZ1zAFVuL8G1IvPV+9wxxSM5T4lwa0RlnJd1la2pUPCdpZ7Q+QCaFlc7opl9Hcqgp1aRi7eAR7myS4Jyol4XGWUFBwMJUhzOVOOcKvaUsFGrY79UwaU7u5M9KvKYPClCd/DWKRGcFiwOmLhKeqe5vhWdR+4bY11IWAedJ9UiSk0c5IZydNphVIzrpZKLwdrCtSkLyKv9z5OQo1tIt8MV5nHCF8E4li9RI6AIOB+vLwh1UsX/QxOlXrsKdKQnqoierCrdwgu18cR4U3kFviUke4qaLYmrE9+7VtMqRrCQ10hLpArwhjOYiw8mWv9TErcKNpJ1QvCfEqZM7uOliY+XNEYroJ6JyYrIFboImnswV1LxXZTlpTUjTGU0COiN2DW5N2hlNQj+nHnQk5SjcGY5huQRxXJ04EkfiSByJI3EkB9YcbyLd5w7x4rKh91L9yjrhzvV4R+JIHIkjcSSO5MAX7pwO0pEYBRPPYBpZ1L7b10TbfEzdviYmieP2NdLiDK/34Dqshq835w17O94SYV/9YF8c+AnaasPtq3rm1wDl3gDpdyNsk1IcEj/RANWxh00S/ylmA20dCxi2Osv7+4mNnKhFVKaOZIRdKUkGaJyrlBLJJnwnN7ekTfhObsL+V7UD1SZsw+1rqmHF1O1r6pMt47h9FWm3w5m6fXXb4RyJI4kr1R+IvmUTCXeFMf4M9kAM4SH9dNskcPs6Sph5ZU1UXHHcvkaSpHH7KoU73Z4vzLZ32HD7ilCdp94BPgI4Pagu66RyylY6yPcpr4vxaXMHjp+oWF7vF+HOZk4GiLKOJ2SO7pUk0uTTBoG/Xkpzco9GuIsTtrEgd6+mjrblXr3gs7CH4YsUFpq1kqo8TCo+jtvXVKPw18LM7WvqoT6O29fEQ70Mpm5fnSrKkTgSR1KeJHlhdoAIjj/5R1JFZ9SaHSZsgwlbwuKlIbmMsNRES5GE5Kds12usb4lDUpPwEFtf5rMg6cb2pfkEKkPjJoxDK6oklyvNi6s+4UnC7qyKS73XkvBO1iTycLeumnqy3k9ki7tfaXGZkEgcT3jdKdUciSNxJOW9syCpbtK/B/LgEu7SKnCqscrkdqGx97VBAnNDWGk2tb2OR/ip8OzkOmXRhHEqHyw0P4xDECcn0BbhTMJGWXbGVMKdKclThBP5c0+Ww0oJ4Sbh6en/J+ux6wPWf6GeVmQ5QGIUgENoDFTYW7Ejy1EY+n2ciQdnK5OTNmFTZSa0eRc6pZojcSSO5FAimcSCm8nQn0+jW9nOZ9jXTLreN1UW5PlgsK4+x6jWSWR4m5U4mZLkeeMS1FL1siSRYTW7ArCiuQsKO0VZ/2apNHf+gBb3sNLirBfXdD5NMZOKh6L5iqz6yTbCfREuSlKRTGKtXCoNn5O7HIkjcSROPZhQPWhFuIsiwbIZrimHsioqszqpwgqBT4W3mzCXZcUfLbwNTLMILbNuXfDdgO0+TwrPcUFmTRit8kYuwhuy7idGwl1SEqieHmFV1N9sKTrVAC8VOGBycRYVv0x4Z6Z1EjHdlpiQbBfePmEonV+xOnZxeF14m5G/yGSA5NDFMJ1cuQ/1Tkx1JI6kgpM0Jnwl9EcEb7NF8i0P+d9pfqtqe1jBybD/pxloc7bqBAn9p9HsmvDYeJTAMz61yFZTP6ameMRHgB2EHQibbZHUZ0edMjyq/HY+q6lSkVzJihx4OyghPKdRfF5uSnK25t5N7CACtoxVWLFTKY3R5CZCG+X7b5lAhjtsWGZKJxAtuYhUk92pnBMrJHku9+0+pxDV85acpepu4tzg8wgbbEkrec33U8S+Z29bHYUxhIzn1VamQ/3xLNE3tCWm5tz060gqoCrKpuWsqpJywl0s4S5NcWHZfb4wMHXbL8JdQQoCmCD+Rrm3zTYJdq0VKd9hvHeB0DiOSEpSX5T1pQG/JzBDhLeQK4Rmh1Rckiv538I76xrhedK9TfkdJojdTEnO1tzDLrUXWVMEm9HWrBr0ywPjTUleE56bZBngjuQJrvDzWamGJrw7zfRbg7Pegef2EcqUPE14my2tqKLgBGK68PzISpvgt4W3XXSHTX1XPZ9w96ugZmqjM6Jy+ySRHp1wd2DO8U4H6UgOYZJjfd/PEp4XqsNsqaKAfxEa8/UvWLkg3Sdac52I8DnhQoVgF9ueWiVRAwh+bePUqzCSW7LaRKaGa3jKzrQJn87Cx+Fx5/io2TJ1P7mGlwW6hU68EFG5vX0au9jnqZns74K89T6hVZrpuSCizJ/VEAibxfWoUjxQKv8taXEF/TDIt+exI+t/n0xCEtSEZVvfyWuSGfy9r64fJJVW5JoQAvY4TWPYbYPETb+OxJHsB/WgqiLcL8JdGpIZrCZEgBfWSbwEH2tbTH1LeFvmprGkgjHtrzYFCYRmnAPBBFBRvZpl64JK6oWsm7AT7uwId2EkfxGexjT11BlVJ6OFd1xmZiTWhLswEpwR2Zuvt+iGi7SqKBzpJ52fQt94MQ8h64W3k9MKiVXhLogElvvVWbh7zaeL7GWLBIldH/DbbttN2GnuHIkj2dsZs2zHuXKx2rD5IiDvWpcjcSSOZD+NXfkKn5Ocq3hHUkGb8IHoocIJd064cySOxJE44e7gFu6cUs2ROBIn3DnhziIJXt6Mildw8Y7xhwuMjw3jlqYZh6SnYtcbJ+yfOolbXC0IC7MsLgkYso6KQyKn33yGnTHnhLtDVLhzc7wjybAJO82dE+6ccGedBKeRwa6xZ1YkSHi+8Pwwy4oNw4FbJ6OFtwd1kdLcw5A4JwuFtz1udNatC1vjeh0U/cQJd05z50gcSUUjwVlRGxmdbZEcJbzjNOTBCNicfDjjIr5XieMcZTpAquEY4R2M20B4Rwl8IrxjNWTA9VoWLi4nrCacQVgapFvRoVcCjVCvuNaycEIwV0lgDaGIcASjiO/JMDfIVUaUEqZYOZHsBM3vJ/BveY4by9SwPeEBwkpOoI/iw3QxQ7rCKOI4K/iZ9qYk63xlLd1dfKLcW8L36vrirjM1Lq5s0Px3mT4bRAKzG9gxruPvl/MnDmz5lJuzPLzlKv5cx8/0iNOEBbu6MK34h5LYYlfhjoaA00pgmgtTkbqMIr4nTzI5UQR5dAvJRY8EnbFH3Jx8KPaerQLvbPcL73AdGdbwvXcV8fXDuDkBTiHcSKjB359U/vWTfK8Gx/l5Ul8bfnQmbGR0tmWL7aZfR1KRVlqH1Dl3h7hwF0bSgQnU6VcNODOqv/Idcc/W6cLCiutlzokM+NfX80xYj6/XKr/P42di1Qn8YU5RJqi2wrNvXMt4lu/JiWwKP2NMAi8UD4i99nNwt4sT4eD+YjGjJd/7Pccp4mfah67jlc4I8aaOEq8+/+NPWGBAwOlwzVioUIsNNo91TTpjxRPugkgmciIj+TucrJwgPJev6BfN+Rr3hnCcEfzMxDity5pwF0ZyFQ8XMhxBeEZpws/wPRm6KEVnTGJNuCuM0JyeyR1uDGGz8EzTpUnui9x/cE4hDkB8j5+JRSJzo/47ONi+RrkWTP5UHB1kVJhKqOU0d47EkVR0WXhtk2bWEz/imyXlJNXLVbeltHNGdSKzq/uOaxWZVTzqUdZlGJGVOolqNIWmLcR2xQf+y6SEBTb7g63pNzDxsHopnX6VSNb6ifwThWGdyFZwgoQjcSSOZD+RTOFltJ0QsjVaum+vn+JQXSNnRPJF2O1xvRzFJVHfxl2h8TpllUSG2YTWWZPk+XzbsYSmWZLIsIU9stfMkkSG5YRrCQVZksjwxyxJ0PIuzaq4jPpQUpJYo0ESkimE5ln2+M4VcuzKfBSOXe7utawjKWctkQw23pr6HdUfPMJdEAleuX4kPPft9bOseOm+HYtxHKdZJcvWhbd08J+FXehXJFnnx3XhgzeieMXUOut+0pqJcFhr0yw7I4qsq/BeB8L1WM0se3w14b2WRQ++Nig9W52xkfDeMz6cJQneA8PP1m3WlWrCe5mMOoFrsh22NXd4ufwcYSChJLWiUxOm8giw2Jo21VfuNzOJ9R6PcodjwZ8lIYjKSaxyT0ISu9yTkJzvtKmOxJE4Ek+jKGK+yHF1UnFJhmsqXH4fnlT57Af0Ku9rlDrvm+hc4qgvjiJ859M7HpVGtxKENuz6CmibpW7lOqWeUk+/cY9HCYxfbhsxgv5hBVN7+JZsbuxyJI7E6SCdcOdIDhjhzpTkJsJszf3Z/JsVEijMoBNertxbwfd22KyT5UqiOtJU0oq/ePry9fs2BIkgYW24E+4qvnDnlGqHKEnutNNOs5rg/Pnzy7+4YK10ju/3c/i+SBBPSzJMeAdNSdtRfMJ06iHfM6bxtD3+n8KzhsV7306ESwjnir1HacWNF1gniNiRcAp/Bj1oGi9w7MK73vYG9Wka7yDyalj44IMPGkW86667KvbYNZjwmEE6ofHCSNBy7hZ7TaUTxwsigQ3pnwnfiHC/pUbx1H4CS1cYQP5deCbQcOLcjrDB94xpPC3JDcI7KA+vvOEgdUCAkG0aT1tcGIM+40RguDo04BnTeFqSNTwO4V/BjjTIKappvMCxC9b6bQ2arGm8/Tis/MiUy4X9jvaPrT7YJFNNKeI9hG3CM/Qu4dzpLc1lTvZRfQvRpE2bNl2mTp06vKSk5LOdO3du2Wfv6M6dW1evXv3ZtGnTnm/fvj1OZmgqS0dJZ18S4dm3txwxYsT9P/zww/LSHZfr1n39xRdfvEPSyAQA17gnf9+0adOK0aNHY7SF+FM5kATFU61atbazZ89+oXSv6JIlM4cNG9a/RYsWV/N8Xgrcw2+II+PPmTPnZaQhicqQsBR/KhG8iMjbtm1bO2rUqAf8CQcBcfGMJEJapSsDhaTxyJEjcWpVfvv27euHDBlytymBBJ4hovVIY8yYMZBqmqgklc8666yLqFy/37Nnzy6QxSWQwLNIY/PmzavbtWsHp/WVZXOsd88993SpUaNGwy+//PK96667rszKtnr16gUtW7bcZ1MSibiH4zf1Hp5FGnS/fv/+/dHi6ssIDc444wwc7pUfP378tN27d+8tw8aNq8ybN++Gt956a2jPnj2Plvd79+7dZMaMGUPpt6JGjRqV7mLDs0gDe+/pT2B0biiLq92uXbu2rl+//utjjz32SjX7rVq16kb3l+IPbNiwYdkll1zS+7LLLutNzftbbtpfUS67qs8gDaRFhNt/nNSYpBMeoGy+oytnKoIbQYA4eJhQet2rV68bdM8gLe/YfXFeoToa00NrtCqi4cO/oTBg3LhxxXXq1PkJx/2KclQ8c+bMdbpnKIcyrQJjaaWwsDCXKzvI5apWrWr0vDrYCfqX9XSR+vTp03Ts2LGDa9eu3RRFREW3lOIe88ILL9yLBqCd/OvWrVeatknFK/WxtEuXLr1Q+Rs3bvxG1ktUxcucrMdgV6tWraZFRUVlTCyXL1++nepjIf3+r759+w6dNGlSycSJE1fdcsstQ1Avy5YtW7hy5coyOi+kQWk1oWeW/ihgcE6OnDx58rM8IL5dqVKli9V/RmV/sW6APPnkk3+N39R7eBZpIK3p06dD2Ggkc7Jm6NChk2goWHXcccedSa2pzNRKY1l+4cKFW/zlvmDBgs34zdcS2yKNLVu2lNBYhrMmSiTJznffffeDl156aRQ1oErdu3e/niK0iDvN4plu3bpdjzReeeWVUbNmzcKqbGcmQ/3cuXNf5skrl8mkBYLAScs3/Z6KITvu9MtzCHJQJXSODxEktuoECfwWJUj8eMNQJIIEf5hGJFrPItGqIJHo/wUYAKq+qnWgnbfeAAAAAElFTkSuQmCC\");\n  top: -8px;\n  width: 25px;\n  height: 25px;\n  cursor: pointer;\n  border-radius: 5px;\n  text-align: center;\n  color: #FFF;\n  font-size: 180%; }\n\n.zm-ad-tooltip {\n  visibility: hidden;\n  width: 280px;\n  text-align: left !important;\n  position: absolute;\n  bottom: -95%;\n  left: -350px;\n  padding: 6px;\n  overflow: visible;\n  border-radius: 5px;\n  background-color: black;\n  color: #ffffff;\n  z-index: 1; }\n\n.zm-ad-tooltip::after {\n  content: \" \";\n  position: absolute;\n  top: 50%;\n  left: 100%;\n  /* To the right of the tooltip */\n  margin-top: -5px;\n  border-width: 5px;\n  border-style: solid;\n  border-color: transparent transparent transparent black; }\n\n.right-cap-content:hover .zm-ad-tooltip {\n  visibility: visible; }\n\n/* The switch - the box around the slider */\n.switch {\n  position: relative;\n  display: inline-block;\n  width: 38px;\n  height: 16px; }\n\n/* Hide default HTML checkbox */\n.switch input {\n  display: none; }\n\n/* The slider */\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  -webkit-transition: .3s;\n  transition: .3s; }\n\n.slider:before {\n  position: absolute;\n  content: \"\";\n  height: 20px;\n  width: 20px;\n  left: 2px;\n  bottom: -2px;\n  background-color: white;\n  -webkit-transition: .3s;\n  transition: .3s; }\n\ninput:checked + .slider {\n  background-color: #fff; }\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #fff; }\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(15px);\n  -ms-transform: translateX(15px);\n  transform: translateX(15px); }\n\n/* Rounded sliders */\n.slider.round {\n  border-radius: 20px; }\n\n.slider.round:before {\n  border-radius: 50%; }\n\n.notification-message {\n  position: absolute;\n  width: 100%;\n  line-height: 2.4em;\n  visibility: hidden;\n  left: 50%;\n  top: 50%;\n  color: #FFF;\n  background-color: rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  margin: -18px 0 0 -100px;\n  border-radius: 8px;\n  font-weight: 200;\n  font-size: 130%;\n  text-align: center;\n  vertical-align: middle;\n  pointer-events: auto;\n  visibility: visible; }\n", ""]);

	// exports


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a8c874b93b3d848f39a71260c57e3863.cur";

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "edb6aea2388fb6d450c7ae3d87f5ff3c.png";

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "<!--Non Linear Ad-->\n<div class=\"non-linear-ad none\">\n    <img id=\"non-linear-ad-image\"/>\n    <div id=\"close-non-linear-ad\" class=\"close-ad\"></div>\n</div>\n\n<!--Pause Ad-->\n<div class=\"pause-ad none\">\n    <img id=\"pause-ad-image\"/>\n    <div class=\"ad-detail-text\">Xem thông tin chi tiết</div>\n    <div id=\"close-pause-ad\" class=\"close-ad\"></div>\n</div>\n\n<!--Suggestion-->\n<% if (options.suggestions && options.suggestions.length > 0) { %>\n<div class=\"zm-endscreen-content none\"\n     style=\"width: 82%; height: 82%; margin-left: -40.5%; margin-top: -26.5%;\">\n    <% var numberOfSuggestion = options.suggestions.length > 9 ? 9 : options.suggestions.length;\n    for (var i = 0; i < numberOfSuggestion; i++) {\n    var suggestion = options.suggestions[i];\n    var left = (i % 3) * 33 + '%';\n    var top = Math.floor(i / 3) * 33 + '%';\n    %>\n    <a class=\"zm-videowall-still\" aria-label=\"<%= suggestion.title %>\" href=\"<%= suggestion.link %>\" style=\"width: 33%; height: 33%; left: <%= left %>; top: <%= top %>;\">\n        <div class=\"zm-videowall-still-image\" style=\"background-image: url(&quot;<%= suggestion.thumbnail %>&quot;);\"></div>\n        <div class=\"zm-videowall-still-info\">\n        <span class=\"zm-videowall-still-info-content\" style=\"will-change: opacity;\">\n            <span class=\"zm-videowall-still-info-title\"><%= suggestion.title %></span>\n            <span class=\"zm-videowall-still-info-description\"><%= suggestion.performer %></span>\n        </span>\n        </div>\n    </a>\n    <% } %>\n</div>\n<% } %>\n\n<!--Media Control-->\n<div class=\"media-control-background\" data-background></div>\n<div class=\"media-control-layer\" data-controls>\n    <%  var renderBar = function(name) { %>\n    <div class=\"bar-container\" data-<%= name %>>\n    <div class=\"bar-background\" data-<%= name %>>\n    <div id=\"ad-marks-container\">\n    </div>\n    <div class=\"bar-fill-1\" data-<%= name %>>\n</div>\n<div class=\"bar-fill-2\" data-<%= name %>></div>\n<div class=\"bar-hover\" data-<%= name %>></div>\n<div class=\"bar-scrubber\" data-<%= name %>>\n<div class=\"bar-scrubber-icon\" data-<%= name %>></div>\n</div>\n</div>\n<%  }; %>\n<%  var renderSegmentedBar = function(name, segments) {\nsegments = segments || 10; %>\n<div class=\"bar-container\" data-<%= name %>>\n<div class=\"zm-volume\">\n    <div class=\"zm-volume-available\" style=\"width:70%\"><span class=\"zm-volume-node\"></span></div>\n</div>\n</div>\n<% }; %>\n\n<% var renderDrawer = function(name, renderContent) { %>\n<div class=\"drawer-container\" data-<%= name %>>\n<div class=\"drawer-icon-container\" data-<%= name %>>\n<div class=\"drawer-icon media-control-icon\" data-<%= name %>>\n<span class=\"zm-hv-tooltip\"></span>\n</div>\n<span class=\"drawer-text\" data-<%= name %>></span>\n</div>\n<% renderContent(name); %>\n</div>\n<% }; %>\n<% var renderIndicator = function(name) { %>\n<div class=\"media-control-indicator\" data-<%= name %>></div>\n<% }; %>\n\n<% var renderSetting = function(name) { %>\n<span class=\"zm-setting\">\n        <button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %>></button>\n    <div id=\"setting-options\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-list-setting text-config-configs\">\n                <li>\n                    <span>\n                        <div id=\"li-config-ad\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Quảng cáo</span></div>\n                            <div class=\"right-cap-content\"><span id=\"ad-mode\"><%= currentAdMode %></span></div>\n                        </div>\n                    </span>\n                </li>\n\n                <li>\n                    <span>\n                        <div id=\"li-config-speed\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Tốc độ</span></div>\n                            <div class=\"right-cap-content\"><span id=\"speed\"><%= currentSpeed %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <% if (levels && levels.length > 0) { %>\n                    <li>\n                        <span>\n                            <div id=\"li-config-quality\">\n                                <div class=\"left-cap-content\"><span class=\"setting-label\">Chất lượng</span></div>\n                                <div class=\"right-cap-content\"><span id=\"quality\"><%=levels[currentLevel].label %></span></div>\n                            </div>\n                        </span>\n                    </li>\n                <% } %>\n            </ul>\n        </div>\n\n    <!--Ad mode setting-->\n        <div id=\"zm-ad-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-ad-mode-setting\">\n                    <li class=\"li-config-header\">\n                        <span>\n                            <div>\n                                <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                                <div class=\"right-cap-content setting-label\"><span>Quảng cáo</span></div>\n                            </div>\n                        </span>\n                    </li>\n                    <%adModes.forEach(function(adMode, index) {%>\n                    <li>\n                        <span>\n                            <div>\n                                <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (adMode == currentAdMode) ? '✓&nbsp;' : '' %></span></div>\n                                <div class=\"right-cap-content\">\n                                    <span id=\"ad-mode-content\"><%= adMode %></span>\n                                    <% if (index > 0) { %>\n                                    <span class=\"zm-ad-tooltip\"><%= adTooltips[index] %></span>\n                                    <% } %>\n                                </div>\n                            </div>\n                        </span>\n                    </li>\n                    <%})%>\n\n                </ul>\n        </div>\n\n    <!--Play speed setting-->\n        <div id=\"zm-speed-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-play-speed-setting\">\n                <li class=\"li-config-header\">\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                            <div class=\"right-cap-content setting-label\"><span>Tốc độ</span></div>\n                        </div>\n                    </span>\n                </li>\n                <%playSpeeds.forEach(function(speed) {%>\n                <li>\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (speed == currentSpeed) ? '✓' : '' %></span></div>\n                            <div class=\"right-cap-content\"><span> <%= speed %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <%})%>\n\n            </ul>\n        </div>\n\n    <!--Quality setting-->\n        <% if (levels && levels.length > 0) { %>\n        <div id=\"zm-quality-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-quality-setting\">\n                <li class=\"li-config-header\">\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                            <div class=\"right-cap-content setting-label\"><span>Chất lượng</span></div>\n                        </div>\n                    </span>\n                </li>\n                <% for (var i = levels.length - 1; i >= 0; i--) { %>\n                <li>\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (i == currentLevel) ? '✓&nbsp;' : '' %></span></div>\n                            <div class=\"right-cap-content\"><span><%=levels[i].label %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <% } %>\n            </ul>\n        </div>\n        <% } %>\n    </span>\n<% }; %>\n\n<% var renderSubTitleSetting = function(name) { %>\n<span class=\"cc-setting\">\n        <button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %>></button>\n    <!--SubTitle Setting Option-->\n        <div id=\"subtitle-options\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-cc-setting text-config-configs\">\n                <li>\n                    <span>\n                        <div id=\"li-config-sub\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Phụ đề</span></div>\n                            <div class=\"right-cap-content\">\n                                <label class=\"switch\">\n                                    <input id=\"sub-switcher\"\n                                           type=\"checkbox\"\n                                           value=\"<%= isSubOn ? 'true' : 'false' %>\" <%= isSubOn ? 'checked' : '' %>>\n                                    <div class=\"slider round\"></div>\n                                </label>\n                            </div>\n                        </div>\n                    </span>\n                </li>\n                <li>\n                    <span>\n                        <div id=\"li-config-bg\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Khung nền</span></div>\n                            <div class=\"right-cap-content\">\n                                <label class=\"switch\">\n                                    <input id=\"sub-bg-switcher\"\n                                           type=\"checkbox\"\n                                           value=\"<%= isSubBackgroundOn ? 'true' : 'false' %>\" <%= isSubBackgroundOn ? 'checked' : '' %>>\n                                    <div class=\"slider round\"></div>\n                                </label>\n                            </div>\n                        </div>\n                    </span>\n                </li>\n                <li>\n                    <span>\n                        <div id=\"li-config-sub-color\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Màu chữ</span></div>\n                            <div class=\"right-cap-content\"><span id=\"sub-color\"><%= currentSubColor %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <li>\n                    <span>\n                        <div id=\"li-config-sub-size\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Cỡ chữ</span></div>\n                            <div class=\"right-cap-content\"><span id=\"sub-size\"><%= currentSubSize %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <li>\n                    <span>\n                        <div id=\"li-config-sub-pos\">\n                            <div class=\"left-cap-content\"><span class=\"setting-label\">Vị trí</span></div>\n                            <div class=\"right-cap-content\"><span id=\"sub-pos\"> <%= currentSubPos %> </span></div>\n                        </div>\n                    </span>\n                </li>\n            </ul>\n        </div>\n\n    <!--SubTittle Color Setting-->\n        <div id=\"zm-subcolor-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-subcolor-setting\">\n                <li class=\"li-config-header\">\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                            <div class=\"right-cap-content setting-label\"><span>Màu chữ</span></div>\n                        </div>\n                    </span>\n                </li>\n                <%subColors.forEach(function(color) {%>\n                <li>\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (color == currentSubColor) ? '✓' : '' %></span></div>\n                            <div class=\"right-cap-content\"><span> <%= color %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <%})%>\n\n            </ul>\n        </div>\n\n    <!--SubTittle Size Setting-->\n        <div id=\"zm-subsize-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-subsize-setting\">\n                <li class=\"li-config-header\">\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                            <div class=\"right-cap-content setting-label\"><span>Cỡ chữ</span></div>\n                        </div>\n                    </span>\n                </li>\n                <%subSizes.forEach(function(size) {%>\n                <li>\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (size == currentSubSize) ? '✓' : '' %></span></div>\n                            <div class=\"right-cap-content\"><span> <%= size %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <%})%>\n\n            </ul>\n        </div>\n\n    <!--SutTittle Position Setting-->\n        <div id=\"zm-subpos-option\" class=\"zm-tooltip none\">\n            <ul class=\"zm-setting-option zm-subpos-setting\">\n                <li class=\"li-config-header\">\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label\"></span></div>\n                            <div class=\"right-cap-content setting-label\"><span>Vị trí</span></div>\n                        </div>\n                    </span>\n                </li>\n                <%subPositions.forEach(function(pos) {%>\n                <li>\n                    <span>\n                        <div>\n                            <div class=\"left-cap-content\"><span class=\"setting-label tick-icon\"><%= (pos == currentSubPos) ? '✓' : '' %></span></div>\n                            <div class=\"right-cap-content\"><span> <%= pos %></span></div>\n                        </div>\n                    </span>\n                </li>\n                <%})%>\n\n            </ul>\n        </div>\n    </span>\n<% }; %>\n\n<% var renderButton = function(name) {\nif (name === \"setting\") {\nrenderSetting(name);\n} else if (name === 'cc') {\nrenderSubTitleSetting(name);\n} else {%>\n<button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %>>\n<span class=\"zm-hv-tooltip\"></span>\n</button>\n<% }\n}; %>\n\n<%  var templates = {\nbar: renderBar,\nsegmentedBar: renderSegmentedBar,\n};\nvar render = function(settingsList) {\nsettingsList.forEach(function(setting) {\nif(setting === \"seekbar\") {\nrenderBar(setting);\n} else if (setting === \"volume\") {\nrenderDrawer(setting, settings.volumeBarTemplate ? templates[settings.volumeBarTemplate] : function(name) { return renderSegmentedBar(name); });\n} else if (setting === \"duration\" || setting === \"position\") {\nrenderIndicator(setting);\n} else {\nrenderButton(setting);\n}\n});\n}; %>\n<% if (settings.default && settings.default.length) { %>\n<div class=\"media-control-center-panel\" data-media-control>\n    <% render(settings.default); %>\n</div>\n<% } %>\n<% if (settings.left && settings.left.length) { %>\n<div class=\"media-control-left-panel\" data-media-control>\n    <% render(settings.left); %>\n</div>\n<% } %>\n<% if (settings.right) { %>\n<div class=\"media-control-right-panel\" data-media-control>\n    <% render(settings.right); %>\n\n    <% if ((options.playerType == 'song' && options.mimeType == 'audio/mp3') || options.showRepeatSongButton) { %>\n    <span id=\"zm-repeat-song\" class=\"zm-ico zm-rp zm-icon-repeat fn-repeat\">\n        <span style=\"width: 60px !important;\" class=\"zm-hv-tooltip\"></span>\n    </span>\n    <% } %>\n    <% if (options.playerType == 'album') { %>\n    <span id=\"zm-repeat-album\" class=\"zm-ico zm-rp zm-icon-repeat fn-repeat all\">\n        <span class=\"zm-hv-tooltip\"></span>\n    </span>\n    <% } %>\n\n    <% if ((options.sourceLevel && options.sourceLevel.length > 0 && options.mimeType == 'audio/mp3') || options.showLevel) { %>\n    <div class=\"zm-quanlity\">\n        <span class=\"zm-quanlity-display\"><%= options.sourceLevel[currentLevel].label %></span>\n        <div class=\"zm-tooltip none\">\n            <ul class=\"zm-list-quanlity\">\n                <% for (var i = options.sourceLevel.length - 1; i >= 0; i--) { %>\n                <li class=\"<%= (i == currentLevel) ? 'active' : '' %>\"><span><%=options.sourceLevel[i].label %></span></li>\n                <% } %>\n            </ul>\n        </div><!-- /.zm-tooltip -->\n    </div>\n    <% } %>\n\n    <% if (options.mvUrl || options.mp3Url) { %>\n    <div class=\"zm-jump-mv\">\n        <a href=\"<%= options.mvUrl ? options.mvUrl : options.mp3Url %>\"><%= options.mvUrl ? 'MV' : 'MP3' %></a>\n        <span class=\"zm-hv-tooltip\"><%= options.mvUrl ? 'Xem MV' : 'Nghe MP3' %> bài này</span>\n    </div>\n    <% } %>\n\n    <% if (options.karaokeUrl) { %>\n    <div class=\"zm-jump-lyric active\">\n        <span class=\"zm-hv-tooltip\"></span>\n    </div>\n    <% } %>\n</div>\n<% } %>\n</div>";

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><path class=\"zp-svg-fill\" d=\"M 12,26 18.5,22 18.5,14 12,10 z M 18.5,22 25,18 25,18 18.5,14 z\" id=\"zp-svg-play\"></path></svg>"

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><path class=\"zp-svg-fill\" d=\"M 12,26 16,26 16,10 12,10 z M 21,26 25,26 25,10 21,10 z\" id=\"zp-svg-pause\"></path></svg>"

/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><use class=\"ytp-svg-shadow\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#ytp-svg-41\"></use><path class=\"ytp-svg-fill\" d=\"M 12,26 16,26 16,10 12,10 z M 21,26 25,26 25,10 21,10 z\" id=\"ytp-svg-41\"></path></svg>"

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" viewBox=\"0 0 36 36\"><defs><path d=\"M8,21 L12,21 L17,26 L17,10 L12,15 L8,15 L8,21 Z M19,14 L19,22 C20.48,21.32 21.5,19.77 21.5,18 C21.5,16.26 20.48,14.74 19,14 Z\" id=\"zp-svg-volume-low\"></path></defs><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-volume-low\"></use><use class=\"zp-svg-fill\" xlink:href=\"#zp-svg-volume-low\"></use></svg>"

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" viewBox=\"0 0 36 36\"><defs><path d=\"M8,21 L12,21 L17,26 L17,10 L12,15 L8,15 L8,21 Z M19,14 L19,22 C20.48,21.32 21.5,19.77 21.5,18 C21.5,16.26 20.48,14.74 19,14 Z M19,11.29 C21.89,12.15 24,14.83 24,18 C24,21.17 21.89,23.85 19,24.71 L19,26.77 C23.01,25.86 26,22.28 26,18 C26,13.72 23.01,10.14 19,9.23 L19,11.29 Z\" id=\"zp-svg-volume-high\"></path></defs><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-volume-high\"></use><use class=\"zp-svg-fill\" xlink:href=\"#zp-svg-volume-high\"></use></svg>"

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><path class=\"zp-svg-fill\" d=\"m16.98686,9.984l0,4.219l-2.109,-2.109l2.109,-2.11zm-7.734,-0.984l16.734,16.734l-1.266,1.266l-2.063,-2.063c-1.078,0.844 -2.297,1.5 -3.656,1.828l0,-2.063c0.844,-0.234 1.594,-0.656 2.25,-1.172l-4.266,-4.266l0,6.75l-5.016,-5.016l-3.984,0l0,-6l4.734,0l-4.734,-4.734l1.267,-1.264zm14.718,9c0,-3.188 -2.063,-5.859 -4.969,-6.703l0,-2.063c4.031,0.891 6.984,4.5 6.984,8.766c0,1.5 -0.375,2.953 -1.031,4.172l-1.5,-1.547c0.328,-0.797 0.516,-1.688 0.516,-2.625zm-2.484,0c0,0.234 0,0.422 -0.047,0.609l-2.438,-2.438l0,-2.203c1.5,0.75 2.484,2.25 2.484,4.031l0.001,0.001z\"></path></svg>"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><g class=\"zp-fullscreen-button-corner-0\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-fullscreen-corner-0\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z\" id=\"zp-svg-fullscreen-corner-0\"></path></g><g class=\"zp-fullscreen-button-corner-1\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-fullscreen-corner-1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z\" id=\"zp-svg-fullscreen-corner-1\"></path></g><g class=\"zp-fullscreen-button-corner-2\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-fullscreen-corner-2\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z\" id=\"zp-svg-fullscreen-corner-2\"></path></g><g class=\"zp-fullscreen-button-corner-3\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-fullscreen-corner-3\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z\" id=\"zp-svg-fullscreen-corner-3\"></path></g></svg>"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><g class=\"zp-fullscreen-button-corner-2\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-normalscreen-corner-0\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 14,14 -4,0 0,2 6,0 0,-6 -2,0 0,4 0,0 z\" id=\"zp-svg-normalscreen-corner-0\"></path></g><g class=\"zp-fullscreen-button-corner-3\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-normalscreen-corner-1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 22,14 0,-4 -2,0 0,6 6,0 0,-2 -4,0 0,0 z\" id=\"zp-svg-normalscreen-corner-1\"></path></g><g class=\"zp-fullscreen-button-corner-0\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-normalscreen-corner-2\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 20,26 2,0 0,-4 4,0 0,-2 -6,0 0,6 0,0 z\" id=\"zp-svg-normalscreen-corner-2\"></path></g><g class=\"zp-fullscreen-button-corner-1\"><use class=\"zp-svg-shadow\" xlink:href=\"#zp-svg-normalscreen-corner-3\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></use><path class=\"zp-svg-fill\" d=\"m 10,22 4,0 0,4 2,0 0,-6 -6,0 0,2 0,0 z\" id=\"zp-svg-normalscreen-corner-3\"></path></g></svg>"

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill=\"#010101\" d=\"M5.375 7.062H2.637V4.26H.502v7.488h2.135V8.9h2.738v2.848h2.133V4.26H5.375v2.802zm5.97-2.81h-2.84v7.496h2.798c2.65 0 4.195-1.607 4.195-3.77v-.022c0-2.162-1.523-3.704-4.154-3.704zm2.06 3.758c0 1.21-.81 1.896-2.03 1.896h-.83V6.093h.83c1.22 0 2.03.696 2.03 1.896v.02z\"></path></svg>"

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = "<svg viewBox=\"0 0 36 36\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"fill: #F7F7F7;\"><defs><path d=\"M27,19.35 L27,16.65 L24.61,16.65 C24.44,15.79 24.10,14.99 23.63,14.28 L25.31,12.60 L23.40,10.69 L21.72,12.37 C21.01,11.90 20.21,11.56 19.35,11.38 L19.35,9 L16.65,9 L16.65,11.38 C15.78,11.56 14.98,11.90 14.27,12.37 L12.59,10.69 L10.68,12.60 L12.36,14.28 C11.89,14.99 11.55,15.79 11.38,16.65 L9,16.65 L9,19.35 L11.38,19.35 C11.56,20.21 11.90,21.01 12.37,21.72 L10.68,23.41 L12.59,25.32 L14.28,23.63 C14.99,24.1 15.79,24.44 16.65,24.61 L16.65,27 L19.35,27 L19.35,24.61 C20.21,24.44 21.00,24.1 21.71,23.63 L23.40,25.32 L25.31,23.41 L23.62,21.72 C24.09,21.01 24.43,20.21 24.61,19.35 L27,19.35 Z M18,22.05 C15.76,22.05 13.95,20.23 13.95,18 C13.95,15.76 15.76,13.95 18,13.95 C20.23,13.95 22.05,15.76 22.05,18 C22.05,20.23 20.23,22.05 18,22.05 L18,22.05 Z\" id=\"ytp-svg-35\"></path></defs><use class=\"ytp-svg-shadow\" xlink:href=\"#ytp-svg-35\"></use><use class=\"ytp-svg-fill\" xlink:href=\"#ytp-svg-35\"></use></svg>"

/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = "<svg viewBox=\"0 0 36 36\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"fill: #F7F7F7;\"><defs><path d=\"M9,24 L27,24 L27,12 L9,12 L9,24 Z M17.05,19.50 C16.91,19.79 16.72,20.04 16.49,20.24 C16.26,20.44 15.99,20.60 15.69,20.70 C15.38,20.81 15.04,20.86 14.67,20.86 C14.21,20.86 13.79,20.79 13.43,20.64 C13.06,20.48 12.75,20.27 12.5,20.01 C12.24,19.74 12.05,19.42 11.91,19.06 C11.78,18.70 11.71,18.31 11.71,17.89 C11.71,17.47 11.78,17.07 11.91,16.70 C12.05,16.34 12.24,16.02 12.5,15.74 C12.75,15.47 13.06,15.26 13.43,15.10 C13.79,14.95 14.21,14.87 14.67,14.87 C15.00,14.87 15.31,14.91 15.61,15.01 C15.90,15.10 16.16,15.23 16.40,15.40 C16.63,15.58 16.82,15.79 16.97,16.05 C17.13,16.31 17.22,16.60 17.26,16.93 L15.98,16.93 C15.96,16.79 15.91,16.66 15.83,16.54 C15.75,16.41 15.65,16.31 15.53,16.22 C15.42,16.13 15.28,16.06 15.14,16.01 C14.98,15.95 14.83,15.93 14.67,15.93 C14.37,15.93 14.12,15.98 13.91,16.09 C13.70,16.20 13.53,16.35 13.40,16.54 C13.27,16.72 13.18,16.93 13.12,17.17 C13.06,17.40 13.03,17.64 13.03,17.89 C13.03,18.14 13.06,18.37 13.12,18.60 C13.18,18.82 13.27,19.03 13.40,19.21 C13.53,19.39 13.70,19.54 13.91,19.65 C14.12,19.76 14.37,19.81 14.67,19.81 C15.07,19.81 15.39,19.70 15.61,19.46 C15.84,19.22 15.98,18.91 16.03,18.53 L17.31,18.53 C17.28,18.89 17.19,19.21 17.05,19.50 L17.05,19.50 Z M24.04,19.51 C23.90,19.80 23.72,20.04 23.49,20.24 C23.26,20.45 22.99,20.60 22.68,20.71 C22.37,20.82 22.03,20.87 21.66,20.87 C21.20,20.87 20.79,20.80 20.42,20.64 C20.05,20.49 19.74,20.28 19.49,20.01 C19.24,19.75 19.04,19.43 18.91,19.07 C18.77,18.71 18.70,18.32 18.70,17.90 C18.70,17.47 18.77,17.08 18.91,16.71 C19.04,16.34 19.24,16.02 19.49,15.75 C19.74,15.48 20.05,15.26 20.42,15.11 C20.79,14.95 21.20,14.88 21.66,14.88 C21.99,14.88 22.30,14.92 22.60,15.01 C22.89,15.10 23.16,15.24 23.39,15.41 C23.62,15.58 23.82,15.80 23.97,16.06 C24.12,16.31 24.21,16.61 24.25,16.94 L22.97,16.94 C22.95,16.79 22.90,16.66 22.82,16.54 C22.74,16.42 22.65,16.32 22.53,16.22 C22.41,16.13 22.27,16.06 22.13,16.01 C21.98,15.96 21.82,15.94 21.66,15.94 C21.36,15.94 21.11,15.99 20.90,16.10 C20.7,16.21 20.53,16.36 20.40,16.54 C20.27,16.73 20.17,16.94 20.11,17.17 C20.06,17.41 20.03,17.65 20.03,17.90 C20.03,18.14 20.06,18.38 20.11,18.60 C20.17,18.83 20.27,19.04 20.40,19.22 C20.53,19.40 20.7,19.55 20.90,19.66 C21.11,19.76 21.36,19.82 21.66,19.82 C22.06,19.82 22.38,19.70 22.61,19.47 C22.84,19.23 22.97,18.92 23.02,18.54 L24.30,18.54 C24.27,18.89 24.18,19.22 24.04,19.51 L24.04,19.51 Z\" id=\"ytp-svg-8\"></path></defs><use class=\"ytp-svg-shadow\" xlink:href=\"#ytp-svg-8\"></use><use class=\"ytp-svg-fill\" xlink:href=\"#ytp-svg-8\"></use></svg>"

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" x=\"0px\" y=\"0px\" viewBox=\"-469 271 20 20\" style=\"enable-background:new -469 271 20 20;\" xml:space=\"preserve\"><g><g transform=\"translate(-18.000000, -65.000000)\"><g transform=\"translate(16.000000, 63.000000)\"><path class=\"zp-svg-fill\" d=\"M-467,273v20h3.3v-20H-467z M-461.2,283l14.2,10v-20L-461.2,283z\"></path></g></g></g></svg>"

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"-469 271 20 20\" style=\"enable-background:new -469 271 20 20;\" xml:space=\"preserve\"><g><g transform=\"translate(-66.000000, -65.000000)\"><g transform=\"translate(64.000000, 63.000000)\"><path class=\"zp-svg-fill\" d=\"M-467,293l14.2-10l-14.2-10V293L-467,293z M-450.3,273v20h3.3v-20H-450.3L-450.3,273z\"></path></g></g></g></svg>"

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"-471 271 16 20\" style=\"enable-background:new -471 271 16 20;\" xml:space=\"preserve\"><g><g transform=\"translate(-21.000000, -497.000000)\"><g transform=\"translate(17.000000, 495.000000)\"><path class=\"zp-svg-fill\" d=\"M-459,277v-4l-5,5l5,5v-4c3.3,0,6,2.7,6,6s-2.7,6-6,6s-6-2.7-6-6h-2c0,4.4,3.6,8,8,8s8-3.6,8-8 S-454.6,277-459,277L-459,277z\"></path></g></g></g></svg>"

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = "<svg viewBox=\"0 0 20 18\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink \"><!-- Generator: Sketch 41.2 (35397) - http://www.bohemiancoding.com/sketch --><title>ic_repeat-off</title><desc>Created with Sketch.</desc><defs></defs><g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"player_icons\" transform=\"translate(-19.000000, -354.000000)\"><g id=\"ic_repeat-off\" transform=\"translate(17.000000, 351.000000)\"><rect id=\"Rectangle-9\" x=\"0\" y=\"0\" width=\"24\" height=\"24\"></rect><path d=\"M8,4.41421356 L10.8284271,7.24264069 L8,10.0710678 L9.41421356,11.4852814 L12.2426407,8.65685425 L15.0710678,11.4852814 L16.4852814,10.0710678 L13.6568542,7.24264069 L16.4852814,4.41421356 L15.0710678,3 L12.2426407,5.82842712 L9.41421356,3 L8,4.41421356 Z M4.223,16.331 L18.667,16.331 L18.667,14.108 L22,17.441 L18.667,20.775 L18.667,18.553 L3.112,18.553 C2.498,18.553 2,18.056 2,17.441 L2,11 L4.21772823,11 L4.223,16.331 Z\" id=\"Combined-Shape\" fill=\"#FFFFFF\"></path></g></g></g></svg>"

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink \" x=\"0px\" y=\"0px\" viewBox=\"-469 272 20 18\" style=\"enable-background:new -469 272 20 18;\" xml:space=\"preserve\"><g><g transform=\"translate(-19.000000, -210.000000)\"><g transform=\"translate(17.000000, 207.000000)\"><path class=\"zp-svg-fill\" d=\"M-464.8,279.4h14.4l0,2.2l3.3-3.3l-3.3-3.3v2.2h-15.6c-0.6,0-1.1,0.5-1.1,1.1v8.4 l2.2-2.3V279.4z M-449.2,288.3h-14.4v-2.2l-3.3,3.3l3.3,3.3v-2.2h15.6c0.6,0,1.1-0.5,1.1-1.1V281l-2.2,2.3V288.3z\"></path></g></g></g></svg>"

/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink \" x=\"0px\" y=\"0px\" viewBox=\"-469 271 20 19\" style=\"enable-background:new -469 271 20 19;\" xml:space=\"preserve\"><g><g transform=\"translate(-19.000000, -258.000000)\"><g transform=\"translate(17.000000, 255.000000)\"><path class=\"zp-svg-fill\" d=\"M-464.8,278.4h14.4l0,2.2l3.3-3.3l-3.3-3.3v2.2h-15.6c-0.6,0-1.1,0.5-1.1,1.1v8.4 l2.2-2.3V278.4z M-449.2,287.3l-7.2,0l-2,2.2l10.3,0c0.6,0,1.1-0.5,1.1-1.1V280l-2.2,2.3V287.3z\"></path><path id=\"Combined-Shape_1_\" class=\"zp-svg-fill\" d=\"M-462.5,289.8h1.3v0.9h-3.5v-0.9h1.3v-2.6h-1.3v-0.9h1.3v0h0.9V289.8z M-463,292.5 c2.2,0,4-1.8,4-4s-1.8-4-4-4s-4,1.8-4,4S-465.2,292.5-463,292.5z\"></path></g></g></g></svg>"

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink \" x=\"0px\" y=\"0px\" viewBox=\"-469 272 20 18\" style=\"enable-background:new -469 272 20 18;\" xml:space=\"preserve\"><g><g transform=\"translate(-19.000000, -306.000000)\"><g transform=\"translate(17.000000, 303.000000)\"><path class=\"zp-svg-fill\" d=\"M-462.6,277.2h-4.4v2.2h5.3l1.9,3l1.3-2.1l-0.6-0.9l-1.4-2.2H-462.6z M-456.7,287.4 l0.6,0.9l1.4,2.2h2.2h2.2l0,0v2.2l3.3-3.3l-3.3-3.3v2.2h-3.2l-1.9-3L-456.7,287.4z M-450.3,275v2.2h-2.2h-2.2l-1.4,2.2l-1.5,2.3 l-1.3,2.1l-2.8,4.5h-5.3v2.2h4.4h2.2l1.4-2.2l1.5-2.4l1.3-2.1l2.8-4.4h3.2l0,0v2.2l3.3-3.3L-450.3,275z\"></path></g></g></g></svg>"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><path d=\"m 28,11 0,14 -20,0 0,-14 z m -18,2 16,0 0,10 -16,0 0,-10 z\" fill-rule=\"evenodd\" id=\"zp-svg-expand\"></path><use class=\"zp-svg-fill\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#zp-svg-expand\"></use></svg>"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" viewBox=\"0 0 36 36\"><path d=\"m 26,13 0,10 -16,0 0,-10 z m -14,2 12,0 0,6 -12,0 0,-6 z\" fill-rule=\"evenodd\" id=\"zp-svg-collapse\"></path><use class=\"zp-svg-fill\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#zp-svg-collapse\"></use></svg>"

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"-471 271 17 20\" style=\"enable-background:new -471 271 17 20;\" xml:space=\"preserve\"><g><g transform=\"translate(-21.000000, -449.000000)\"><g transform=\"translate(17.000000, 447.000000)\"><path class=\"zp-svg-fill\" d=\"M-458.9,280.3c-0.4-0.4-1.1-0.4-1.5,0s-0.4,1.1,0,1.5s1.1,0.4,1.5,0S-458.5,280.8-458.9,280.3z M-462.7,287.2l-0.8-0.8l-0.8,0.8c-0.8,0.8-0.8,2.2,0,3c0.8,0.8,2.2,0.8,3,0l3.8-3.8c1.7-1.7,4.4-1.7,6.1,0l0.8,0.8 c0.3,0.3,0.5,1,0,1.5c-0.5,0.5-1.3,0.3-1.5,0l-0.8-0.8c-0.8-0.8-2.2-0.8-3,0l-3.8,3.8c-1.7,1.7-4.4,1.7-6.1,0s-1.7-4.4,0-6.1 l0.8-0.8l-0.8-0.8l5.6-6.9c0-0.8,0.2-1.5,0.6-2.2l5.9,5.9c-0.7,0.4-1.4,0.6-2.2,0.6L-462.7,287.2z M-452.8,274.3 c1.7,1.7,1.7,4.4,0,6.1l-6.1-6.1C-457.2,272.6-454.5,272.6-452.8,274.3z\"></path></g></g></g></svg>"

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var defineProperties = __webpack_require__(27);

	var implementation = __webpack_require__(87);
	var getPolyfill = __webpack_require__(89);
	var shim = __webpack_require__(90);

	var polyfill = getPolyfill();

	defineProperties(polyfill, {
		implementation: implementation,
		getPolyfill: getPolyfill,
		shim: shim
	});

	module.exports = polyfill;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es6-shim
	var keys = __webpack_require__(28);
	var bind = __webpack_require__(43);
	var canBeObject = function (obj) {
		return typeof obj !== 'undefined' && obj !== null;
	};
	var hasSymbols = __webpack_require__(88)();
	var toObject = Object;
	var push = bind.call(Function.call, Array.prototype.push);
	var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
	var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

	module.exports = function assign(target, source1) {
		if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
		var objTarget = toObject(target);
		var s, source, i, props, syms, value, key;
		for (s = 1; s < arguments.length; ++s) {
			source = toObject(arguments[s]);
			props = keys(source);
			var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
			if (getSymbols) {
				syms = getSymbols(source);
				for (i = 0; i < syms.length; ++i) {
					key = syms[i];
					if (propIsEnumerable(source, key)) {
						push(props, key);
					}
				}
			}
			for (i = 0; i < props.length; ++i) {
				key = props[i];
				value = source[key];
				if (propIsEnumerable(source, key)) {
					objTarget[key] = value;
				}
			}
		}
		return objTarget;
	};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys = __webpack_require__(28);

	module.exports = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; }
		if (keys(obj).length !== 0) { return false; }
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var implementation = __webpack_require__(87);

	var lacksProperEnumerationOrder = function () {
		if (!Object.assign) {
			return false;
		}
		// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
		// note: this does not detect the bug unless there's 20 characters
		var str = 'abcdefghijklmnopqrst';
		var letters = str.split('');
		var map = {};
		for (var i = 0; i < letters.length; ++i) {
			map[letters[i]] = letters[i];
		}
		var obj = Object.assign({}, map);
		var actual = '';
		for (var k in obj) {
			actual += k;
		}
		return str !== actual;
	};

	var assignHasPendingExceptions = function () {
		if (!Object.assign || !Object.preventExtensions) {
			return false;
		}
		// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		// which is 72% slower than our shim, and Firefox 40's native implementation.
		var thrower = Object.preventExtensions({ 1: 2 });
		try {
			Object.assign(thrower, 'xy');
		} catch (e) {
			return thrower[1] === 'y';
		}
		return false;
	};

	module.exports = function getPolyfill() {
		if (!Object.assign) {
			return implementation;
		}
		if (lacksProperEnumerationOrder()) {
			return implementation;
		}
		if (assignHasPendingExceptions()) {
			return implementation;
		}
		return Object.assign;
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(27);
	var getPolyfill = __webpack_require__(89);

	module.exports = function shimAssign() {
		var polyfill = getPolyfill();
		define(
			Object,
			{ assign: polyfill },
			{ assign: function () { return Object.assign !== polyfill; } }
		);
		return polyfill;
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(92);

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _player_info = __webpack_require__(54);

	var _player_info2 = _interopRequireDefault(_player_info);

	var _utils = __webpack_require__(2);

	var _html5_video = __webpack_require__(93);

	var _html5_video2 = _interopRequireDefault(_html5_video);

	var _no_op = __webpack_require__(98);

	var _no_op2 = _interopRequireDefault(_no_op);

	var _spinner_three_bounce = __webpack_require__(102);

	var _spinner_three_bounce2 = _interopRequireDefault(_spinner_three_bounce);

	var _stats = __webpack_require__(107);

	var _stats2 = _interopRequireDefault(_stats);

	var _click_to_pause = __webpack_require__(110);

	var _click_to_pause2 = _interopRequireDefault(_click_to_pause);

	var _favicon = __webpack_require__(112);

	var _favicon2 = _interopRequireDefault(_favicon);

	var _seek_time = __webpack_require__(115);

	var _seek_time2 = _interopRequireDefault(_seek_time);

	var _sources = __webpack_require__(120);

	var _sources2 = _interopRequireDefault(_sources);

	var _end_video = __webpack_require__(121);

	var _end_video2 = _interopRequireDefault(_end_video);

	var _strings = __webpack_require__(122);

	var _strings2 = _interopRequireDefault(_strings);

	var _playlist = __webpack_require__(123);

	var _playlist2 = _interopRequireDefault(_playlist);

	var _vast_mobile = __webpack_require__(124);

	var _vast_mobile2 = _interopRequireDefault(_vast_mobile);

	var _poster = __webpack_require__(179);

	var _poster2 = _interopRequireDefault(_poster);

	var _hls = __webpack_require__(183);

	var _hls2 = _interopRequireDefault(_hls);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Playback


	// Plugins


	// import DVRControls from 'plugins/dvr_controls'

	// import LevelSelector from 'plugins/level_selector'

	// // ZingMP3
	// import HTML5AudioPlayback from 'playbacks/html5_audio'
	// import KaraokePlugin from 'plugins/karaoke';
	// import DaastPlugin from 'plugins/daast';
	// import VastPlugin from 'plugins/vast_mobile';
	// import PosterPlugin from 'plugins/poster';
	// import BannerAdsPlugin from 'plugins/bannerads'
	// import PlayNextPlugin from 'plugins/playnext'

	// // ZingTV
	// import SubtitlePlugin from 'plugins/subtitle';
	// import PosterPlugin from 'plugins/poster';
	// import VastPlugin from 'plugins/vast_zingtv';
	// import HLS from 'playbacks/hls';

	// ZingNews


	// // BaoMoi
	// import HLS from 'playbacks/hls';
	// import VastPlugin from 'plugins/vast_mobile';
	// import PosterPlugin from 'plugins/poster_baomoi';

	// // ZTE
	// import PosterPlugin from 'plugins/poster';
	// import HLS from 'playbacks/hls';

	var Loader = function (_BaseObject) {
	    _inherits(Loader, _BaseObject);

	    function Loader(externalPlugins, playerId) {
	        _classCallCheck(this, Loader);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this));

	        _this.playerId = playerId;

	        _this.playbackPlugins = [_hls2.default, _html5_video2.default,
	        // HTML5AudioPlayback,
	        _no_op2.default];

	        _this.containerPlugins = [_spinner_three_bounce2.default, _stats2.default, _click_to_pause2.default, _poster2.default];

	        _this.corePlugins = [
	        // LevelSelector,
	        // DVRControls,
	        _favicon2.default, _seek_time2.default, _sources2.default, _end_video2.default, _strings2.default, _playlist2.default, _vast_mobile2.default];

	        if (externalPlugins) {
	            if (!Array.isArray(externalPlugins)) {
	                _this.validateExternalPluginsType(externalPlugins);
	            }
	            _this.addExternalPlugins(externalPlugins);
	        }
	        return _this;
	    }

	    Loader.prototype.groupPluginsByType = function groupPluginsByType(plugins) {
	        if (Array.isArray(plugins)) {
	            plugins = plugins.reduce(function (memo, plugin) {
	                memo[plugin.type] || (memo[plugin.type] = []);
	                memo[plugin.type].push(plugin);
	                return memo;
	            }, {});
	        }
	        return plugins;
	    };

	    Loader.prototype.addExternalPlugins = function addExternalPlugins(plugins) {
	        plugins = this.groupPluginsByType(plugins);
	        var pluginName = function pluginName(plugin) {
	            return plugin.prototype.name;
	        };
	        if (plugins.playback) {
	            this.playbackPlugins = (0, _utils.uniqBy)(plugins.playback.concat(this.playbackPlugins), pluginName);
	        }
	        if (plugins.container) {
	            this.containerPlugins = (0, _utils.uniqBy)(plugins.container.concat(this.containerPlugins), pluginName);
	        }
	        if (plugins.core) {
	            this.corePlugins = (0, _utils.uniqBy)(plugins.core.concat(this.corePlugins), pluginName);
	        }
	        _player_info2.default.getInstance(this.playerId).playbackPlugins = this.playbackPlugins;
	    };

	    Loader.prototype.validateExternalPluginsType = function validateExternalPluginsType(plugins) {
	        var pluginTypes = ['playback', 'container', 'core'];
	        pluginTypes.forEach(function (type) {
	            (plugins[type] || []).forEach(function (el) {
	                var errorMessage = 'external ' + el.type + ' plugin on ' + type + ' array';
	                if (el.type !== type) {
	                    throw new ReferenceError(errorMessage);
	                }
	            });
	        });
	    };

	    return Loader;
	}(_base_object2.default);

	exports.default = Loader;
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(94);

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _style = __webpack_require__(95);

	var _style2 = _interopRequireDefault(_style);

	var _index = __webpack_require__(96);

	var _index2 = _interopRequireDefault(_index);

	var _webvtt = __webpack_require__(97);

	var _webvtt2 = _interopRequireDefault(_webvtt);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var MIMETYPES = {
	  'mp4': ['avc1.42E01E', 'avc1.58A01E', 'avc1.4D401E', 'avc1.64001E', 'mp4v.20.8', 'mp4v.20.240', 'mp4a.40.2'].map(function (codec) {
	    return 'video/mp4; codecs="' + codec + ', mp4a.40.2"';
	  }),
	  'ogg': ['video/ogg; codecs="theora, vorbis"', 'video/ogg; codecs="dirac"', 'video/ogg; codecs="theora, speex"'],
	  '3gpp': ['video/3gpp; codecs="mp4v.20.8, samr"'],
	  'webm': ['video/webm; codecs="vp8, vorbis"'],
	  'mkv': ['video/x-matroska; codecs="theora, vorbis"'],
	  'm3u8': ['application/x-mpegurl']
	};
	MIMETYPES['ogv'] = MIMETYPES['ogg'];
	MIMETYPES['3gp'] = MIMETYPES['3gpp'];

	var AUDIO_MIMETYPES = {
	  'wav': ['audio/wav'],
	  'mp3': ['audio/mp3', 'audio/mpeg;codecs="mp3"'],
	  'aac': ['audio/mp4;codecs="mp4a.40.5"'],
	  'oga': ['audio/ogg']
	};

	var KNOWN_AUDIO_MIMETYPES = Object.keys(AUDIO_MIMETYPES).reduce(function (acc, k) {
	  return [].concat(_toConsumableArray(acc), _toConsumableArray(AUDIO_MIMETYPES[k]));
	}, []);

	var HTML5Video = function (_Playback) {
	  _inherits(HTML5Video, _Playback);

	  _createClass(HTML5Video, [{
	    key: 'name',
	    get: function get() {
	      return 'html5_video';
	    }
	  }, {
	    key: 'tagName',
	    get: function get() {
	      return this.isAudioOnly ? 'audio' : 'video';
	    }
	  }, {
	    key: 'template',
	    get: function get() {
	      return (0, _template2.default)(_index2.default);
	    }
	  }, {
	    key: 'isAudioOnly',
	    get: function get() {
	      var resourceUrl = this.options.src;
	      var mimeTypes = HTML5Video._mimeTypesForUrl(resourceUrl, AUDIO_MIMETYPES, this.options.mimeType);
	      return this.options.playback && this.options.playback.audioOnly || this.options.audioOnly || KNOWN_AUDIO_MIMETYPES.indexOf(mimeTypes[0]) >= 0;
	    }
	  }, {
	    key: 'attributes',
	    get: function get() {
	      var attr = {
	        'data-html5-video': ''
	      };

	      if (this.options.playInline) {
	        attr['webkit-playsinline'] = '';
	        attr['playsinline'] = '';
	      }

	      if (this.options.autoPlay) {
	        attr['autoplay'] = '';
	      }

	      if (this.options.muted) {
	        attr['muted'] = '';
	      }

	      return attr;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return {
	        'loadstart': '_onLoadStart',
	        'canplay': '_onCanPlay',
	        'canplaythrough': '_onCanPlayThrough',
	        'durationchange': '_onDurationChange',
	        'ended': '_onEnded',
	        'error': '_onError',
	        'loadeddata': '_onLoadedData',
	        'loadedmetadata': '_onLoadedMetadata',
	        'pause': '_onPause',
	        'playing': '_onPlaying',
	        'progress': '_onProgress',
	        'seeked': '_handleBufferingEvents',
	        'seeking': '_onSeeking',
	        'stalled': '_onSeeked',
	        'timeupdate': '_onTimeUpdate',
	        'waiting': '_onWaiting'
	      };
	    }
	  }, {
	    key: 'ended',
	    get: function get() {
	      return this.el.ended;
	    }
	  }, {
	    key: 'buffering',
	    get: function get() {
	      return !!this._bufferingState;
	    }
	  }]);

	  function HTML5Video() {
	    _classCallCheck(this, HTML5Video);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var _this = _possibleConstructorReturn(this, _Playback.call.apply(_Playback, [this].concat(args)));

	    window.zplayer_isTracking = false;

	    _this._loadStarted = false;
	    _this._playheadMoving = false;
	    _this._playheadMovingTimer = null;
	    _this._stopped = false;
	    _this._setupSrc(_this.options.src);
	    _this.options.playback || (_this.options.playback = _this.options || {});
	    _this.options.playback.disableContextMenu = _this.options.playback.disableContextMenu || _this.options.disableVideoTagContextMenu;

	    var playbackConfig = _this.options.playback;
	    var preload = playbackConfig.preload || (_browser2.default.isSafari ? 'auto' : _this.options.preload);

	    _clapprZepto2.default.extend(_this.el, {
	      loop: _this.options.loop || false,
	      // poster: this.options.poster,
	      id: (0, _utils.uniqueId)('zplayerjs') || 'zplayerjs',
	      preload: preload || 'none',
	      crossOrigin: playbackConfig.crossOrigin,
	      autoPlay: _this.options.autoPlay || false
	    });

	    _this.settings = { default: ['seekbar'] };
	    _this.settings.left = ['replay', 'playpause', 'position', 'duration'];
	    _this.settings.right = ['fullscreen', 'volume', 'hd-indicator'];
	    if (_this.options.showSetting) {
	      _this.settings.right.push('setting');
	    }
	    if (_this.options.subtitleUrl) {
	      _this.settings.right.push('cc');
	    }

	    _this.options.autoPlay && process.nextTick(function () {
	      return _this.play();
	    });
	    return _this;
	  }

	  HTML5Video.prototype._startTracking = function _startTracking() {
	    var _this2 = this;

	    window.zplayer_isTracking = true;
	    var viewerId = window.localStorage.getItem("zpl_viewerid");
	    if (!viewerId || viewerId == 'undefined') {
	      viewerId = '';
	    }

	    if (this.options.trackingId) {
	      _clapprZepto2.default.get('//tracking.api.media.zapps.vn/event?id=' + this.options.trackingId + '&viewerId=' + viewerId, function (response, status) {
	        if (status == 'success') {
	          response = JSON.parse(response);
	          if (response.error_code > 0) {
	            var inteval = response.ping_period;
	            if (inteval > 0) {
	              if (viewerId == '') {
	                viewerId = response.viewer_id;
	                window.localStorage.setItem("zpl_viewerid", viewerId);
	              }

	              //interval
	              _this2.trackingWorker = setInterval(function () {
	                _clapprZepto2.default.get('//tracking.api.media.zapps.vn/event?type=ping&id=' + _this2.options.trackingId + '&viewerId=' + viewerId, function (response) {});
	              }, inteval);
	            }
	          }
	        }
	      });
	    }
	  };

	  HTML5Video.prototype._stopTracking = function _stopTracking() {
	    window.zplayer_isTracking = false;
	    if (this.trackingWorker) {
	      clearInterval(this.trackingWorker);
	      this.trackingWorker = null;
	    }
	  };

	  HTML5Video.prototype._now = function _now() {
	    return new Date();
	  };

	  HTML5Video.prototype._setupSrc = function _setupSrc(srcUrl) {
	    this._src = srcUrl;
	    this.el.src = srcUrl;
	  };

	  HTML5Video.prototype._onLoadStart = function _onLoadStart(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_LOADSTART, { time: this._now(), data: e });
	  };

	  HTML5Video.prototype._onLoadedMetadata = function _onLoadedMetadata(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_LOADEDMETADATA, { duration: e.target.duration, data: e });
	    this._updateSettings();
	    var autoSeekFromUrl = typeof this._options.autoSeekFromUrl === 'undefined' || this._options.autoSeekFromUrl;
	    if (this.getPlaybackType() !== _playback2.default.LIVE && autoSeekFromUrl) {
	      this._checkInitialSeek();
	    }
	  };

	  HTML5Video.prototype._onDurationChange = function _onDurationChange() {
	    this._updateSettings();
	    // this._onTimeUpdate()
	    // onProgress uses the duration
	    this._onProgress();
	  };

	  HTML5Video.prototype._updateSettings = function _updateSettings() {
	    if (this.getPlaybackType() === _playback2.default.VOD || this.getPlaybackType() === _playback2.default.AOD) {
	      this.settings.left = ['playpause', 'position', 'duration'];
	    } else {
	      this.settings.left = ['playstop'];
	    }
	    this.settings.seekEnabled = this.isSeekEnabled();
	    this.trigger(_events2.default.PB_SETTINGSUPDATE);
	  };

	  HTML5Video.prototype.isSeekEnabled = function isSeekEnabled() {
	    return isFinite(this.getDuration());
	  };

	  HTML5Video.prototype.getPlaybackType = function getPlaybackType() {
	    var onDemandType = this.tagName === 'audio' ? _playback2.default.AOD : _playback2.default.VOD;
	    return [0, undefined, Infinity].indexOf(this.el.duration) >= 0 ? _playback2.default.LIVE : onDemandType;
	  };

	  HTML5Video.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
	    return false;
	  };

	  HTML5Video.prototype.play = function play() {
	    var _this3 = this;

	    var d = new Date();
	    this.n = d.getTime();

	    if (!window.zplayer_isTracking) {
	      this._startTracking();
	    }

	    if (this._src || this.name == 'hls') {
	      this.trigger(_events2.default.PB_PLAY_INTENT, this._now());
	      this._stopped = false;
	      this._handleBufferingEvents();
	      this.playPromise = this.el.play();
	      if (this.playPromise !== undefined) {
	        this.playPromise.then(function () {
	          // Automatic playback started!
	        }).catch(function (error) {
	          // Automatic playback failed.
	          // Show a UI element to let the user manually start playback.
	          _this3.trigger(_events2.default.PB_PLAY_ERROR_SOURCE);
	        });
	      }
	    }
	  };

	  HTML5Video.prototype.pause = function pause() {
	    this.el.pause();
	  };

	  HTML5Video.prototype.stop = function stop() {
	    this._stopTracking();
	    this.pause();
	    this._stopped = true;
	    this.el.currentTime = 0;
	    this._stopPlayheadMovingChecks();
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_STOP);
	  };

	  HTML5Video.prototype.volume = function volume(value) {
	    this.el.volume = value / 100;
	  };

	  HTML5Video.prototype.mute = function mute() {
	    this.el.volume = 0;
	  };

	  HTML5Video.prototype.unmute = function unmute() {
	    this.el.mute = false;
	    this.el.volume = 1;
	  };

	  HTML5Video.prototype.isMuted = function isMuted() {
	    return !!this.el.volume;
	  };

	  HTML5Video.prototype.isPlaying = function isPlaying() {
	    return !this.el.paused && !this.el.ended;
	  };

	  HTML5Video.prototype._startPlayheadMovingChecks = function _startPlayheadMovingChecks() {
	    if (this._playheadMovingTimer !== null) {
	      return;
	    }
	    this._playheadMovingTimeOnCheck = null;
	    this._determineIfPlayheadMoving();
	    this._playheadMovingTimer = setInterval(this._determineIfPlayheadMoving.bind(this), 500);
	  };

	  HTML5Video.prototype._stopPlayheadMovingChecks = function _stopPlayheadMovingChecks() {
	    if (this._playheadMovingTimer === null) {
	      return;
	    }
	    clearInterval(this._playheadMovingTimer);
	    this._playheadMovingTimer = null;
	    this._playheadMoving = false;
	  };

	  HTML5Video.prototype._determineIfPlayheadMoving = function _determineIfPlayheadMoving() {
	    var before = this._playheadMovingTimeOnCheck;
	    var now = this.el.currentTime;
	    this._playheadMoving = before !== now;
	    this._playheadMovingTimeOnCheck = now;
	    this._handleBufferingEvents();
	  };

	  HTML5Video.prototype._onWaiting = function _onWaiting(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_WAITING, { time: this._now(), data: e });
	    this._loadStarted = true;
	  };

	  HTML5Video.prototype._onLoadedData = function _onLoadedData() {
	    this._loadStarted = true;
	    this._handleBufferingEvents();
	  };

	  HTML5Video.prototype._onCanPlay = function _onCanPlay(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_CANPLAY, { time: this._now(), data: e });
	    var d = new Date();
	  };

	  HTML5Video.prototype._onPlaying = function _onPlaying(e) {
	    this._startPlayheadMovingChecks();
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_PLAY, { time: this._now(), data: e });
	  };

	  HTML5Video.prototype._onPause = function _onPause() {
	    this._stopPlayheadMovingChecks();
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_PAUSE);
	  };

	  HTML5Video.prototype._onEnded = function _onEnded() {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_ENDED, this.name);
	  };

	  HTML5Video.prototype._onSeeking = function _onSeeking(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_SEEKING, { time: this._now(), data: e });
	  };

	  HTML5Video.prototype._onSeeked = function _onSeeked() {
	    this._handleBufferingEvents();
	  };

	  HTML5Video.prototype._onCanPlayThrough = function _onCanPlayThrough(e) {
	    this._handleBufferingEvents();
	    this.trigger(_events2.default.PB_CANPLAYTHROUGH, { time: this._now(), data: e });
	  };

	  HTML5Video.prototype._handleBufferingEvents = function _handleBufferingEvents() {
	    var playheadShouldBeMoving = !this.el.ended && !this.el.paused;
	    var buffering = this._loadStarted && !this.el.ended && !this._stopped && (playheadShouldBeMoving && !this._playheadMoving || this.el.readyState < this.el.HAVE_CURRENT_DATA);

	    if (this._bufferingState !== buffering) {
	      this._bufferingState = buffering;
	      if (buffering) {
	        this.trigger(_events2.default.PB_BUFFERING, this.name);
	      } else {
	        this.trigger(_events2.default.PB_BUFFERFULL, this.name);
	      }
	    }
	  };

	  HTML5Video.prototype._onError = function _onError() {
	    var error = this.el.error;
	    if (this.isReady && error.code && !isNaN(error.code)) {
	      this.trigger(_events2.default.PB_ERROR, this.el.error, this.name);
	    }
	  };

	  HTML5Video.prototype.destroy = function destroy() {
	    this._stopTracking();
	    this.el.src = '';
	    this._src = null;
	  };

	  HTML5Video.prototype.seek = function seek(time) {
	    this.el.currentTime = time;
	  };

	  HTML5Video.prototype.seekPercentage = function seekPercentage(percentage) {
	    var time = this.el.duration * (percentage / 100);
	    this.seek(time);
	  };

	  HTML5Video.prototype._checkInitialSeek = function _checkInitialSeek() {
	    var seekTime = (0, _utils.seekStringToSeconds)(window.location.href);
	    if (seekTime !== 0) {
	      this.seek(seekTime);
	    }
	  };

	  HTML5Video.prototype.getCurrentTime = function getCurrentTime() {
	    return this.el.currentTime;
	  };

	  HTML5Video.prototype.getDuration = function getDuration() {
	    return this.el.duration;
	  };

	  HTML5Video.prototype._onTimeUpdate = function _onTimeUpdate() {
	    this._handleBufferingEvents();
	    if (this.getPlaybackType() === _playback2.default.LIVE) {
	      this.trigger(_events2.default.PB_TIMEUPDATE, { current: 1, total: 1 }, this.name);
	    } else {
	      this.trigger(_events2.default.PB_TIMEUPDATE, { current: this.el.currentTime, total: this.el.duration }, this.name);
	    }
	  };

	  HTML5Video.prototype._onProgress = function _onProgress() {
	    if (!this.el.buffered.length) {
	      return;
	    }
	    var buffered = [];
	    var bufferedPos = 0;
	    for (var i = 0; i < this.el.buffered.length; i++) {
	      buffered = [].concat(_toConsumableArray(buffered), [{ start: this.el.buffered.start(i), end: this.el.buffered.end(i) }]);
	      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end) {
	        bufferedPos = i;
	      }
	    }
	    var progress = {
	      start: buffered[bufferedPos].start,
	      current: buffered[bufferedPos].end,
	      total: this.el.duration
	    };
	    this.trigger(_events2.default.PB_PROGRESS, progress, buffered);
	  };

	  HTML5Video.prototype._typeFor = function _typeFor(src) {
	    var mimeTypes = HTML5Video._mimeTypesForUrl(src, MIMETYPES, this.options.mimeType);
	    if (mimeTypes.length == 0) {
	      mimeTypes = HTML5Video._mimeTypesForUrl(src, AUDIO_MIMETYPES, this.options.mimeType);
	    }
	    var mimeType = mimeTypes[0] || '';
	    return mimeType.split(';')[0];
	  };

	  HTML5Video.prototype._ready = function _ready() {
	    if (this._isReadyState) {
	      return;
	    }
	    this._isReadyState = true;
	    this.trigger(_events2.default.PB_READY, this.name);
	  };

	  HTML5Video.prototype.render = function render() {
	    var _this4 = this;

	    var style = _styler2.default.getStyleFor(_style2.default, { customCSS: this.options.customCSS });

	    this._src && this.$el.html(this.template({
	      src: this._src,
	      type: this.options.mimeType || this._typeFor(this._src)
	    }));

	    if (this.options.playback.disableContextMenu) {
	      this.$el.on('contextmenu', function () {
	        return false;
	      });
	    }

	    // Webvtt
	    if (this.options.webvtt && this.options.webvtt.length > 0) {

	      this.options.webvtt.map(function (v) {
	        _this4.$el.append((0, _template2.default)(_webvtt2.default)({
	          label: v.label,
	          url: v.url
	        }));
	      });
	    }

	    !this.options.hasAnPlayerInstance && this.$el.append(style);

	    this._ready();

	    return this;
	  };

	  _createClass(HTML5Video, [{
	    key: 'isReady',
	    get: function get() {
	      return this._isReadyState;
	    }
	  }]);

	  return HTML5Video;
	}(_playback2.default);

	exports.default = HTML5Video;


	HTML5Video._mimeTypesForUrl = function (resourceUrl, mimeTypesByExtension, mimeType) {
	  var extension = (resourceUrl.split('?')[0].match(/.*\.(.*)$/) || [])[1];
	  var mimeTypes = mimeType || extension && mimeTypesByExtension[extension.toLowerCase()] || [];
	  return mimeTypes.constructor === Array ? mimeTypes : [mimeTypes];
	};

	HTML5Video._canPlay = function (type, mimeTypesByExtension, resourceUrl, mimeType) {
	  var mimeTypes = HTML5Video._mimeTypesForUrl(resourceUrl, mimeTypesByExtension, mimeType);
	  var media = document.createElement(type);
	  return !!(0, _arrayPrototype2.default)(mimeTypes, function (mediaType) {
	    return !!media.canPlayType(mediaType).replace(/no/, '');
	  });
	};

	HTML5Video.canPlay = function (resourceUrl, mimeType) {
	  return HTML5Video._canPlay('audio', AUDIO_MIMETYPES, resourceUrl, mimeType) || HTML5Video._canPlay('video', MIMETYPES, resourceUrl, mimeType);
	};

	module.exports = HTML5Video;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, "[data-html5-video] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: block; }\n\n.ima-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  text-align: left;\n  z-index: 999999 !important; }\n\niframe {\n  z-index: 99999998 !important; }\n\n.preroll-overlay[data-preroll] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999999 !important;\n  background-color: #000;\n  opacity: 0;\n  cursor: pointer;\n  overflow: visible; }\n\nvideo::cue {\n  color: white;\n  text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;\n  font-size: 25px;\n  background: rgba(0, 0, 0, 0.7);\n  width: 90%;\n  overflow-wrap: break-word; }\n\nvideo.hide-sub::cue {\n  visibility: hidden; }\n\nvideo.hide-background::cue {\n  background: transparent; }\n\nvideo.white::cue {\n  color: white; }\n\nvideo.yellow::cue {\n  color: yellow; }\n\nvideo.green::cue {\n  color: #6cd936; }\n\nvideo.normal::cue {\n  font-size: 20px; }\n\nvideo.large::cue {\n  font-size: 30px; }\n\nvideo.extra-large::cue {\n  font-size: 38px; }\n\n/* This used to work for parent element of button divs */\n/* But it is not enough now, below dont hide play button parent div */\n*::-webkit-media-controls-panel {\n  display: none !important;\n  -webkit-appearance: none; }\n\n/* Old shadow dom for play button */\n*::\\--webkit-media-controls-play-button {\n  display: none !important;\n  -webkit-appearance: none; }\n\n/* New shadow dom for play button */\n/* This one works */\n*::-webkit-media-controls-start-playback-button {\n  display: none !important;\n  -webkit-appearance: none; }\n\nvideo::-webkit-media-controls {\n  display: none !important; }\n", ""]);

	// exports


/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = "";

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "<track label=\"<%=label%>\" kind=\"subtitles\" srclang=\"en\" src=\"<%=url%>\" default>";

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(99);

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _style = __webpack_require__(100);

	var _style2 = _interopRequireDefault(_style);

	var _error = __webpack_require__(101);

	var _error2 = _interopRequireDefault(_error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var NoOp = function (_Playback) {
	    _inherits(NoOp, _Playback);

	    _createClass(NoOp, [{
	        key: 'name',
	        get: function get() {
	            return 'no_op';
	        }
	    }, {
	        key: 'template',
	        get: function get() {
	            return (0, _template2.default)(_error2.default);
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return { 'data-no-op': '' };
	        }
	    }]);

	    function NoOp() {
	        _classCallCheck(this, NoOp);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        var _this = _possibleConstructorReturn(this, _Playback.call.apply(_Playback, [this].concat(args)));

	        _this._noiseFrameNum = -1;
	        return _this;
	    }

	    NoOp.prototype.render = function render() {
	        var style = _styler2.default.getStyleFor(_style2.default);

	        // Prepare message for two case: not support and song has license
	        var hasLicenseMessage = this.container._options.msg || this.i18n.t('has_license');
	        var notSupportedMessage = this.container._options.notSupportMsg || this.i18n.t('playback_not_supported');
	        var noOpMsg = this.container._options.source === '' ? hasLicenseMessage : notSupportedMessage;

	        // Show message
	        this.$el.html(this.template({ message: noOpMsg }));
	        this.$el.append(style);
	        this._animate();
	        this.trigger(_events2.default.PB_READY, this.name);
	        return this;
	    };

	    NoOp.prototype._noise = function _noise() {};

	    NoOp.prototype._loop = function _loop() {
	        var _this2 = this;

	        if (this._stop) {
	            return;
	        }
	        this._noise();
	        this._animationHandle = (0, _utils.requestAnimationFrame)(function () {
	            return _this2._loop();
	        });
	    };

	    NoOp.prototype.destroy = function destroy() {
	        if (this._animationHandle) {
	            (0, _utils.cancelAnimationFrame)(this._animationHandle);
	            this._stop = true;
	        }
	    };

	    NoOp.prototype._animate = function _animate() {
	        this.canvas = this.$el.find('canvas[data-no-op-canvas]')[0];
	        this.context = this.canvas.getContext('2d');
	        this._loop();
	    };

	    return NoOp;
	}(_playback2.default);

	exports.default = NoOp;


	NoOp.canPlay = function (source) {
	    // eslint-disable-line no-unused-vars
	    return true;
	};
	module.exports = exports['default'];

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, "[data-no-op] {\n  z-index: 999999;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  text-align: center; }\n\n[data-no-op] p[data-no-op-msg] {\n  position: absolute;\n  text-align: center;\n  font-size: 18px;\n  left: 0;\n  right: 0;\n  color: white;\n  padding: 10px;\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  -moz-transform: translateY(-50%);\n  -ms-transform: translateY(-50%);\n  -o-transform: translateY(-50%);\n  transform: translateY(-50%);\n  max-height: 100%;\n  overflow: hidden;\n  height: 60%; }\n\n[data-no-op] canvas[data-no-op-canvas] {\n  height: 100%;\n  width: 100%; }\n", ""]);

	// exports


/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = "<canvas data-no-op-canvas></canvas>\n<p data-no-op-msg><%=message%><p>\n";

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(103);

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _ui_container_plugin = __webpack_require__(104);

	var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _spinner = __webpack_require__(105);

	var _spinner2 = _interopRequireDefault(_spinner);

	var _spinner3 = __webpack_require__(106);

	var _spinner4 = _interopRequireDefault(_spinner3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var SpinnerThreeBouncePlugin = function (_UIContainerPlugin) {
	  _inherits(SpinnerThreeBouncePlugin, _UIContainerPlugin);

	  _createClass(SpinnerThreeBouncePlugin, [{
	    key: 'name',
	    get: function get() {
	      return 'spinner';
	    }
	  }, {
	    key: 'attributes',
	    get: function get() {
	      return {
	        'data-spinner': '',
	        'class': 'spinner-three-bounce'
	      };
	    }
	  }]);

	  function SpinnerThreeBouncePlugin(container) {
	    _classCallCheck(this, SpinnerThreeBouncePlugin);

	    var _this = _possibleConstructorReturn(this, _UIContainerPlugin.call(this, container));

	    _this.template = (0, _template2.default)(_spinner2.default);
	    _this.showTimeout = null;
	    _this.listenTo(_this.container, _events2.default.CT_STATE_BUFFERING, _this.onBuffering);
	    _this.listenTo(_this.container, _events2.default.CT_STATE_BUFFERFULL, _this.onBufferFull);
	    _this.listenTo(_this.container, _events2.default.CT_STOP, _this.onStop);
	    _this.listenTo(_this.container, _events2.default.CT_ENDED, _this.onStop);
	    _this.listenTo(_this.container, _events2.default.CT_ERROR, _this.onStop);
	    _this.render();
	    return _this;
	  }

	  SpinnerThreeBouncePlugin.prototype.onBuffering = function onBuffering() {
	    this.show();
	  };

	  SpinnerThreeBouncePlugin.prototype.onBufferFull = function onBufferFull() {
	    this.hide();
	  };

	  SpinnerThreeBouncePlugin.prototype.onStop = function onStop() {
	    this.hide();
	  };

	  SpinnerThreeBouncePlugin.prototype.show = function show() {
	    var _this2 = this;

	    if (this.showTimeout === null) {
	      this.showTimeout = setTimeout(function () {
	        return _this2.$el.show();
	      }, 300);
	    }
	  };

	  SpinnerThreeBouncePlugin.prototype.hide = function hide() {
	    if (this.showTimeout !== null) {
	      clearTimeout(this.showTimeout);
	      this.showTimeout = null;
	    }
	    this.$el.hide();
	  };

	  SpinnerThreeBouncePlugin.prototype.render = function render() {
	    this.$el.html(this.template());
	    var style = _styler2.default.getStyleFor(_spinner4.default, { customCSS: this.options.customCSS });
	    !this.options.hasAnPlayerInstance && this.container.$el.append(style);
	    this.container.$el.append(this.$el);
	    this.$el.hide();
	    if (this.container.buffering) {
	      this.onBuffering();
	    }
	    return this;
	  };

	  return SpinnerThreeBouncePlugin;
	}(_ui_container_plugin2.default);

	exports.default = SpinnerThreeBouncePlugin;
	module.exports = exports['default'];

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _utils = __webpack_require__(2);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var UIContainerPlugin = function (_UIObject) {
	    _inherits(UIContainerPlugin, _UIObject);

	    function UIContainerPlugin(container) {
	        _classCallCheck(this, UIContainerPlugin);

	        var _this = _possibleConstructorReturn(this, _UIObject.call(this, container.options));

	        _this.container = container;
	        _this.enabled = true;
	        _this.bindEvents();
	        return _this;
	    }

	    UIContainerPlugin.prototype.enable = function enable() {
	        if (!this.enabled) {
	            this.bindEvents();
	            this.$el.show();
	            this.enabled = true;
	        }
	    };

	    UIContainerPlugin.prototype.disable = function disable() {
	        this.stopListening();
	        this.$el.hide();
	        this.enabled = false;
	    };

	    UIContainerPlugin.prototype.bindEvents = function bindEvents() {};

	    UIContainerPlugin.prototype.destroy = function destroy() {
	        this.remove();
	    };

	    return UIContainerPlugin;
	}(_ui_object2.default);

	exports.default = UIContainerPlugin;


	UIContainerPlugin.extend = function (properties) {
	    return (0, _utils.extend)(UIContainerPlugin, properties);
	};

	UIContainerPlugin.type = 'container';
	module.exports = exports['default'];

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "<div data-bounce1></div><div data-bounce2></div><div data-bounce3></div>\n";

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".spinner-three-bounce[data-spinner] {\n  position: absolute;\n  margin: 0 auto;\n  width: 70px;\n  text-align: center;\n  z-index: 99999999;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n  /* center vertically */\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  -moz-transform: translateY(-50%);\n  -ms-transform: translateY(-50%);\n  -o-transform: translateY(-50%);\n  transform: translateY(-50%); }\n  .spinner-three-bounce[data-spinner] > div {\n    width: 18px;\n    height: 18px;\n    background-color: #FFFFFF;\n    border-radius: 100%;\n    display: inline-block;\n    -webkit-animation: bouncedelay 1.4s infinite ease-in-out;\n    -moz-animation: bouncedelay 1.4s infinite ease-in-out;\n    animation: bouncedelay 1.4s infinite ease-in-out;\n    /* Prevent first frame from flickering when animation starts */\n    -webkit-animation-fill-mode: both;\n    -moz-animation-fill-mode: both;\n    animation-fill-mode: both; }\n  .spinner-three-bounce[data-spinner] [data-bounce1] {\n    -webkit-animation-delay: -0.32s;\n    -moz-animation-delay: -0.32s;\n    animation-delay: -0.32s; }\n  .spinner-three-bounce[data-spinner] [data-bounce2] {\n    -webkit-animation-delay: -0.16s;\n    -moz-animation-delay: -0.16s;\n    animation-delay: -0.16s; }\n\n@-webkit-keyframes bouncedelay {\n  0%, 80%, 100% {\n    -webkit-transform: scale(0); }\n  40% {\n    -webkit-transform: scale(1); } }\n\n@-moz-keyframes bouncedelay {\n  0%, 80%, 100% {\n    -moz-transform: scale(0); }\n  40% {\n    -moz-transform: scale(1); } }\n\n@keyframes bouncedelay {\n  0%, 80%, 100% {\n    -webkit-transform: scale(0);\n    -moz-transform: scale(0);\n    -ms-transform: scale(0);\n    -o-transform: scale(0);\n    transform: scale(0); }\n  40% {\n    -webkit-transform: scale(1);\n    -moz-transform: scale(1);\n    -ms-transform: scale(1);\n    -o-transform: scale(1);\n    transform: scale(1); } }\n", ""]);

	// exports


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(108);

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _container_plugin = __webpack_require__(109);

	var _container_plugin2 = _interopRequireDefault(_container_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var REPORT_EVENT = 'clappr:stats:report';

	var StatsPlugin = function (_ContainerPlugin) {
	    _inherits(StatsPlugin, _ContainerPlugin);

	    StatsPlugin.prototype._now = function _now() {
	        return new Date();
	    };

	    StatsPlugin.prototype._inc = function _inc(counter) {
	        this._metrics.counters[counter] += 1;
	    };

	    StatsPlugin.prototype._timerHasStarted = function _timerHasStarted(timer) {
	        return this['_start' + timer] !== undefined;
	    };

	    StatsPlugin.prototype._start = function _start(timer) {
	        this['_start' + timer] = this._now();
	    };

	    StatsPlugin.prototype._stop = function _stop(timer) {
	        this._metrics.timers[timer] += this._now() - this['_start' + timer];
	    };

	    StatsPlugin.prototype._defaultReport = function _defaultReport(metrics) {}; //eslint-disable-line no-console

	    _createClass(StatsPlugin, [{
	        key: 'name',
	        get: function get() {
	            return 'clappr_stats';
	        }
	    }, {
	        key: '_playbackName',
	        get: function get() {
	            return this.container.playback.name;
	        }
	    }, {
	        key: '_playbackType',
	        get: function get() {
	            return this.container.getPlaybackType();
	        }
	    }]);

	    function StatsPlugin(container) {
	        _classCallCheck(this, StatsPlugin);

	        var _this = _possibleConstructorReturn(this, _ContainerPlugin.call(this, container));

	        if (_this.options.sources == [{ source: '', mimeType: '' }]) {
	            return _possibleConstructorReturn(_this);
	        }
	        _this._runEach = 5000;
	        _this._onReport = _this.onreport;
	        _this._isFirstLoad = true;
	        _this._isBuffering = true;
	        _this._seekLatencyHistory = [];
	        // this._playLatencyHistory = [];
	        _this._newMetrics();
	        // this._getUrlMetric();
	        _this.on(REPORT_EVENT, _this._onReport);
	        return _this;
	    }

	    StatsPlugin.prototype.onreport = function onreport(data) {};

	    StatsPlugin.prototype.get = function get(container, string, defa) {
	        container._options[string];
	    };

	    StatsPlugin.prototype.bindEvents = function bindEvents() {
	        var _this2 = this;

	        this.listenTo(this.container, _events2.default.CT_TRACKINGZDN, this._getUrlMetric);
	        this.listenTo(this.container, _events2.default.CT_SELECTLEVEL, this.onBitrate);
	        this.listenTo(this.container, _events2.default.CT_STOP, this.stopReporting);
	        this.listenTo(this.container, _events2.default.CT_ENDED, this.stopReporting);
	        this.listenToOnce(this.container.playback, _events2.default.PB_PLAY_INTENT, this.startTimers);
	        this.listenToOnce(this.container, _events2.default.CT_PLAY, this.onFirstPlaying);
	        // this.listenTo(this.container, Events.CT_LOADSTART, this.onLoadStart);
	        this.listenTo(this.container, _events2.default.CT_SEEKING, this.onSeeking);
	        this.listenTo(this.container, _events2.default.CT_CANPLAYTHROUGH, this.onCanPlayThrough);
	        this.listenTo(this.container, _events2.default.CT_WAITING, this.onWaiting);
	        this.listenTo(this.container, _events2.default.CT_PLAY, this.onPlay);
	        this.listenTo(this.container, _events2.default.CT_PAUSE, this.onPause);
	        this.listenToOnce(this.container, _events2.default.CT_STATE_BUFFERING, this.onBuffering);
	        this.listenTo(this.container, _events2.default.CT_SEEK, this.onSeek);
	        this.listenTo(this.container, _events2.default.CT_ERROR, this.onError);
	        this.listenTo(this.container, _events2.default.CT_CHECK_ONLINE, this.onCheckOnline);
	        this.listenTo(this.container, _events2.default.CT_FULLSCREEN, function () {
	            return _this2._inc('fullscreen');
	        });
	        this.listenTo(this.container, _events2.default.CT_PLAYBACKDVRSTATECHANGED, function (dvrInUse) {
	            dvrInUse && _this2._inc('dvrUsage');
	        });
	        this.listenTo(this.container.playback, _events2.default.PB_PROGRESS, this.onProgress);
	        this.listenTo(this.container.playback, _events2.default.PB_TIMEUPDATE, this.onTimeUpdate);
	        this.listenTo(this.container, _events2.default.CT_LOADED_ADS, this.onStartAd);
	    };

	    StatsPlugin.prototype.onError = function onError(event) {
	        if (!isNaN(event.error.code)) {
	            this._metrics.extra.errorDetail.push(event.error.code);
	            this._inc('error');
	        }
	    };

	    StatsPlugin.prototype.onBitrate = function onBitrate(newBitrate) {
	        var bitrate = parseInt(newBitrate);
	        var now = this._now();

	        if (this._metrics.extra.bitratesHistory.length > 0) {
	            var beforeLast = this._metrics.extra.bitratesHistory[this._metrics.extra.bitratesHistory.length - 1];
	            beforeLast.end = now;
	            beforeLast.time = now - beforeLast.start;
	        }

	        this._metrics.extra.bitratesHistory.push({ start: this._now(), bitrate: bitrate });

	        this._inc('changeLevel');
	    };

	    StatsPlugin.prototype.stopReporting = function stopReporting() {
	        this._isFirstLoad = true;
	        this._buildReport();

	        clearInterval(this._intervalId);
	        this._newMetrics();

	        this.stopListening();
	        this.bindEvents();
	    };

	    StatsPlugin.prototype.startTimers = function startTimers(time) {
	        if (this.options.offTracking) {
	            return;
	        }

	        this._timeOnStartLoad = time;
	        this._intervalId = setInterval(this._buildReport.bind(this), this._runEach);
	        if (this._isDebug()) {
	            this.statusEl = document.createElement('pre');
	            this.statusEl.innerHTML = "Stat metrics (updates each 5s)";
	            var playerEl = this.container.el.parentElement.parentElement;
	            playerEl.appendChild(this.statusEl);
	        }
	        this._start('session');
	        this._start('startup');
	    };

	    StatsPlugin.prototype.onFirstPlaying = function onFirstPlaying(e) {
	        this.listenTo(this.container, _events2.default.CT_TIMEUPDATE, this.onContainerUpdateWhilePlaying);

	        this._start('watch');
	        this._stop('startup');
	    };

	    StatsPlugin.prototype.playAfterPause = function playAfterPause() {
	        this._stop('pause');
	        this._start('watch');
	    };

	    StatsPlugin.prototype.onLoadStart = function onLoadStart(e) {
	        this._timeOnStartLoad = e.time;
	    };

	    StatsPlugin.prototype.onCanPlayThrough = function onCanPlayThrough(e) {
	        if (!this.container.playback.isPlaying()) {
	            return;
	        }
	        var timeCanPlayThroughTime = e.time;

	        if (this._isFirstLoad) {
	            this._isFirstLoad = false;
	            this._timeOnCanPlayFirstLoad = timeCanPlayThroughTime;
	        } else {
	            this._timeOnCanPlayThrough = timeCanPlayThroughTime;
	            this.trackLatencyHistory(this._isBuffering);
	        }
	    };

	    StatsPlugin.prototype.trackLatencyHistory = function trackLatencyHistory(isBuffering) {
	        if (!isBuffering) {
	            return;
	        }

	        if (this._isSeeking) {
	            this._seekLatencyHistory.push(this._timeOnCanPlayThrough - this._timeOnSeeking);
	            this._isSeeking = false;
	        } else if (this._isWaiting) {
	            var currentPlayLatency = this._timeOnCanPlayThrough - this._timeOnWaiting;
	            this._metrics.timers.playLatency += currentPlayLatency;
	            // this._playLatencyHistory.push(this._timeOnCanPlayThrough - this._timeOnWaiting);
	            this._isWaiting = false;
	        }
	    };

	    StatsPlugin.prototype.onSeeking = function onSeeking(e) {
	        this._isSeeking = true;
	        this._timeOnSeeking = e.time;
	    };

	    StatsPlugin.prototype.onCheckOnline = function onCheckOnline(e) {
	        this._metrics.extra.isOnline = e.isOnline;
	    };

	    StatsPlugin.prototype.onWaiting = function onWaiting(e) {
	        if (!this._isSeeking) {
	            this._isWaiting = true;
	            this._timeOnWaiting = e.time;
	        }
	    };

	    StatsPlugin.prototype.onPlay = function onPlay() {
	        this._inc('play');
	    };

	    StatsPlugin.prototype.onPause = function onPause() {
	        this._stop('watch');
	        this._start('pause');
	        this._inc('pause');
	        this.listenToOnce(this.container, _events2.default.CT_PLAY, this.playAfterPause);
	    };

	    StatsPlugin.prototype.onSeek = function onSeek(e) {
	        this._inc('seek');
	        this._metrics.extra.watchHistory.push([e * 1000, e * 1000]);
	    };

	    StatsPlugin.prototype.onTimeUpdate = function onTimeUpdate(e) {
	        var current = e.current * 1000,
	            total = e.total * 1000,
	            l = this._metrics.extra.watchHistory.length;

	        this._metrics.extra.duration = total;
	        this._metrics.extra.currentTime = current;

	        if (l === 0) {
	            this._metrics.extra.watchHistory.push([current, current]);
	        } else {
	            this._metrics.extra.watchHistory[l - 1][1] = current;
	        }
	    };

	    StatsPlugin.prototype.onStartAd = function onStartAd() {
	        this._startAd = true;
	    };

	    StatsPlugin.prototype.onContainerUpdateWhilePlaying = function onContainerUpdateWhilePlaying() {
	        if (this.container.playback.isPlaying()) {
	            this._stop('watch');
	            this._start('watch');
	        }
	    };

	    StatsPlugin.prototype.onBuffering = function onBuffering() {
	        this._isBuffering = true;
	        this._inc('buffering');
	        this._start('buffering');
	        this.listenToOnce(this.container, _events2.default.CT_STATE_BUFFERFULL, this.onBufferfull);
	    };

	    StatsPlugin.prototype.onBufferfull = function onBufferfull() {
	        this._isBuffering = false;
	        this._stop('buffering');
	        this.listenToOnce(this.container, _events2.default.CT_STATE_BUFFERING, this.onBuffering);
	    };

	    StatsPlugin.prototype.onProgress = function onProgress(progress) {
	        this._metrics.extra.buffersize = progress.current * 1000;
	    };

	    StatsPlugin.prototype._newMetrics = function _newMetrics() {
	        this._metrics = {
	            counters: {
	                play: 0,
	                pause: 0,
	                error: 0,
	                buffering: 0,
	                decodedFrames: 0,
	                droppedFrames: 0,
	                fps: 0,
	                changeLevel: 0,
	                seek: 0,
	                fullscreen: 0,
	                dvrUsage: 0
	            },
	            timers: {
	                startup: 0,
	                watch: 0,
	                pause: 0,
	                buffering: 0,
	                session: 0,
	                startLatency: 0,
	                seekLatency: 0,
	                playLatency: 0,
	                getSourceLatency: 0
	            },
	            extra: {
	                product: '',
	                level: '',
	                playbackName: '',
	                playbackType: '',
	                playbackRedirector: '',
	                playbackSrc: '',
	                platform: _browser2.default.isMobile ? 'webm' : 'webd',
	                zdnServer: '',
	                bitratesHistory: [],
	                bitrateMean: 0,
	                bitrateVariance: 0,
	                bitrateStandardDeviation: 0,
	                bitrateMostUsed: 0,
	                buffersize: 0,
	                errorDetail: [],
	                watchHistory: [],
	                watchedPercentage: 0,
	                bufferingPercentage: 0,
	                isOnline: true
	            }
	        };
	    };

	    StatsPlugin.prototype._getUrlMetric = function _getUrlMetric(url) {
	        this.container.trigger(_events2.default.CT_TRACKINGZDN_END, { playbackSrc: url });
	    };

	    StatsPlugin.prototype._buildReport = function _buildReport() {
	        this._stop('session');
	        this._start('session');

	        this._metrics.extra.playbackName = this._playbackName;
	        this._metrics.extra.playbackType = this._playbackType;
	        this._metrics.extra.product = this.options.product;
	        this._metrics.extra.level = this._getCurrentLevel();

	        this._calculateBitrates();
	        this._calculatePercentages();
	        this._fetchFPS();
	        this._calculateStartLatency();
	        this._calculateSeekLatency();
	        // this._calculatePlayLatency();

	        this._metrics.extra.playbackSrc = this.options.mimeType == 'application/x-mpegURL' ? this.options.source : this.container.playback.el.src;

	        if (this._isDebug()) {
	            this._buildStatHTML();
	        }

	        // this.trigger(REPORT_EVENT, JSON.parse(JSON.stringify(this._metrics)))
	        this.container.trigger(_events2.default.CT_REPORT, JSON.stringify(this._metrics));
	    };

	    StatsPlugin.prototype._buildStatHTML = function _buildStatHTML() {
	        this.statusEl.innerHTML = this._syntaxHighlight(this._metrics);
	    };

	    StatsPlugin.prototype._syntaxHighlight = function _syntaxHighlight(json) {
	        if (typeof json != 'string') {
	            json = JSON.stringify(json, undefined, 2);
	        }

	        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
	            var cls = 'number';
	            if (/^"/.test(match)) {
	                if (/:$/.test(match)) {
	                    cls = 'key';
	                } else {
	                    cls = 'string';
	                }
	            } else if (/true|false/.test(match)) {
	                cls = 'boolean';
	            } else if (/null/.test(match)) {
	                cls = 'null';
	            }
	            return '<span class="' + cls + '">' + match + '</span>';
	        });
	    };

	    StatsPlugin.prototype._getCurrentLevel = function _getCurrentLevel() {
	        var _this3 = this;

	        var level = parseInt(window.localStorage.getItem("currentLevel"));
	        var sourceLevel = this.container._options.sourceLevel;
	        if (!sourceLevel) return;

	        if (sourceLevel[level]) {
	            return sourceLevel[level].label;
	        } else {
	            var currentSource = sourceLevel.filter(function (source) {
	                return source.source == _this3.container.playback.el.src;
	            });
	            if (currentSource.length > 0) {
	                return currentSource[0].label;
	            } else {
	                return '';
	            }
	        }
	    };

	    StatsPlugin.prototype._isRedirectUrl = function _isRedirectUrl(url) {
	        var cdnPattern = 'r.za.zdn.vn';
	        return url.indexOf(cdnPattern) > -1;
	    };

	    StatsPlugin.prototype._fetchFPS = function _fetchFPS() {
	        var fetchFPS = {
	            'html5_video': this._html5FetchFPS,
	            'hls': this._html5FetchFPS,
	            'dash_shaka_playback': this._html5FetchFPS
	        };

	        fetchFPS[this._playbackName] && fetchFPS[this._playbackName].call(this);
	    };

	    StatsPlugin.prototype._calculateBitrates = function _calculateBitrates() {
	        var _this4 = this;

	        var bitrates = this._metrics.extra.bitratesHistory.map(function (x) {
	            return x.bitrate;
	        });

	        this._metrics.extra.bitrateMean = bitrates.reduce(function (a, b) {
	            return a + b;
	        }, 0) / bitrates.length;

	        this._metrics.extra.bitrateVariance = bitrates.map(function (n) {
	            return Math.pow(n - _this4._metrics.extra.bitrateMean, 2);
	        }).reduce(function (a, b) {
	            return a + b;
	        }, 0) / bitrates.length;

	        this._metrics.extra.bitrateStandardDeviation = Math.sqrt(this._metrics.extra.bitrateVariance);
	        this._metrics.extra.bitrateMostUsed = this._metrics.extra.bitratesHistory.sort(function (a, b) {
	            return a.time < b.time;
	        })[0];
	    };

	    StatsPlugin.prototype._calculatePercentages = function _calculatePercentages() {
	        if (this._metrics.extra.duration > 0) {
	            this._metrics.extra.watchedPercentage = this._metrics.timers.watch / this._metrics.extra.duration * 100;
	            this._metrics.extra.bufferingPercentage = this._metrics.timers.buffering / this._metrics.extra.duration * 100;
	        }
	    };

	    StatsPlugin.prototype._calculateStartLatency = function _calculateStartLatency() {
	        if (!this._timeOnCanPlayFirstLoad || this._timeOnCanPlayFirstLoad <= 0) {
	            return;
	        }
	        this._metrics.timers.startLatency = this._timeOnCanPlayFirstLoad - this._timeOnStartLoad;
	    };

	    StatsPlugin.prototype._calculateSeekLatency = function _calculateSeekLatency() {
	        this._metrics.timers.seekLatency = this._average(this._seekLatencyHistory);
	    };

	    // _calculatePlayLatency() {
	    //     this._metrics.timers.playLatency = this._average(this._playLatencyHistory);
	    // }

	    StatsPlugin.prototype._calculateGetSourceLatency = function _calculateGetSourceLatency(url) {
	        var _this5 = this;

	        var xmlhttp = new XMLHttpRequest();

	        xmlhttp.onreadystatechange = function () {
	            if (xmlhttp.readyState == XMLHttpRequest.DONE) {
	                if (xmlhttp.status == 200) {
	                    _this5._metrics.timers.getSourceLatency = _this5._now() - _this5._startGetSourceUrlTime;
	                    _this5._metrics.extra.playbackSrc = xmlhttp.responseURL;
	                    _this5._metrics.extra.zdnServer = xmlhttp.responseURL.split(".")[1];
	                    _this5.container.trigger(_events2.default.CT_TRACKINGZDN_END, {
	                        getSourceLatency: _this5._metrics.timers.getSourceLatency,
	                        playbackSrc: _this5._metrics.extra.playbackSrc,
	                        zdnServer: _this5._metrics.extra.zdnServer,
	                        playbackRedirector: url
	                    });
	                }
	            }
	        };

	        xmlhttp.open("GET", url, true);
	        xmlhttp.channel.QueryInterface(Components.interfaces.nsIHttpChannel).redirectionLimit = 0;
	        xmlhttp.send();
	        this._startGetSourceUrlTime = this._now();
	    };

	    StatsPlugin.prototype._average = function _average(arr) {
	        if (!arr.length) {
	            return 0;
	        }
	        return arr.reduce(function (a, b) {
	            return a + b;
	        }, 0) / arr.length;
	    };

	    StatsPlugin.prototype._isDebug = function _isDebug() {
	        if (window.localStorage) {
	            var debug = window.localStorage.getItem('zplayer-debug');
	            return debug == 'true';
	        } else {
	            return false;
	        }
	    };

	    StatsPlugin.prototype._html5FetchFPS = function _html5FetchFPS() {
	        var videoTag = this.container.playback.el;
	        var decodedFrames = videoTag.webkitDecodedFrameCount || videoTag.mozDecodedFrames || 0;
	        var droppedFrames = videoTag.webkitDroppedFrameCount || videoTag.mozParsedFrames - videoTag.mozDecodedFrames || 0;
	        var decodedFramesLastTime = decodedFrames - (this._lastDecodedFramesCount || 0);

	        this._metrics.counters.decodedFrames = decodedFrames;
	        this._metrics.counters.droppedFrames = droppedFrames;
	        this._metrics.counters.fps = decodedFramesLastTime / (this._runEach / 1000);

	        this._lastDecodedFramesCount = decodedFrames;
	    };

	    return StatsPlugin;
	}(_container_plugin2.default);

	exports.default = StatsPlugin;
	module.exports = exports['default'];

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	var _utils = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ContainerPlugin = function (_BaseObject) {
	    _inherits(ContainerPlugin, _BaseObject);

	    function ContainerPlugin(container) {
	        _classCallCheck(this, ContainerPlugin);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this, container.options));

	        _this.container = container;
	        _this.enabled = true;
	        _this.bindEvents();
	        return _this;
	    }

	    ContainerPlugin.prototype.enable = function enable() {
	        if (!this.enabled) {
	            this.bindEvents();
	            this.enabled = true;
	        }
	    };

	    ContainerPlugin.prototype.disable = function disable() {
	        if (this.enabled) {
	            this.stopListening();
	            this.enabled = false;
	        }
	    };

	    ContainerPlugin.prototype.bindEvents = function bindEvents() {};

	    ContainerPlugin.prototype.destroy = function destroy() {
	        this.stopListening();
	    };

	    return ContainerPlugin;
	}(_base_object2.default);

	exports.default = ContainerPlugin;


	ContainerPlugin.extend = function (properties) {
	    return (0, _utils.extend)(ContainerPlugin, properties);
	};

	ContainerPlugin.type = 'container';
	module.exports = exports['default'];

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(111);

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _container_plugin = __webpack_require__(109);

	var _container_plugin2 = _interopRequireDefault(_container_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ClickToPausePlugin = function (_ContainerPlugin) {
	  _inherits(ClickToPausePlugin, _ContainerPlugin);

	  _createClass(ClickToPausePlugin, [{
	    key: 'name',
	    get: function get() {
	      return 'click_to_pause';
	    }
	  }]);

	  function ClickToPausePlugin(container) {
	    _classCallCheck(this, ClickToPausePlugin);

	    return _possibleConstructorReturn(this, _ContainerPlugin.call(this, container));
	  }

	  ClickToPausePlugin.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.container, _events2.default.CT_CLICK, this.click);
	    this.listenTo(this.container, _events2.default.CT_SETTINGSUPDATE, this.settingsUpdate);
	  };

	  ClickToPausePlugin.prototype.click = function click() {
	    if (!this.options.pauseOnClick) {
	      return;
	    }

	    if (this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrEnabled()) {
	      if (this.container.isPlaying()) {
	        this.container.pause();
	      } else {
	        this.container.play();
	      }
	    }
	  };

	  ClickToPausePlugin.prototype.settingsUpdate = function settingsUpdate() {
	    this.container.$el.removeClass('pointer-enabled');
	    if (this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrEnabled()) {
	      this.container.$el.addClass('pointer-enabled');
	    }
	  };

	  return ClickToPausePlugin;
	}(_container_plugin2.default);

	exports.default = ClickToPausePlugin;
	module.exports = exports['default'];

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(113);

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _play = __webpack_require__(65);

	var _play2 = _interopRequireDefault(_play);

	var _pause = __webpack_require__(66);

	var _pause2 = _interopRequireDefault(_pause);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var oldIcon = (0, _clapprZepto2.default)('link[rel="shortcut icon"]');

	var Favicon = function (_CorePlugin) {
	  _inherits(Favicon, _CorePlugin);

	  _createClass(Favicon, [{
	    key: 'name',
	    get: function get() {
	      return 'favicon';
	    }
	  }, {
	    key: 'oldIcon',
	    get: function get() {
	      return oldIcon;
	    }
	  }]);

	  function Favicon(core) {
	    _classCallCheck(this, Favicon);

	    var _this = _possibleConstructorReturn(this, _CorePlugin.call(this, core));

	    _this._container = null;
	    _this.configure();
	    return _this;
	  }

	  Favicon.prototype.configure = function configure() {
	    if (this.core.options.changeFavicon) {
	      if (!this.enabled) {
	        this.stopListening(this.core, _events2.default.CORE_OPTIONS_CHANGE);
	        this.enable();
	      }
	    } else if (this.enabled) {
	      this.disable();
	      this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.configure);
	    }
	  };

	  Favicon.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.configure);
	    this.listenTo(this.core.mediaControl, _events2.default.MC_CONTAINERCHANGED, this.containerChanged);
	    if (this.core.mediaControl.container) {
	      this.containerChanged();
	    }
	  };

	  Favicon.prototype.containerChanged = function containerChanged() {
	    this._container && this.stopListening(this._container);
	    this._container = this.core.mediaControl.container;
	    this.listenTo(this._container, _events2.default.CT_PLAY, this.setPlayIcon);
	    this.listenTo(this._container, _events2.default.CT_PAUSE, this.setPauseIcon);
	    this.listenTo(this._container, _events2.default.CT_STOP, this.resetIcon);
	    this.listenTo(this._container, _events2.default.CT_ENDED, this.resetIcon);
	    this.listenTo(this._container, _events2.default.CT_ERROR, this.resetIcon);
	    this.resetIcon();
	  };

	  Favicon.prototype.disable = function disable() {
	    _CorePlugin.prototype.disable.call(this);
	    this.resetIcon();
	  };

	  Favicon.prototype.destroy = function destroy() {
	    _CorePlugin.prototype.destroy.call(this);
	    this.resetIcon();
	  };

	  Favicon.prototype.createIcon = function createIcon(svg) {
	    var canvas = (0, _clapprZepto2.default)('<canvas/>');
	    canvas[0].width = 16;
	    canvas[0].height = 16;
	    var ctx = canvas[0].getContext('2d');
	    ctx.fillStyle = '#000';
	    var d = (0, _clapprZepto2.default)(svg).find('path').attr('d');
	    var path = new Path2D(d);
	    ctx.fill(path);
	    var icon = (0, _clapprZepto2.default)('<link rel="shortcut icon" type="image/png"/>');
	    icon.attr('href', canvas[0].toDataURL('image/png'));
	    return icon;
	  };

	  Favicon.prototype.setPlayIcon = function setPlayIcon() {
	    if (!this.playIcon) {
	      this.playIcon = this.createIcon(_play2.default);
	    }
	    this.changeIcon(this.playIcon);
	  };

	  Favicon.prototype.setPauseIcon = function setPauseIcon() {
	    if (!this.pauseIcon) {
	      this.pauseIcon = this.createIcon(_pause2.default);
	    }
	    this.changeIcon(this.pauseIcon);
	  };

	  Favicon.prototype.resetIcon = function resetIcon() {
	    (0, _clapprZepto2.default)('link[rel="shortcut icon"]').remove();
	    (0, _clapprZepto2.default)('head').append(this.oldIcon);
	  };

	  Favicon.prototype.changeIcon = function changeIcon(icon) {
	    if (icon) {
	      (0, _clapprZepto2.default)('link[rel="shortcut icon"]').remove();
	      (0, _clapprZepto2.default)('head').append(icon);
	    }
	  };

	  return Favicon;
	}(_core_plugin2.default);

	exports.default = Favicon;
	module.exports = exports['default'];

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _utils = __webpack_require__(2);

	var _base_object = __webpack_require__(4);

	var _base_object2 = _interopRequireDefault(_base_object);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CorePlugin = function (_BaseObject) {
	    _inherits(CorePlugin, _BaseObject);

	    function CorePlugin(core) {
	        _classCallCheck(this, CorePlugin);

	        var _this = _possibleConstructorReturn(this, _BaseObject.call(this, core.options));

	        _this.core = core;
	        _this.enabled = true;
	        _this.bindEvents();
	        return _this;
	    }

	    CorePlugin.prototype.bindEvents = function bindEvents() {};

	    CorePlugin.prototype.enable = function enable() {
	        if (!this.enabled) {
	            this.bindEvents();
	            this.enabled = true;
	        }
	    };

	    CorePlugin.prototype.disable = function disable() {
	        if (this.enabled) {
	            this.stopListening();
	            this.enabled = false;
	        }
	    };

	    CorePlugin.prototype.getExternalInterface = function getExternalInterface() {
	        return {};
	    };

	    CorePlugin.prototype.destroy = function destroy() {
	        this.stopListening();
	    };

	    return CorePlugin;
	}(_base_object2.default);

	exports.default = CorePlugin;


	CorePlugin.extend = function (properties) {
	    return (0, _utils.extend)(CorePlugin, properties);
	};

	CorePlugin.type = 'core';
	module.exports = exports['default'];

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(116);

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _ui_core_plugin = __webpack_require__(117);

	var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _seek_time = __webpack_require__(118);

	var _seek_time2 = _interopRequireDefault(_seek_time);

	var _seek_time3 = __webpack_require__(119);

	var _seek_time4 = _interopRequireDefault(_seek_time3);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2014 Globo.com Player authors. All rights reserved.
	// Use of this source code is governed by a BSD-style
	// license that can be found in the LICENSE file.

	var SeekTime = function (_UICorePlugin) {
	    _inherits(SeekTime, _UICorePlugin);

	    _createClass(SeekTime, [{
	        key: 'name',
	        get: function get() {
	            return 'seek_time';
	        }
	    }, {
	        key: 'template',
	        get: function get() {
	            return (0, _template2.default)(_seek_time4.default);
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return {
	                'class': 'seek-time',
	                'data-seek-time': ''
	            };
	        }
	    }, {
	        key: 'mediaControl',
	        get: function get() {
	            return this.core.mediaControl;
	        }
	    }, {
	        key: 'mediaControlContainer',
	        get: function get() {
	            return this.mediaControl.container;
	        }
	    }, {
	        key: 'isLiveStreamWithDvr',
	        get: function get() {
	            return this.mediaControlContainer && this.mediaControlContainer.getPlaybackType() === _playback2.default.LIVE && this.mediaControlContainer.isDvrEnabled();
	        }
	    }, {
	        key: 'durationShown',
	        get: function get() {
	            return this.isLiveStreamWithDvr && !this.useActualLiveTime;
	        }
	    }, {
	        key: 'useActualLiveTime',
	        get: function get() {
	            return this.actualLiveTime && this.isLiveStreamWithDvr;
	        }
	    }]);

	    function SeekTime(core) {
	        _classCallCheck(this, SeekTime);

	        var _this = _possibleConstructorReturn(this, _UICorePlugin.call(this, core));

	        _this.hoveringOverSeekBar = false;
	        _this.hoverPosition = null;
	        _this.duration = null;
	        _this.actualLiveTime = !!_this.mediaControl.options.actualLiveTime;
	        if (_this.actualLiveTime) {
	            if (_this.mediaControl.options.actualLiveServerTime) {
	                _this.actualLiveServerTimeDiff = new Date().getTime() - new Date(_this.mediaControl.options.actualLiveServerTime).getTime();
	            } else {
	                _this.actualLiveServerTimeDiff = 0;
	            }
	        }
	        return _this;
	    }

	    SeekTime.prototype.bindEvents = function bindEvents() {
	        this.listenTo(this.mediaControl, _events2.default.MC_RENDERED, this.render);
	        this.listenTo(this.mediaControl, _events2.default.MC_MOUSEMOVE_SEEKBAR, this.showTime);
	        this.listenTo(this.mediaControl, _events2.default.MC_MOUSELEAVE_SEEKBAR, this.hideTime);
	        this.listenTo(this.mediaControl, _events2.default.MC_CONTAINERCHANGED, this.onContainerChanged);
	        this.listenTo(this.mediaControl, _events2.default.MC_HIDE, this.onMediaControlHide);

	        if (this.mediaControlContainer) {
	            this.listenTo(this.mediaControlContainer, _events2.default.CT_PLAYBACKDVRSTATECHANGED, this.update);
	            this.listenTo(this.mediaControlContainer, _events2.default.CT_TIMEUPDATE, this.updateDuration);
	        }
	    };

	    SeekTime.prototype.onContainerChanged = function onContainerChanged() {
	        this.stopListening();
	        this.bindEvents();
	    };

	    SeekTime.prototype.onMediaControlHide = function onMediaControlHide() {
	        this.hideTime();
	    };

	    SeekTime.prototype.updateDuration = function updateDuration(timeProgress) {
	        this.duration = timeProgress.total;
	        this.update();
	    };

	    SeekTime.prototype.showTime = function showTime(event) {
	        this.hoveringOverSeekBar = true;
	        this.calculateHoverPosition(event);
	        this.update();
	    };

	    SeekTime.prototype.hideTime = function hideTime() {
	        this.hoveringOverSeekBar = false;
	        this.update();
	    };

	    SeekTime.prototype.calculateHoverPosition = function calculateHoverPosition(event) {
	        var offset = event.pageX - this.mediaControl.$seekBarContainer.offset().left;
	        // proportion into the seek bar that the mouse is hovered over 0-1
	        this.hoverPosition = Math.min(1, Math.max(offset / this.mediaControl.$seekBarContainer.width(), 0));
	    };

	    SeekTime.prototype.getSeekTime = function getSeekTime() {
	        var seekTime = void 0,
	            secondsSinceMidnight = void 0;
	        if (this.useActualLiveTime) {
	            var d = new Date(new Date().getTime() - this.actualLiveServerTimeDiff),
	                e = new Date(d);
	            secondsSinceMidnight = (e - d.setHours(0, 0, 0, 0)) / 1000;
	            seekTime = secondsSinceMidnight - this.duration + this.hoverPosition * this.duration;
	            if (seekTime < 0) {
	                seekTime += 86400;
	            }
	        } else {
	            seekTime = this.hoverPosition * this.duration;
	        }
	        return { seekTime: seekTime, secondsSinceMidnight: secondsSinceMidnight };
	    };

	    SeekTime.prototype.update = function update() {
	        if (!this.rendered) {
	            // update() is always called after a render
	            return;
	        }
	        if (!this.shouldBeVisible()) {
	            this.$el.hide();
	            this.$el.css('left', '-100%');
	        } else {
	            var seekTime = this.getSeekTime();
	            var currentSeekTime = (0, _utils.formatTime)(seekTime.seekTime, this.useActualLiveTime);
	            // only update dom if necessary, ie time actually changed
	            if (currentSeekTime !== this.displayedSeekTime) {
	                this.$seekTimeEl.text(currentSeekTime);
	                this.displayedSeekTime = currentSeekTime;
	            }

	            if (this.durationShown) {
	                this.$durationEl.show();
	                var currentDuration = (0, _utils.formatTime)(this.actualLiveTime ? seekTime.secondsSinceMidnight : this.duration, this.actualLiveTime);
	                if (currentDuration !== this.displayedDuration) {
	                    this.$durationEl.text(currentDuration);
	                    this.displayedDuration = currentDuration;
	                }
	            } else {
	                this.$durationEl.hide();
	            }

	            // the element must be unhidden before its width is requested, otherwise it's width will be reported as 0
	            this.$el.show();
	            var containerWidth = this.mediaControl.$seekBarContainer.width();
	            var elWidth = this.$el.width();
	            var elLeftPos = this.hoverPosition * containerWidth;
	            elLeftPos -= elWidth / 2;
	            elLeftPos = Math.max(0, Math.min(elLeftPos, containerWidth - elWidth));
	            this.$el.css('left', elLeftPos);
	        }
	    };

	    SeekTime.prototype.shouldBeVisible = function shouldBeVisible() {
	        return this.mediaControlContainer && this.mediaControlContainer.settings.seekEnabled && this.hoveringOverSeekBar && this.hoverPosition !== null && this.duration !== null;
	    };

	    SeekTime.prototype.render = function render() {
	        if (_browser2.default.isMobile) {
	            return;
	        }

	        this.rendered = true;
	        this.displayedDuration = null;
	        this.displayedSeekTime = null;
	        var style = _styler2.default.getStyleFor(_seek_time2.default);
	        this.$el.html(this.template());
	        !this.options.hasAnPlayerInstance && this.$el.append(style);
	        this.$el.hide();
	        this.mediaControl.$el.append(this.el);
	        this.$seekTimeEl = this.$el.find('[data-seek-time]');
	        this.$durationEl = this.$el.find('[data-duration]');
	        this.$durationEl.hide();
	        this.update();
	    };

	    return SeekTime;
	}(_ui_core_plugin2.default);

	exports.default = SeekTime;
	module.exports = exports['default'];

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _utils = __webpack_require__(2);

	var _ui_object = __webpack_require__(18);

	var _ui_object2 = _interopRequireDefault(_ui_object);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var UICorePlugin = function (_UIObject) {
	    _inherits(UICorePlugin, _UIObject);

	    function UICorePlugin(core) {
	        _classCallCheck(this, UICorePlugin);

	        var _this = _possibleConstructorReturn(this, _UIObject.call(this, core.options));

	        _this.core = core;
	        _this.enabled = true;
	        _this.bindEvents();
	        _this.render();
	        return _this;
	    }

	    UICorePlugin.prototype.bindEvents = function bindEvents() {};

	    UICorePlugin.prototype.getExternalInterface = function getExternalInterface() {
	        return {};
	    };

	    UICorePlugin.prototype.enable = function enable() {
	        if (!this.enabled) {
	            this.bindEvents();
	            this.$el.show();
	            this.enabled = true;
	        }
	    };

	    UICorePlugin.prototype.disable = function disable() {
	        this.stopListening();
	        this.$el.hide();
	        this.enabled = false;
	    };

	    UICorePlugin.prototype.destroy = function destroy() {
	        this.remove();
	    };

	    UICorePlugin.prototype.render = function render() {
	        return this;
	    };

	    return UICorePlugin;
	}(_ui_object2.default);

	exports.default = UICorePlugin;


	UICorePlugin.extend = function (properties) {
	    return (0, _utils.extend)(UICorePlugin, properties);
	};

	UICorePlugin.type = 'core';
	module.exports = exports['default'];

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".seek-time[data-seek-time] {\n  position: absolute;\n  white-space: nowrap;\n  height: 20px;\n  line-height: 20px;\n  font-size: 0;\n  left: -100%;\n  bottom: 55px;\n  background-color: rgba(2, 2, 2, 0.5);\n  z-index: 9999;\n  -webkit-transition: opacity 0.1s ease;\n  -moz-transition: opacity 0.1s ease;\n  transition: opacity 0.1s ease; }\n  .seek-time[data-seek-time].hidden[data-seek-time] {\n    opacity: 0; }\n  .seek-time[data-seek-time] [data-seek-time] {\n    display: inline-block;\n    color: white;\n    font-size: 10px;\n    padding-left: 7px;\n    padding-right: 7px;\n    vertical-align: top; }\n  .seek-time[data-seek-time] [data-duration] {\n    display: inline-block;\n    color: #000;\n    opacity: 0.6;\n    font-size: 10px;\n    padding-right: 7px;\n    vertical-align: top; }\n    .seek-time[data-seek-time] [data-duration]:before {\n      content: \"|\";\n      margin-right: 7px; }\n", ""]);

	// exports


/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = "<span data-seek-time></span>\n<span data-duration></span>\n";

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SourcesPlugin = function (_CorePlugin) {
	  _inherits(SourcesPlugin, _CorePlugin);

	  function SourcesPlugin() {
	    _classCallCheck(this, SourcesPlugin);

	    return _possibleConstructorReturn(this, _CorePlugin.apply(this, arguments));
	  }

	  SourcesPlugin.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.core, _events2.default.CORE_CONTAINERS_CREATED, this.onContainersCreated);
	  };

	  SourcesPlugin.prototype.onContainersCreated = function onContainersCreated() {
	    var firstValidSource = (0, _arrayPrototype2.default)(this.core.containers, function (container) {
	      return container.playback.name !== 'no_op';
	    }) || this.core.containers[0];
	    if (firstValidSource) {
	      this.core.containers.forEach(function (container) {
	        if (container !== firstValidSource) {
	          container.destroy();
	        }
	      });
	    }
	  };

	  _createClass(SourcesPlugin, [{
	    key: 'name',
	    get: function get() {
	      return 'sources';
	    }
	  }]);

	  return SourcesPlugin;
	}(_core_plugin2.default);

	exports.default = SourcesPlugin;
	module.exports = exports['default'];

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	var _utils = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EndVideo = function (_CorePlugin) {
	  _inherits(EndVideo, _CorePlugin);

	  function EndVideo() {
	    _classCallCheck(this, EndVideo);

	    return _possibleConstructorReturn(this, _CorePlugin.apply(this, arguments));
	  }

	  EndVideo.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.core.mediaControl, _events2.default.MC_CONTAINERCHANGED, this.containerChanged);
	    var container = this.core.getCurrentContainer();
	    if (container) {
	      this.listenTo(container, _events2.default.CT_ENDED, this.ended);
	      this.listenTo(container, _events2.default.CT_STOP, this.ended);
	    }
	  };

	  EndVideo.prototype.containerChanged = function containerChanged() {
	    this.stopListening();
	    this.bindEvents();
	  };

	  EndVideo.prototype.ended = function ended() {
	    var exitOnEnd = typeof this.core.options.exitFullscreenOnEnd === 'undefined' || this.core.options.exitFullscreenOnEnd;
	    if (exitOnEnd && _utils.Fullscreen.isFullscreen()) {
	      this.core.toggleFullscreen();
	    }
	  };

	  _createClass(EndVideo, [{
	    key: 'name',
	    get: function get() {
	      return 'end_video';
	    }
	  }]);

	  return EndVideo;
	}(_core_plugin2.default);

	exports.default = EndVideo;
	module.exports = exports['default'];

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(2);

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var assign = Object.assign || __webpack_require__(86);

	var Strings = function (_CorePlugin) {
	  _inherits(Strings, _CorePlugin);

	  _createClass(Strings, [{
	    key: 'name',
	    get: function get() {
	      return 'strings';
	    }
	  }]);

	  function Strings(core) {
	    _classCallCheck(this, Strings);

	    var _this = _possibleConstructorReturn(this, _CorePlugin.call(this, core));

	    _this._initializeMessages();
	    return _this;
	  }

	  Strings.prototype.t = function t(key) {
	    var lang = this._language();
	    var i18n = lang && this._messages[lang] || this._messages['en'];
	    return i18n[key] || key;
	  };

	  Strings.prototype._language = function _language() {
	    return this.core.options.language || (0, _utils.getBrowserLanguage)();
	  };

	  Strings.prototype._initializeMessages = function _initializeMessages() {
	    this._messages = assign({
	      'en': {
	        'live': 'live',
	        'back_to_live': 'back to live',
	        'has_license': 'Sorry, this content is not available right now.',
	        'playback_not_supported': 'Trình duyệt này chưa được hỗ trợ. Vui lòng sử dụng Chrome hoặc Cốc Cốc để nhận được trải nghiệm tốt nhất.'
	      }
	    }, this.core.options.strings || {});

	    this._messages['en-US'] = this._messages['en'];
	  };

	  return Strings;
	}(_core_plugin2.default);

	exports.default = Strings;
	module.exports = exports['default'];

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core_plugin = __webpack_require__(114);

	var _core_plugin2 = _interopRequireDefault(_core_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var assign = Object.assign || __webpack_require__(86);

	var PlaylistPlugin = function (_CorePlugin) {
	  _inherits(PlaylistPlugin, _CorePlugin);

	  function PlaylistPlugin() {
	    _classCallCheck(this, PlaylistPlugin);

	    return _possibleConstructorReturn(this, _CorePlugin.apply(this, arguments));
	  }

	  PlaylistPlugin.prototype.bindEvents = function bindEvents() {
	    if (this.options.playlist) {
	      this.listenToOnce(this.core, _events2.default.CORE_CONTAINERS_CREATED, this._containersCreated);
	      this.listenTo(this.core.mediaControl, _events2.default.MC_CONTAINERCHANGED, this._bindContainerEvents);
	      this.core.getCurrentContainer() && this._bindContainerEvents();
	    }
	  };

	  PlaylistPlugin.prototype._onPlayItem = function _onPlayItem(trackObj) {
	    this.trackObj = trackObj;

	    var level = window.localStorage.getItem("currentLevel") || 0;
	    var realUrl = trackObj.playbackSrc;
	    this.currentItem.source = realUrl;
	  };

	  PlaylistPlugin.prototype.loadPlaylistItem = function loadPlaylistItem(index) {
	    var _this2 = this;

	    var autoPlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (index >= 0 && index < this.items.length) {
	      this.currentIndex = index;
	      var level = window.localStorage.getItem("currentLevel") || 0;
	      if (this.currentItem.sourceLevel) {
	        if (!this.currentItem.sourceLevel[level] || !this.currentItem.sourceLevel[level].source) {
	          level = 0;
	        }
	        if (this.currentItem.sourceLevel[level]) {
	          this.currentItem.source = this.currentItem.sourceLevel[level].source;
	        } else {
	          this.currentItem.source = '';
	        }
	      } else {}

	      // tracking first
	      this.currentItem.autoPlay = autoPlay || false;

	      this.core.configure(this.currentItem);
	      if (this._container) {
	        this._container.trigger(_events2.default.CT_PLAYITEM, this.currentIndex);
	      }

	      if (this.nextTimeout) {
	        clearTimeout(this.nextTimeout);
	      }
	      if (this.currentItem.sourceLevel) {
	        if (!this.currentItem.sourceLevel[level]) {
	          this.nextTimeout = setTimeout(function () {
	            _this2.next();
	          }, 5000);
	          setTimeout(function () {
	            _this2.core.trigger(_events2.default.CORE_CANTPLAY);
	          }, 100);
	        } else {
	          this.startTracking(this.currentItem);
	        }
	      } else {
	        this.startTracking(this.currentItem);
	      }
	    }
	  };

	  PlaylistPlugin.prototype.startTracking = function startTracking(item) {
	    var _this3 = this;

	    if (this.options.offTracking) {
	      return;
	    }

	    if (item) {
	      this.sendLog();
	      this.data = {
	        userAgent: navigator.userAgent,
	        fromUrl: window.location.href,
	        repeatTime: 0,
	        playTimeInSecond: 0,
	        duration: 0
	      };
	      if (this.trackingTimer) {
	        clearInterval(this.trackingTimer);
	      }
	      this.trackingTimer = setInterval(function () {
	        _this3.tracking();
	      }, 5000);
	    }
	  };

	  PlaylistPlugin.prototype.sendLog = function sendLog() {
	    for (var key in window.localStorage) {
	      if (key.indexOf("zplayertrk") !== -1) {
	        var data = JSON.parse(window.localStorage.getItem(key));
	        if (data) {
	          var url = 'https://zplayer-trk.zdn.vn/track?userAgent=' + encodeURIComponent(data.userAgent) + '&fromUrl=' + encodeURIComponent(data.fromUrl) + '&repeatTime=' + data.repeatTime + '&playTimeInSecond=' + data.playTimeInSecond + '&duration=' + data.duration + '&params=' + encodeURIComponent(data.params);
	          var xmlhttp = new XMLHttpRequest();
	          xmlhttp.open("GET", url, true);
	          xmlhttp.send();
	        }
	        window.localStorage.removeItem(key);
	      }
	    }
	  };

	  PlaylistPlugin.prototype.tracking = function tracking() {
	    if (this._container.playback.el.src != window.location.href) {
	      var key = this._container.playback.el.src;
	      this.data.playTimeInSecond += 3;
	      this.data.duration = this._container.getDuration();
	      var localData = window.localStorage.getItem("zplayertrk-" + key);
	      var saveData = {};
	      if (localData) {
	        saveData = JSON.parse(localData);
	      }
	      assign(saveData, this.data);
	      window.localStorage.setItem("zplayertrk-" + key, JSON.stringify(saveData));
	    }
	  };

	  PlaylistPlugin.prototype._bindContainerEvents = function _bindContainerEvents() {
	    var container = this.core.getCurrentContainer();
	    if (this._container) {
	      this.stopListening(this._container);
	    }
	    this._container = container;
	    this.playMode = this.options.loop ? 0 : 1;
	    this.listenTo(container, _events2.default.CT_ENDED, this._ended);
	    this.listenTo(container, _events2.default.CT_NEXT, this.next);
	    this.listenTo(container, _events2.default.CT_PREV, this.prev);
	    // this.listenTo(container, Events.CT_PAUSE, this.stop);
	    this.listenTo(container, _events2.default.CT_STOP, this.stop);
	    this.listenTo(container, _events2.default.CT_PLAY, this.play);
	    !this.options.offTracking && this.listenTo(container, _events2.default.CT_REPORT, this.onreport);
	  };

	  PlaylistPlugin.prototype.onreport = function onreport(data) {
	    this.data.params = data;
	  };

	  PlaylistPlugin.prototype.play = function play() {
	    var _this4 = this;

	    if (this.data) {
	      if (this.trackingTimer) {
	        clearInterval(this.trackingTimer);
	      }
	      this.trackingTimer = setInterval(function () {
	        _this4.tracking();
	      }, 5000);
	    }
	  };

	  PlaylistPlugin.prototype.stop = function stop() {
	    if (this.trackingTimer) {
	      clearInterval(this.trackingTimer);
	    }
	  };

	  PlaylistPlugin.prototype._containersCreated = function _containersCreated() {
	    if (this.options.sources) {
	      this.loadPlaylistItem(0, this.options.autoPlay);
	    }
	  };

	  PlaylistPlugin.prototype._ended = function _ended() {
	    if (this.options.playerType == 'song') {
	      this.playMode = window.localStorage.getItem("playmodesong");

	      if (!this.playMode) {
	        this.playMode = 1;
	      }

	      if (!this.options.loop) {
	        if (this.playMode == 0) {
	          this.loadPlaylistItem(this.currentIndex, true);
	        } else if (this.playMode == 1) {
	          // do nothing
	        }
	      } else {
	        this.loadPlaylistItem(this.currentIndex, true);
	      }
	    } else if (this.options.playerType == 'album') {
	      this.playMode = window.localStorage.getItem("playmode");
	      if (!this.playMode) {
	        this.playMode = 0;
	      }

	      if (this.playMode == 0) {
	        this.next();
	      } else if (this.playMode == 1) {
	        var index = this.getNextShuffleIndex();
	        this.loadPlaylistItem(index, true);
	      } else if (this.playMode == 2) {
	        if (this.currentIndex < this.items.length - 1) {
	          this.currentIndex += 1;
	          this.loadPlaylistItem(this.currentIndex, true);
	        }
	      } else if (this.playMode == 3) {
	        this.loadPlaylistItem(this.currentIndex, true);
	      }
	    } else {
	      if (!this.options.loop) {
	        return;
	      } else {
	        this.loadPlaylistItem(this.currentIndex, true);
	      }
	    }
	  };

	  PlaylistPlugin.prototype.next = function next() {
	    if (this.options.playerType !== 'song') {
	      this.playMode = window.localStorage.getItem("playmode");
	      if (!this.playMode) {
	        this.playMode = 0;
	      }

	      if (this.playMode == 1) {
	        this.currentIndex = this.getNextShuffleIndex();
	      } else {
	        this.increaseIndex();
	      }
	      this.loadPlaylistItem(this.currentIndex, true);
	    }
	  };

	  PlaylistPlugin.prototype.prev = function prev() {
	    this.playMode = window.localStorage.getItem("playmode");
	    if (!this.playMode) {
	      this.playMode = 0;
	    }

	    var currentTime = this._container.playback.getCurrentTime();

	    // If currentTime is equal or less than 5s, we will change to another song
	    if (currentTime <= 5) {
	      if (this.playMode == 1) {
	        this.currentIndex = this.getNextShuffleIndex();
	      } else {
	        this.decreaseIndex();
	      }
	    }

	    this.loadPlaylistItem(this.currentIndex, true);
	  };

	  PlaylistPlugin.prototype.increaseIndex = function increaseIndex() {
	    if (this.currentIndex < this.items.length - 1) {
	      this.currentIndex += 1;
	    } else {
	      this.currentIndex = 0;
	    }
	  };

	  PlaylistPlugin.prototype.decreaseIndex = function decreaseIndex() {
	    if (this.currentIndex > 0) {
	      this.currentIndex -= 1;
	    } else {
	      this.currentIndex = this.items.length - 1;
	    }
	  };

	  PlaylistPlugin.prototype.getNextShuffleIndex = function getNextShuffleIndex() {
	    var index = this.getRandomIndex();
	    if (index === this.currentIndex) {
	      index = this.getRandomIndex();
	    }
	    return index;
	  };

	  PlaylistPlugin.prototype.getRandomIndex = function getRandomIndex() {
	    var indexArray = this.indexArr;
	    if (!indexArray.length) {
	      this.resetIndexArr();
	    }
	    var index = Math.floor(Math.random() * this.indexArray.length);
	    var nextIndex = indexArray[index];
	    this.indexArray.splice(index, 1);
	    return nextIndex;
	  };

	  PlaylistPlugin.prototype.resetIndexArr = function resetIndexArr() {
	    for (var i = 0; i < this.items.length; i++) {
	      this.indexArray.push(i);
	    }
	  };

	  PlaylistPlugin.prototype.playItem = function playItem(index) {
	    this.currentIndex = index;
	    this.loadPlaylistItem(this.currentIndex, true);
	  };

	  _createClass(PlaylistPlugin, [{
	    key: 'name',
	    get: function get() {
	      return 'playlist';
	    }
	  }, {
	    key: 'items',
	    get: function get() {
	      return this.options.playlist;
	    }
	  }, {
	    key: 'currentItem',
	    get: function get() {
	      return this.items[this.currentIndex];
	    }
	  }, {
	    key: 'currentIndex',
	    get: function get() {
	      return this._currentIndex || (this._currentIndex = 0);
	    },
	    set: function set(index) {
	      if (index >= 0 && index < this.items.length) {
	        this._currentIndex = index;
	      }
	    }
	  }, {
	    key: 'indexArr',
	    get: function get() {
	      return this.indexArray || (this.indexArray = []);
	    }
	  }], [{
	    key: 'version',
	    get: function get() {
	      return ("0.0.1");
	    }
	  }]);

	  return PlaylistPlugin;
	}(_core_plugin2.default);

	exports.default = PlaylistPlugin;
	module.exports = exports['default'];

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(125);

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _ui_core_plugin = __webpack_require__(117);

	var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _vast = __webpack_require__(126);

	var _vast2 = _interopRequireDefault(_vast);

	var _vast3 = __webpack_require__(127);

	var _vast4 = _interopRequireDefault(_vast3);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _utils = __webpack_require__(2);

	var _clapprZepto = __webpack_require__(16);

	var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

	var _core = __webpack_require__(129);

	var _core2 = _interopRequireDefault(_core);

	var _vastacular = __webpack_require__(135);

	var _play = __webpack_require__(65);

	var _play2 = _interopRequireDefault(_play);

	var _pause = __webpack_require__(66);

	var _pause2 = _interopRequireDefault(_pause);

	var _volumeHigh = __webpack_require__(69);

	var _volumeHigh2 = _interopRequireDefault(_volumeHigh);

	var _mute = __webpack_require__(70);

	var _mute2 = _interopRequireDefault(_mute);

	var _fullscreen = __webpack_require__(71);

	var _fullscreen2 = _interopRequireDefault(_fullscreen);

	var _exitFullscreen = __webpack_require__(72);

	var _exitFullscreen2 = _interopRequireDefault(_exitFullscreen);

	var _utils2 = __webpack_require__(2);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _imaLoader = __webpack_require__(178);

	var _imaLoader2 = _interopRequireDefault(_imaLoader);

	var _arrayPrototype = __webpack_require__(26);

	var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// VAST


	// Media Control Icons


	// Utils


	var VastPlugin = function (_UICorePlugin) {
	  _inherits(VastPlugin, _UICorePlugin);

	  _createClass(VastPlugin, [{
	    key: "waitingText",
	    get: function get() {
	      return 'Bỏ qua quảng cáo sau ';
	    }
	  }, {
	    key: "skipText",
	    get: function get() {
	      return 'Bỏ qua';
	    }
	  }, {
	    key: "durationText",
	    get: function get() {
	      return 'Bỏ qua quảng cáo sau ';
	    }
	  }, {
	    key: "loadingAdText",
	    get: function get() {
	      return 'Đang tải quảng cáo...';
	    }
	  }, {
	    key: "viewDetailText",
	    get: function get() {
	      return 'Xem chi tiết quảng cáo';
	    }
	  }, {
	    key: "name",
	    get: function get() {
	      return 'vast_ad';
	    }
	  }, {
	    key: "template",
	    get: function get() {
	      return (0, _template2.default)(_vast2.default);
	    }
	  }, {
	    key: "attributes",
	    get: function get() {
	      return {
	        'class': this.name,
	        'data-vast_ad': ''
	      };
	    }
	  }, {
	    key: "events",
	    get: function get() {
	      return {
	        'click': 'onClickVideoAd',
	        'click .skip-ad-container': 'skipLinearAd',
	        'click .zp-view-detail': 'showDetail',
	        'click [data-playpause]': 'togglePausePlayAd',
	        'click [data-fullscreen]': 'toggleFullScreen',
	        'click .drawer-icon[data-volume]': 'toggleMute'
	      };
	    }
	  }], [{
	    key: "version",
	    get: function get() {
	      return ("0.0.1");
	    }
	  }]);

	  function VastPlugin(container) {
	    _classCallCheck(this, VastPlugin);

	    var _this = _possibleConstructorReturn(this, _UICorePlugin.call(this, container));

	    _this.shouldRenderAd = true;
	    window.addEventListener('buildUserInfo', function (e) {
	      if (window.MP3 && (window.MP3.VIP == 1 || window.MP3.BANNER_OFF)) {
	        _this.shouldRenderAd = false;
	      }
	    }, false);

	    _this.prerollAds = [];
	    _this.middleAds = [];
	    _this.postrollAds = [];
	    _this.currentTime = 0;
	    _this.currentPrerollIndex = 0;
	    _this.currentAdMode = 2;
	    _this.isAdPaused = false;
	    _this.clickedVideoAd = false;

	    // Load IMA
	    _this._imaIsloaded = false;
	    _this._imaLoadResult = false;
	    _this._pluginIsReady = false;
	    _this._autostart = true;
	    _this._events = {};
	    _this.imaLoadTimeout = _this.options.imaLoadTimeout > 0 ? _this.options.imaLoadTimeout : 6000;

	    _this.settings = {
	      left: ['playpause', 'position'],
	      right: ['fullscreen', 'volume'],
	      default: ['seekbar']
	    };

	    _this.currentPositionValue = null;

	    _this.getCurrentAdMode();

	    if (_this.options.ads && _this.currentAdMode != 0) {
	      _this.fetchAdsData();
	      // this.fetchPauseAdData();
	    }

	    _this.isRendering = false;
	    window.addEventListener('resize', _this.onWindowResize);

	    return _this;
	  }

	  // Listen user action to play mobile ad first


	  VastPlugin.prototype.onClickVideoAd = function onClickVideoAd() {
	    if (!this.isIMA && !this.clickedVideoAd && _browser2.default.isMobile) {
	      console.log('on click video ad');
	      this.player.startAd();

	      // For "autoplay" purpose
	      this.core.getCurrentPlayback().play();

	      // Show ad layout
	      this.$el.show();
	      this.clickedVideoAd = true;
	      this.$el.css('opacity', 1);
	      this.$vpaidLayer && this.$vpaidLayer.css('display', 'block');
	      this.core.mediaControl.hide();
	      this.core.getCurrentPlayback().pause();

	      // Start play mobile ad
	    }
	  };

	  VastPlugin.prototype.getCurrentAdMode = function getCurrentAdMode() {
	    var currentAdMode = window.localStorage.getItem("currentAdMode");
	    var isVip = this.options.isVip;

	    this.currentAdMode = currentAdMode ? currentAdMode : 2;
	    if (currentAdMode == 0 && !isVip) {
	      this.currentAdMode = 1;
	    }
	  };

	  VastPlugin.prototype.fetchAdsData = function fetchAdsData() {
	    var _this2 = this;

	    var uri = this.currentAdMode == 1 ? this.options.ads.interruptSource : this.options.ads.nonInterruptSource;
	    if (!uri) return;

	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', uri, true);
	    xhr.withCredentials = true;
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState == XMLHttpRequest.DONE) {
	        if (xhr.status == 200) {
	          if (xhr.responseText) {
	            var data = JSON.parse(xhr.responseText);
	            data.ads.schedule.forEach(function (ad) {
	              _this2.populateAd(ad);
	            });
	            if (_browser2.default.isMobile) {
	              _this2.renderPreRollAd();
	            }
	          }
	        }
	      }
	    };

	    xhr.send();
	  };

	  VastPlugin.prototype.fetchPauseAdData = function fetchPauseAdData() {
	    var _this3 = this;

	    var pauseSourceUri = this.options.ads.pauseSource;
	    if (pauseSourceUri) {
	      _clapprZepto2.default.ajax({
	        type: "GET",
	        url: pauseSourceUri,
	        dataType: "xml",
	        success: function success(xmlData) {
	          if (xmlData && xmlData.documentElement) {
	            var vast = new _vastacular.VAST(_vastacular.VAST.pojoFromXML(new XMLSerializer().serializeToString(xmlData.documentElement)));
	            _this3.core.getCurrentContainer().trigger(_events2.default.CT_LOADED_PAUSE_AD, { vast: vast });
	          }
	        }
	      });
	    }
	  };

	  VastPlugin.prototype.populateAd = function populateAd(ad) {
	    if (ad.position === 'pre-roll') {
	      this.prerollAds.push(ad);
	    } else if (ad.position === 'post-roll') {
	      this.postrollAds.push(ad);
	    } else {
	      this.middleAds.push(ad);
	    }
	  };

	  VastPlugin.prototype.setSeekPercentage = function setSeekPercentage(value) {
	    if (this.currentSeekBarPercentage === value) {
	      // not changed since last update
	      return;
	    }
	    this.currentSeekBarPercentage = value;

	    this.$seekBarPosition.removeClass('media-control-notransition');
	    this.$seekBarScrubber.removeClass('media-control-notransition');
	    this.$seekBarPosition.css({ width: value + "%" });
	    this.$seekBarScrubber.css({ left: value + "%" });
	  };

	  VastPlugin.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.core, _events2.default.CORE_READY, this.bindPlaybackEvents);
	  };

	  VastPlugin.prototype.bindPlaybackEvents = function bindPlaybackEvents() {
	    this.listenTo(this.core.getCurrentPlayback(), _events2.default.PB_CANPLAYTHROUGH, this.renderPreRollAd);
	    this.listenTo(this.core.getCurrentContainer(), _events2.default.CT_PAUSE_AD, this.pauseAd);
	    this.listenTo(this.core.getCurrentContainer(), _events2.default.CT_PLAY_AD, this.playAd);
	  };

	  VastPlugin.prototype.createCachedElements = function createCachedElements() {
	    this.$layer = this.$el.find('.media-control-layer');

	    // IMA elements
	    if (this.isIMA) {
	      if (this._$adContainer == undefined) {
	        this._$adContainer = (0, _clapprZepto2.default)("<div />").addClass("ima-container").attr('data-ima', '');
	        this._$clickOverlay = (0, _clapprZepto2.default)("<div />").addClass("preroll-overlay").attr('data-preroll', '');
	        this.core.$el.append(this._$adContainer);
	        this.core.$el.append(this._$clickOverlay);
	        this._adContainer = this._$adContainer[0];
	        this._clickOverlay = this._$clickOverlay[0];
	      } else {
	        this._$adContainer.show();
	      }
	    }

	    // Adtima elements
	    this.$seekBarContainer = this.$layer.find('.bar-container[data-seekbar]');
	    this.$seekBarHover = this.$layer.find('.bar-hover[data-seekbar]');
	    this.$seekBarLoaded = this.$layer.find('.bar-fill-1[data-seekbar]');
	    this.$seekBarPosition = this.$layer.find('.bar-fill-2[data-seekbar]');
	    this.$seekBarScrubber = this.$layer.find('.bar-scrubber[data-seekbar]');
	    this.$duration = this.$layer.find('.media-control-indicator[data-duration]');
	    this.$skipAdText = this.$layer.find('.skip-ad');
	    this.$skipadContainer = this.$layer.find('.skip-ad-container');
	    this.$adProgressContainer = this.$layer.find('.zp-ad-progress');
	    this.$adProgress = this.$layer.find('.zp-ad-progress-text');
	    this.$poster = this.$layer.find('#zp-poster-img');
	    this.$viewDetail = this.$layer.find('.zp-view-detail-text');

	    // Media Control Icons
	    this.$playPauseToggle = this.$layer.find('button.media-control-button[data-playpause]');
	    this.$fullscreenToggle = this.$layer.find('button.media-control-button[data-fullscreen]');
	    this.$volumeIcon = this.$layer.find('.drawer-icon[data-volume]');
	    this.$position = this.$layer.find('.media-control-indicator[data-position]');
	    this.$adProgressContainer.css('display', 'none');
	    this.initializeIcons();
	  };

	  VastPlugin.prototype.initializeIcons = function initializeIcons() {
	    this.$playPauseToggle.append(_pause2.default);
	    this.$fullscreenToggle.append(_fullscreen2.default);
	    this.$volumeIcon.append(_volumeHigh2.default);
	  };

	  VastPlugin.prototype.shouldRenderPreRollAd = function shouldRenderPreRollAd() {
	    return this.shouldRenderAd && this.prerollAds.length > 0 && this.currentPrerollIndex < this.prerollAds.length && !this.isRendering;
	  };

	  VastPlugin.prototype.renderPreRollAd = function renderPreRollAd() {
	    if (this.shouldRenderPreRollAd()) {
	      if (this.prerollAds[this.currentPrerollIndex]) {
	        this.renderAd(this.prerollAds[this.currentPrerollIndex].server.tag);
	      }
	      this.currentPrerollIndex++;
	    } else {
	      this.currentPrerollIndex = Infinity;
	      this.core.getCurrentContainer().trigger(_events2.default.CT_FINISH_PREROLL_AD);
	    }

	    return this;
	  };

	  VastPlugin.prototype.isIMAAd = function isIMAAd(adSystem) {
	    return adSystem.indexOf('Google') !== -1 || adSystem.indexOf('google') !== -1;
	  };

	  VastPlugin.prototype.adjustMobileLayout = function adjustMobileLayout() {
	    // Hide MC of Ad on mobile
	    if (_browser2.default.isMobile) {
	      this.$layer.find('div [data-media-control]').hide();
	      this.$layer.find('div [data-background]').hide();
	      this.$skipadContainer.css('top', -30);
	    }
	  };

	  VastPlugin.prototype.renderAd = function renderAd(xmlData) {
	    this.isRendering = true;

	    this.$el.html(this.template({
	      settings: this.settings
	    }));

	    this.$el.append(_styler2.default.getStyleFor(_vast4.default, { baseUrl: this.options.baseUrl }));
	    this.currentTime = this.core.getCurrentPlayback().getCurrentTime();
	    var vast = new _vastacular.VAST(_vastacular.VAST.pojoFromXML(xmlData));

	    this.createCachedElements();
	    this.adjustMobileLayout();

	    // Detect 'IMA Ad' or 'Adtima Ad'
	    this.isIMA = this.isIMAAd(vast.ads[0].system.name);
	    this.isIMA ? this.playIMAAd(vast) : this.playAdtimaAd(vast, xmlData);
	  };

	  VastPlugin.prototype.playIMAAd = function playIMAAd(vast) {
	    var _this4 = this;

	    this.IMAImpression = vast.ads[0].impressions[0].uri;
	    this.IMATrackingEvents = vast.ads[0].creatives[0].trackingEvents;
	    this.core.mediaControl.hide();
	    this._imaTag = vast.ads[0].vastAdTagURI;
	    this.core.getCurrentContainer().trigger(_events2.default.CT_LOADING_AD);

	    (0, _imaLoader2.default)(function (result) {
	      _this4._imaLoadResult = result;
	      _this4._imaIsloaded = true;
	      _this4._initImaSDK();
	    }, true, this.imaLoadTimeout);
	  };

	  VastPlugin.prototype.playAdtimaAd = function playAdtimaAd(vast, xmlData) {
	    console.log('play adtima ad');

	    var adType = vast.get('ads[0].creatives[0].type');

	    switch (adType) {
	      case 'linear':
	        {
	          this.core.mediaControl.hide();
	          this.core.getCurrentPlayback().pause();
	          this.$skipAdText.hide();
	          this.core.getCurrentContainer().trigger(_events2.default.CT_LOADING_AD);
	          this.playLinearAd(xmlData);
	          break;
	        }
	      case 'nonLinear':
	        {
	          this.playNonLinearAd(vast);
	          break;
	        }
	      default:
	        {
	          this.isRendering = false;
	          this.core.mediaControl.show();
	          this.core.getCurrentPlayback().seek(this.currentTime);
	          this.core.getCurrentPlayback().play();
	        }
	    }
	  };

	  VastPlugin.prototype._initImaSDK = function _initImaSDK() {
	    if (!this._imaIsloaded) {
	      console.error('Can\'t load IMA SDK.');
	      this._playVideoContent();
	      return;
	    }

	    // Skip ad scenario if IMA SDK is not successfully loaded
	    // May happen if user has ad blocker, or Google server unavailable
	    if (!this._imaLoadResult) {
	      console.log('Can not load IMA SDK successfully');
	      this._playVideoContent();
	      return;
	    }

	    google.ima.settings.setLocale('vi');
	    this._createAdDisplayContainer();
	    this._requestAd();
	  };

	  VastPlugin.prototype._createAdDisplayContainer = function _createAdDisplayContainer() {
	    this._createImaContainer();
	    this._playback = this.core.getCurrentPlayback();
	    this._contentElement = this._playback.el;
	    google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.INSECURE);
	    this._adDisplayContainer = new google.ima.AdDisplayContainer(this._imaContainer, this._contentElement);
	  };

	  VastPlugin.prototype._requestAd = function _requestAd() {
	    var _this5 = this;

	    var adsLoader = new google.ima.AdsLoader(this._adDisplayContainer);

	    // Listen to ADS_MANAGER_LOADED event
	    adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function (e) {
	      _this5._onAdsManagerLoaded(e);
	    });

	    // Listen to AD_ERROR event
	    adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function (e) {
	      _this5._onAdError(e);
	    });

	    var adsRequest = new google.ima.AdsRequest();
	    adsRequest.adTagUrl = this._imaTag;

	    adsRequest.linearAdSlotWidth = this._contentElement.offsetWidth;
	    adsRequest.linearAdSlotHeight = this._contentElement.offsetHeight;
	    adsRequest.nonLinearAdSlotWidth = this._contentElement.offsetWidth;
	    adsRequest.nonLinearAdSlotHeight = this._contentElement.offsetHeight;

	    // requestAds() trigger _onAdsManagerLoaded() or _onAdError()
	    adsLoader.requestAds(adsRequest);
	  };

	  VastPlugin.prototype._onAdsManagerLoaded = function _onAdsManagerLoaded(adsManagerLoadedEvent) {
	    var _this6 = this;

	    var adsRenderingSettings = new google.ima.AdsRenderingSettings();

	    // This could also set to false and ensure playback state is restored
	    adsRenderingSettings.restoreCustomPlaybackStateOnAdBreakComplete = true;

	    this._adsManager = adsManagerLoadedEvent.getAdsManager(this._contentElement, adsRenderingSettings);

	    this._adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function (e) {
	      _this6._onAdError(e);
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, function () {
	      _this6._imaEvent('content_resume_requested');
	      _this6._playVideoContent();
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, function () {
	      _this6._imaEvent('content_pause_requested');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.LOADED, function () {
	      _this6._imaEvent('loaded');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.CLICK, function () {
	      _this6._imaEvent('click');
	      _this6.sendAdtimaEvent('click');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.IMPRESSION, function () {
	      _this6._imaEvent('impression');
	      _clapprZepto2.default.get(_this6.IMAImpression);
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.STARTED, function () {
	      _this6._imaEvent('started');
	      _this6.core.mediaControl.hide();
	      _this6.sendAdtimaEvent('creativeView');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.FIRST_QUARTILE, function () {
	      _this6._imaEvent('first_quartile');
	      _this6.sendAdtimaEvent('firstQuartile');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.MIDPOINT, function () {
	      _this6._imaEvent('midpoint');
	      _this6.sendAdtimaEvent('midpoint');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.THIRD_QUARTILE, function () {
	      _this6._imaEvent('third_quartile');
	      _this6.sendAdtimaEvent('thirdQuartile');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, function () {
	      _this6._imaEvent('complete');
	      _this6.sendAdtimaEvent('complete');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.PAUSED, function () {
	      _this6._imaEvent('paused');
	      _this6.sendAdtimaEvent('pause');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.RESUMED, function () {
	      _this6._imaEvent('resumed');
	      _this6.sendAdtimaEvent('resume');
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.SKIPPED, function () {
	      _this6._imaEvent('skipped');
	      _this6.sendAdtimaEvent('skip');
	      _this6._playVideoContent();
	    });

	    this._adsManager.addEventListener(google.ima.AdEvent.Type.USER_CLOSE, function () {
	      _this6._imaEvent('user_close');
	      _this6.sendAdtimaEvent('skip');
	      _this6._playVideoContent();
	    });

	    this.setupOverlay();
	  };

	  VastPlugin.prototype.setupOverlay = function setupOverlay() {
	    var _this7 = this;

	    if (_browser2.default.isMobile) {
	      (function () {
	        var startAd = function startAd(e) {
	          _this7.core.getCurrentPlayback().play();
	          // Remove current event listener
	          try {
	            _this7._clickOverlay.removeEventListener('click', startAd, false);
	            _this7._clickOverlay.removeEventListener('touch', startAd, false);
	            e.preventDefault();
	            e.stopPropagation();
	          } catch (err) {
	            console.error(err);
	          }

	          // Hide overlay and start playing ads
	          _this7.core.mediaControl.hide();
	          _this7._$clickOverlay.hide();

	          // Play Ads
	          _this7.core.getCurrentPlayback().pause();
	          _this7._playAds();
	        };

	        _this7._clickOverlay.addEventListener('click', startAd, false);
	        _this7._clickOverlay.addEventListener('touch', startAd, false);
	      })();
	    } else {
	      this._$clickOverlay.hide();
	      this._playAds();
	    }
	  };

	  VastPlugin.prototype.onWindowResize = function onWindowResize() {
	    if (this._adsManager) {
	      this._adsManager.resize(this._contentElement.offsetWidth, this._contentElement.offsetHeight, google.ima.ViewMode.NORMAL);
	    }
	  };

	  VastPlugin.prototype.sendAdtimaEvent = function sendAdtimaEvent(eventName) {
	    var event = (0, _arrayPrototype2.default)(this.IMATrackingEvents, function (e) {
	      return e.event == eventName;
	    });
	    if (event) {
	      _clapprZepto2.default.get(event.uri);
	    }
	  };

	  VastPlugin.prototype._playAds = function _playAds() {
	    this.core.getCurrentContainer().trigger(_events2.default.CT_START_LINEAR_AD, { type: 'ad' });
	    this.core.getCurrentContainer().disableMediaControl();
	    this.core.mediaControl.hide();
	    this.core.getCurrentPlayback().pause();
	    this._adDisplayContainer.initialize();

	    try {
	      this._adsManager.init(this._contentElement.offsetWidth, this._contentElement.offsetHeight, google.ima.ViewMode.NORMAL);
	      this._adsManager.start();
	    } catch (e) {
	      this._imaEvent('error', e);
	      this._playVideoContent();
	    }
	  };

	  VastPlugin.prototype._imaEvent = function _imaEvent(eventName, e) {
	    _clapprZepto2.default.isFunction(this._events[eventName]) && this._events[eventName](e);
	  };

	  VastPlugin.prototype._onAdError = function _onAdError(adErrorEvent) {
	    // google.ima.AdErrorEvent : https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdErrorEvent
	    // google.ima.AdError : https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdError
	    console.log('google.ima.AdErrorEvent: ', adErrorEvent);
	    this._playVideoContent();
	  };

	  VastPlugin.prototype._playVideoContent = function _playVideoContent() {
	    this.isRendering = false;
	    if (this.shouldRenderPreRollAd()) {
	      this._$adContainer.hide();
	      this._destroyImaContainer();
	      this.renderPreRollAd();
	    } else {
	      this.core.getCurrentContainer().trigger(_events2.default.CT_FINISH_LINEAR_AD);
	      this.core.mediaControl.show();
	      this.core.getCurrentPlayback().seek(this.currentTime);
	      this.core.getCurrentPlayback().play();

	      // Hide PreRoll overlay and Destroy IMA Container
	      this._$clickOverlay.hide();
	      this._$adContainer.hide();
	      this._destroyImaContainer();
	    }
	  };

	  VastPlugin.prototype._createImaContainer = function _createImaContainer() {
	    this._destroyImaContainer();

	    // IMA does not clean ad container when finished
	    // For the sake of simplicity, wrap into a <div> element
	    if (this._adContainer) {
	      this._imaContainer = document.createElement('div');
	      this._imaContainer.setAttribute('id', 'imaAd');
	      this._adContainer.appendChild(this._imaContainer);
	    }
	  };

	  VastPlugin.prototype._destroyImaContainer = function _destroyImaContainer() {
	    if (this._imaContainer && this._adContainer) {
	      this._adContainer.removeChild(this._imaContainer);
	      delete this._imaContainer;
	    }
	  };

	  VastPlugin.prototype.playNonLinearAd = function playNonLinearAd(vast) {
	    this.core.getCurrentContainer().trigger(_events2.default.CT_START_NON_LINEAR_AD, { vast: vast });
	    this.$el.hide();
	    this.isRendering = false;
	  };

	  VastPlugin.prototype.getAdSkipOffset = function getAdSkipOffset() {
	    if (this.player) {
	      return this.player.__private__.vast.ads[0].creatives[0].skipOffset;
	    } else {
	      return 0;
	    }
	  };

	  VastPlugin.prototype.playLinearAd = function playLinearAd(xmlData) {
	    var _this8 = this;

	    console.log('playLinear Ad');

	    this.player = new _core2.default(this.$el[0]);
	    // this.player.on('AdClickBackground', () => this.adjustPlayPauseIcon());

	    // Hide main media control and show ad layout
	    this.core.getCurrentContainer().disableMediaControl();
	    this.$el.css('opacity', 0);

	    this.core.$el.append(this.el);

	    // Start loading ad
	    this.player.load(this.getUri(xmlData)).then(function () {
	      if (_this8.options.mute) {
	        _this8.toggleMute();
	      }

	      _this8.core.getCurrentContainer().trigger(_events2.default.CT_START_LINEAR_AD, { type: 'ad' });
	      _this8.adSkipOffset = (0, _utils.convertToSecond)(_this8.getAdSkipOffset());
	      _this8.player.on('AdStopped', function () {
	        return _this8.onAdStopped();
	      });

	      if (!_browser2.default.isMobile) {
	        _this8.$el.css('opacity', 1);
	        _this8.player.startAd();
	      }
	      _this8.showLinearAdLayout();
	    }).catch(function (error) {
	      console.log('There are errors while loading ad: ', error);
	      _this8.onAdError();
	    });
	  };

	  VastPlugin.prototype.showLinearAdLayout = function showLinearAdLayout() {
	    this.$duration.html(this.loadingAdText);

	    if (!_browser2.default.isMobile) {
	      this.core.mediaControl.hide();
	    } else {
	      this.$vpaidLayer = this.$el.find('iframe');
	      this.$vpaidLayer && this.$vpaidLayer.css('display', 'none');
	    }

	    this.core.getCurrentPlayback().pause();
	    this.updateSeekBar();
	  };

	  VastPlugin.prototype.onAdError = function onAdError() {
	    this.isRendering = false;
	    this.$el.hide();
	    this.core.mediaControl.show();
	    this.core.getCurrentPlayback().play();
	  };

	  VastPlugin.prototype.onAdStopped = function onAdStopped() {
	    this.$el.hide();
	    this.core.getCurrentContainer().trigger(_events2.default.CT_FINISH_LINEAR_AD);
	    this.core.getCurrentContainer().enableMediaControl();
	    this.isRendering = false;
	    clearInterval(this.timer);
	    if (this.shouldRenderPreRollAd()) {
	      this.renderPreRollAd();
	    } else {
	      this.core.getCurrentPlayback().seek(this.currentTime);
	      this.core.getCurrentPlayback().play();
	    }
	  };

	  VastPlugin.prototype.skipLinearAd = function skipLinearAd() {
	    if (this.$skipadContainer.hasClass('skipable')) {
	      this.core.getCurrentContainer().trigger(_events2.default.CT_FINISH_LINEAR_AD);
	      this.$el.hide();
	      this.core.getCurrentContainer().enableMediaControl();
	      this.player.stopAd(true);
	      this.core.getCurrentPlayback().seek(this.currentTime);
	      this.core.getCurrentPlayback().play();
	      this.isRendering = false;
	      clearInterval(this.timer);
	      clearTimeout(this.stopTimer);
	      if (this.shouldRenderPreRollAd()) {
	        this.renderPreRollAd();
	      }
	    }
	  };

	  VastPlugin.prototype.showDetail = function showDetail() {
	    this.player.emit('AdClickThru', null, null, true);
	  };

	  VastPlugin.prototype.togglePausePlayAd = function togglePausePlayAd() {
	    this.isAdPaused ? this.player.resumeAd() : this.player.pauseAd();
	    this.isAdPaused = !this.isAdPaused;
	    this.adjustPlayPauseIcon();
	  };

	  VastPlugin.prototype.playAd = function playAd() {
	    if (this.isIMA) {
	      this._adsManager && this._adsManager.resume();
	    } else {
	      this.player && this.player.resumeAd();
	    }
	  };

	  VastPlugin.prototype.pauseAd = function pauseAd() {
	    if (this.isIMA) {
	      this._adsManager && this._adsManager.pause();
	    } else {
	      this.player && this.player.pauseAd();
	    }
	  };

	  VastPlugin.prototype.adjustPlayPauseIcon = function adjustPlayPauseIcon() {
	    if (_browser2.default.isMobile && !this.clickedVideoAd) {
	      return;
	    }

	    this.$playPauseToggle.html('');

	    if (this.player.paused) {
	      this.$playPauseToggle.append(_play2.default);
	    } else {
	      this.$playPauseToggle.append(_pause2.default);
	    }
	  };

	  VastPlugin.prototype.toggleMute = function toggleMute() {
	    this.$volumeIcon.html('');

	    if (this.player.adVolume === 0) {
	      // ON
	      this.player.adVolume = 1;
	      this.$volumeIcon.append(_volumeHigh2.default);
	    } else {
	      // OFF
	      this.player.adVolume = 0;
	      this.$volumeIcon.append(_mute2.default);
	    }
	  };

	  VastPlugin.prototype.toggleFullScreen = function toggleFullScreen() {
	    this.$fullscreenToggle.html('');
	    if (!_utils2.Fullscreen.isFullscreen()) {
	      this.$fullscreenToggle.append(_exitFullscreen2.default);
	    } else {
	      this.$fullscreenToggle.append(_fullscreen2.default);
	    }
	    this.core.toggleFullscreen();
	  };

	  VastPlugin.prototype.updateSeekBar = function updateSeekBar() {
	    var _this9 = this;

	    this.timer = setInterval(function () {
	      var player = _this9.player;
	      var percent = (player.adDuration - player.adRemainingTime) / player.adDuration * 100;
	      _this9.$position.text((0, _utils2.formatTime)(player.adDuration - player.adRemainingTime));

	      _this9.setSeekPercentage(percent);
	      _this9.updateText();
	    }, 100);
	  };

	  VastPlugin.prototype.updateText = function updateText() {
	    var player = this.player;
	    this.$adProgressContainer.css('display', 'none');

	    if (this.options.poster) {
	      var poster = this.options.poster || this.options.poster.url;
	      this.$poster.attr('src', poster);
	    } else {
	      this.$poster.hide();
	      (0, _clapprZepto2.default)('.ad-progress-text').css('padding-bottom', 55);
	    }

	    this.$viewDetail.html(this.viewDetailText);
	    this.$skipAdText.show();

	    if (this.currentPrerollIndex <= this.prerollAds.length) {
	      this.$adProgress.html('Xem video sau ' + (this.prerollAds.length - this.currentPrerollIndex + 1) + ' quảng cáo');
	    } else {
	      this.$adProgress.hide();
	    }

	    if (isNaN(this.adSkipOffset)) {
	      this.adSkipOffset = player.adDuration;
	    }

	    var skipLeft = Math.round(this.adSkipOffset - (player.adDuration - player.adRemainingTime));
	    if (skipLeft >= 0) {
	      this.$skipAdText.html(this.waitingText + skipLeft + 's');
	    } else {
	      this.$skipAdText.html(this.skipText);
	      this.$skipadContainer.addClass('skipable');
	    }
	  };

	  VastPlugin.prototype.getUri = function getUri(xmlData) {
	    var data = new Blob([xmlData], {
	      type: "text/xml;charset=utf-8;"
	    });

	    return window.URL.createObjectURL(data);
	  };

	  return VastPlugin;
	}(_ui_core_plugin2.default);

	exports.default = VastPlugin;
	module.exports = exports["default"];

/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = "<div class=\"media-control-background\" data-background></div>\n<div class=\"media-control-layer\" data-controls>\n    <%  var renderBar = function(name) { %>\n    <div class=\"bar-container\" data-<%= name %>>\n    <div class=\"bar-background\" data-<%= name %>>\n    <div class=\"bar-fill-1\" data-<%= name %>></div>\n<div class=\"bar-fill-2\" data-<%= name %>></div>\n<!--<div class=\"bar-hover\" data-<%= name %>></div>-->\n</div>\n<div class=\"bar-scrubber\" data-<%= name %>>\n<!--<div class=\"bar-scrubber-icon\" data-<%= name %>></div>-->\n</div>\n</div>\n<%  }; %>\n<%  var renderSegmentedBar = function(name, segments) {\nsegments = segments || 10; %>\n<div class=\"bar-container\" data-<%= name %>>\n<% for (var i = 0; i < segments; i++) { %>\n<div class=\"segmented-bar-element\" data-<%= name %>></div>\n<% } %>\n</div>\n<% }; %>\n\n<div class=\"zp-view-detail\">\n    <div class=\"zp-view-detail-text\"></div>\n    <div class=\"zp-view-detail-icon\"></div>\n</div>\n\n<div class=\"zp-ad-progress\">\n    <div class=\"zp-ad-progress-text-container\">\n        <div style=\"display: table\">\n            <div class=\"zp-ad-progress-text\" style=\"display: table-cell\">\n\n            </div>\n        </div>\n    </div>\n    <div class=\"zp-poster\">\n        <img id=\"zp-poster-img\" alt=\"Poster\"\n             height=\"100%\"/>\n    </div>\n</div>\n\n<div class=\"skip-ad-container\">\n    <div class=\"skip-ad\">\n    </div>\n</div>\n\n<% var renderDrawer = function(name, renderContent) { %>\n<div class=\"drawer-container\" data-<%= name %>>\n<div class=\"drawer-icon-container\" data-<%= name %>>\n<div class=\"drawer-icon media-control-icon\" data-<%= name %>>\n<span class=\"zm-hv-tooltip\"></span>\n</div>\n<span class=\"drawer-text\" data-<%= name %>></span>\n</div>\n<!--<% renderContent(name); %>-->\n</div>\n<% }; %>\n\n<% var renderIndicator = function(name) { %>\n<div class=\"media-control-indicator\" data-<%= name %>></div>\n<% }; %>\n\n<% var renderButton = function(name) {\nif (name === \"setting\") {\nrenderSetting(name);\n} else if (name === 'cc') {\nrenderSubTitleSetting(name);\n} else {%>\n<button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %>>\n<span class=\"zm-hv-tooltip\"></span>\n</button>\n<% }\n}; %>\n\n<%  var templates = {\nbar: renderBar,\nsegmentedBar: renderSegmentedBar,\n};\nvar render = function(settingsList) {\nsettingsList.forEach(function(setting) {\nif(setting === \"seekbar\") {\nrenderBar(setting);\n} else if (setting === \"volume\") {\nrenderDrawer(setting, settings.volumeBarTemplate ?\n    templates[settings.volumeBarTemplate] :\n    function(name) { return renderSegmentedBar(name); });\n} else if (setting === \"duration\" || setting === \"position\") {\nrenderIndicator(setting);\n} else {\nrenderButton(setting);\n}\n});\n}; %>\n<% if (settings.default && settings.default.length) { %>\n<div class=\"media-control-center-panel\" data-media-control>\n    <% render(settings.default); %>\n</div>\n<% } %>\n<% if (settings.left && settings.left.length) { %>\n<div class=\"media-control-left-panel\" data-media-control>\n    <% render(settings.left); %>\n</div>\n<% } %>\n<% if (settings.right && settings.right.length) { %>\n<div class=\"media-control-right-panel\" data-media-control>\n    <% render(settings.right); %>\n</div>\n<% } %>\n</div>\n";

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".media-control-notransition {\n  -webkit-transition: none !important;\n  -moz-transition: none !important;\n  transition: none !important; }\n\n.vast_ad[data-vast_ad] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 99999999 !important; }\n  .vast_ad[data-vast_ad] video {\n    background: #000;\n    z-index: 0; }\n  .vast_ad[data-vast_ad] .media-control-background[data-background] {\n    position: absolute;\n    height: 20%;\n    width: 100%;\n    bottom: 0;\n    background: -webkit-linear-gradient(transparent, black);\n    background: linear-gradient(transparent, black);\n    -webkit-transition: opacity 0.2s ease-out;\n    -moz-transition: opacity 0.2s ease-out;\n    transition: opacity 0.2s ease-out; }\n  .vast_ad[data-vast_ad] .zp-view-detail {\n    position: fixed;\n    font-size: 13px;\n    z-index: 10;\n    top: 18px;\n    right: 19px;\n    color: white;\n    cursor: pointer; }\n    .vast_ad[data-vast_ad] .zp-view-detail .zp-view-detail-text {\n      position: absolute;\n      right: 16px;\n      top: -1px;\n      display: inline-block;\n      vertical-align: center;\n      height: 20px;\n      width: 150px; }\n    .vast_ad[data-vast_ad] .zp-view-detail .zp-view-detail-icon {\n      background: url(" + __webpack_require__(128) + ") no-repeat;\n      display: inline-block;\n      padding: 10px;\n      height: 14px;\n      width: 14px;\n      opacity: .75; }\n  .vast_ad[data-vast_ad] .zp-ad-progress {\n    position: absolute;\n    background: rgba(0, 0, 0, 0.6);\n    left: 20px;\n    top: -80px;\n    z-index: 10;\n    height: 60px;\n    padding: 0;\n    color: #fff;\n    font-size: 13.5px; }\n    .vast_ad[data-vast_ad] .zp-ad-progress .zp-ad-progress-text-container {\n      display: inline-block;\n      vertical-align: middle;\n      padding-right: 6px;\n      padding-left: 6px; }\n    .vast_ad[data-vast_ad] .zp-ad-progress .zp-ad-progress-text {\n      padding-bottom: 50px; }\n    .vast_ad[data-vast_ad] .zp-ad-progress .zp-poster {\n      display: inline-block;\n      height: 100%;\n      padding: 0; }\n  .vast_ad[data-vast_ad] .skip-ad-container {\n    position: absolute;\n    display: table;\n    background: rgba(0, 0, 0, 0.6);\n    font-size: 12px;\n    z-index: 10;\n    top: -90px;\n    vertical-align: middle;\n    right: 12px;\n    height: 40px;\n    border-radius: 5px;\n    color: #fff; }\n  .vast_ad[data-vast_ad] .skip-ad {\n    padding-left: 12px;\n    padding-right: 12px;\n    display: table-cell;\n    vertical-align: middle; }\n  .vast_ad[data-vast_ad] .skip-ad-container.skipable {\n    font-size: 12px;\n    max-width: 170px;\n    height: 40px;\n    cursor: pointer; }\n  .vast_ad[data-vast_ad] .poster-image {\n    width: 100%;\n    height: 100%; }\n  .vast_ad[data-vast_ad] .media-control-icon {\n    line-height: 0;\n    letter-spacing: 0;\n    speak: none;\n    color: white;\n    opacity: 1;\n    vertical-align: middle;\n    text-align: left;\n    cursor: pointer;\n    -webkit-transition: all 0.1s ease;\n    -moz-transition: all 0.1s ease;\n    transition: all 0.1s ease; }\n  .vast_ad[data-vast_ad] .media-control-icon:hover {\n    color: white;\n    opacity: 0.75;\n    text-shadow: rgba(255, 255, 255, 0.8) 0 0 5px; }\n  .vast_ad[data-vast_ad].media-control-hide .media-control-background[data-background] {\n    opacity: 0; }\n  .vast_ad[data-vast_ad].media-control-hide .media-control-layer[data-controls] {\n    bottom: -50px; }\n    .vast_ad[data-vast_ad].media-control-hide .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n      opacity: 0; }\n  .vast_ad[data-vast_ad] .media-control-layer[data-controls] {\n    z-index: 10;\n    position: absolute;\n    bottom: 7px;\n    width: 100%;\n    height: 32px;\n    font-size: 0;\n    vertical-align: middle; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-left-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      left: 4px;\n      height: 100%; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-center-panel[data-media-control] {\n      height: 100%;\n      text-align: center;\n      line-height: 32px; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-right-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      right: 4px;\n      height: 100%; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button {\n      background-color: transparent;\n      border: 0;\n      margin: 0 6px;\n      padding: 0;\n      display: inline-block;\n      width: 32px;\n      height: 100%; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button svg {\n        height: 42px;\n        top: -6px;\n        position: relative;\n        left: -8px; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button svg path {\n          fill: white; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button svg:hover path {\n        fill: #fff; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button:focus {\n        outline: none; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-play] {\n        float: left;\n        height: 100%; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-pause] {\n        float: left;\n        height: 100%; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-stop] {\n        float: left;\n        height: 100%; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-fullscreen] {\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator] {\n        cursor: default;\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%;\n        display: none; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled {\n          opacity: 1.0;\n          display: block; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled:hover {\n            opacity: 1.0;\n            text-shadow: none; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-playpause] {\n        float: left; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] button.media-control-button[data-playstop] {\n        float: left; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-indicator[data-position], .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      display: inline-block;\n      font-size: 13px;\n      color: white;\n      cursor: default;\n      line-height: 32px;\n      position: relative; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .media-control-indicator[data-position] {\n      margin: 0 6px 0 7px; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] {\n      position: absolute;\n      top: -20px;\n      left: 0;\n      display: inline-block;\n      vertical-align: middle;\n      width: 100%;\n      height: 25px; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] {\n        width: 100%;\n        height: 4px;\n        position: relative;\n        top: 12px;\n        background-color: #666666; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-1[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #c2c2c2;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #ffec00;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0;\n          position: absolute;\n          top: -3px;\n          width: 5px;\n          height: 7px;\n          background-color: rgba(255, 255, 255, 0.5);\n          -webkit-transition: opacity 0.1s ease;\n          -moz-transition: opacity 0.1s ease;\n          transition: opacity 0.1s ease; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n        opacity: 1; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled {\n        cursor: default; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n        position: absolute;\n        -webkit-transform: translateX(-50%);\n        -moz-transform: translateX(-50%);\n        -ms-transform: translateX(-50%);\n        -o-transform: translateX(-50%);\n        transform: translateX(-50%);\n        top: 2px;\n        left: 0;\n        width: 20px;\n        height: 20px;\n        opacity: 1;\n        -webkit-transition: all 0.1s ease-out;\n        -moz-transition: all 0.1s ease-out;\n        transition: all 0.1s ease-out; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] .bar-scrubber-icon[data-seekbar] {\n          position: absolute;\n          left: 6px;\n          top: 8px;\n          width: 8px;\n          height: 8px;\n          box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n          background-color: white; }\n    .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] {\n      float: right;\n      display: inline-block;\n      height: 32px;\n      margin: 0 6px;\n      box-sizing: border-box; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] {\n        float: left;\n        bottom: 0; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] {\n          background-color: transparent;\n          cursor: pointer;\n          border: 0;\n          box-sizing: content-box;\n          width: 32px;\n          height: 32px;\n          opacity: 1; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume]:hover {\n            opacity: 0.75; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg {\n            height: 38px;\n            position: relative;\n            top: -3px;\n            left: -5px; }\n            .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg path {\n              fill: white; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume].muted svg {\n            margin-left: 2px; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg:hover path {\n            fill: #fff; }\n      .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] {\n        float: left;\n        position: relative;\n        overflow: hidden;\n        top: 6px;\n        width: 42px;\n        height: 18px;\n        padding: 3px 0;\n        -webkit-transition: width 0.2s ease-out;\n        -moz-transition: width 0.2s ease-out;\n        transition: width 0.2s ease-out; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] {\n          height: 1px;\n          position: relative;\n          top: 7px;\n          margin: 0 3px;\n          background-color: #666666; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-1[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #ffec00;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-2[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #ffec00;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-hover[data-volume] {\n            opacity: 0;\n            position: absolute;\n            top: -3px;\n            width: 5px;\n            height: 7px;\n            background-color: rgba(255, 255, 255, 0.5);\n            -webkit-transition: opacity 0.1s ease;\n            -moz-transition: opacity 0.1s ease;\n            transition: opacity 0.1s ease; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] {\n          position: absolute;\n          -webkit-transform: translateX(-50%);\n          -moz-transform: translateX(-50%);\n          -ms-transform: translateX(-50%);\n          -o-transform: translateX(-50%);\n          transform: translateX(-50%);\n          top: 0px;\n          left: 0;\n          width: 20px;\n          height: 20px;\n          opacity: 1;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] .bar-scrubber-icon[data-volume] {\n            position: absolute;\n            left: 6px;\n            top: 6px;\n            width: 8px;\n            height: 8px;\n            border-radius: 10px;\n            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n            background-color: white; }\n        .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume] {\n          float: left;\n          width: 4px;\n          padding-left: 2px;\n          height: 12px;\n          opacity: 0.5;\n          box-shadow: inset 2px 0 0 white;\n          -webkit-transition: -webkit-transform 0.2s ease-out;\n          -moz-transition: -moz-transform 0.2s ease-out;\n          transition: transform 0.2s ease-out; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume].fill {\n            box-shadow: inset 2px 0 0 #fff;\n            opacity: 1; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:nth-of-type(1) {\n            padding-left: 0; }\n          .vast_ad[data-vast_ad] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:hover {\n            -webkit-transform: scaleY(0.5);\n            -moz-transform: scaleY(0.5);\n            -ms-transform: scaleY(0.5);\n            -o-transform: scaleY(0.5);\n            transform: scaleY(0.5); }\n  .vast_ad[data-vast_ad].w320 .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume].volume-bar-hide {\n    width: 0;\n    height: 12px;\n    top: 9px;\n    padding: 0; }\n", ""]);

	// exports


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a290c3e675ecc4e15ff87a68ee564c99.png";

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(130);

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var EventEmitter = __webpack_require__(131).EventEmitter;
	var inherits = __webpack_require__(132).inherits;
	var VAST = __webpack_require__(135).VAST;
	var JavaScriptVPAIDPlayer = __webpack_require__(158);
	var FlashVPAIDPlayer = __webpack_require__(165);
	var HTMLVideoPlayer = __webpack_require__(170);
	var MIME = __webpack_require__(163);
	var EVENTS = __webpack_require__(160);
	var EventProxy = __webpack_require__(176);
	var LiePromise = __webpack_require__(137);
	var PixelReporter = __webpack_require__(177);
	var request = __webpack_require__(139);

	function defaults() /*...objects*/{
	    var result = {};
	    var length = arguments.length;
	    var index, object;
	    var prop, value;

	    for (index = 0; index < length; index++) {
	        object = arguments[index] || {};

	        for (prop in object) {
	            value = object[prop];

	            if (result[prop] === undefined) {
	                result[prop] = value;
	            }

	            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	                result[prop] = defaults(result[prop], value);
	            }
	        }
	    }

	    return result;
	}

	function identity(value) {
	    return value;
	}

	function getNotReadyError() {
	    return new Error('VASTPlayer not ready.');
	}

	function proxy(method) {
	    return function callMethod() {
	        var self = this;
	        var player = this.__private__.player;

	        if (!this.ready) {
	            return LiePromise.reject(getNotReadyError());
	        }

	        return player[method].apply(player, arguments).then(function () {
	            return self;
	        });
	    };
	}

	function proxyProp(property) {
	    return {
	        get: function get() {
	            if (!this.ready) {
	                throw getNotReadyError();
	            }

	            return this.__private__.player[property];
	        },

	        set: function set(value) {
	            if (!this.ready) {
	                throw getNotReadyError();
	            }

	            return this.__private__.player[property] = value;
	        }
	    };
	}

	function VASTPlayer(container, config) {
	    var _this = this;

	    var self = this;

	    EventEmitter.call(this); // call super()

	    this.__private__ = {
	        container: container,
	        config: defaults(config, {
	            vast: {
	                resolveWrappers: true,
	                maxRedirects: 5
	            },
	            tracking: {
	                mapper: identity
	            }
	        }),

	        vast: null,
	        ready: false,
	        player: null
	    };

	    this.on(EVENTS.AdClickThru, function onAdClickThru(url, id, playerHandles) {
	        var clickThrough = url || self.vast.get('ads[0].creatives[0].videoClicks.clickThrough');
	        if (playerHandles && clickThrough) {
	            window.open(clickThrough);
	        }

	        // track 'VideoClick' event for wrapper
	        var clickTrackings = self.vast.get('ads[0].creatives[0].videoClicks.clickTrackings');
	        if (clickTrackings && clickTrackings.length > 0) {
	            clickTrackings.map(function (clickTracking) {
	                var xmlHttp = new XMLHttpRequest();
	                xmlHttp.open("GET", clickTracking, true); // false for synchronous request
	                xmlHttp.send(null);
	            });
	        }
	    });

	    this.on(EVENTS.AdClickBackground, function () {
	        var player = self.__private__.player;
	        if (!player.video) {
	            return;
	        }

	        if (!player.video.paused) {
	            _this.pauseAd();
	        } else {
	            _this.resumeAd();
	        }
	    });
	}
	inherits(VASTPlayer, EventEmitter);
	Object.defineProperties(VASTPlayer.prototype, {
	    container: {
	        get: function getContainer() {
	            return this.__private__.container;
	        }
	    },

	    config: {
	        get: function getConfig() {
	            return this.__private__.config;
	        }
	    },

	    vast: {
	        get: function getVast() {
	            return this.__private__.vast;
	        }
	    },

	    ready: {
	        get: function getReady() {
	            return this.__private__.ready;
	        }
	    },

	    paused: {
	        get: function getPaused() {
	            return this.__private__.player.video.paused;
	        }
	    },

	    muted: {
	        get: function getMute() {
	            return this.__private__.player.video.muted;
	        },
	        set: function setMute(value) {
	            if (value) {
	                this.__private__.player.video.muted = value;
	            }
	        }
	    },

	    video: {
	        get: function getVideo() {
	            return this.__private__.player.video;
	        }
	    },

	    adRemainingTime: proxyProp('adRemainingTime'),
	    adDuration: proxyProp('adDuration'),
	    adVolume: proxyProp('adVolume')
	});

	VASTPlayer.prototype.load = function load(uri) {
	    var self = this;
	    var config = this.config.vast;

	    return VAST.fetch(uri, config).then(function loadPlayer(vast) {
	        var config = function () {
	            var jsVPAIDFiles = vast.filter('ads[0].creatives[0].mediaFiles', function (mediaFile) {
	                return (mediaFile.type === MIME.JAVASCRIPT || mediaFile.type === 'application/x-javascript') && mediaFile.apiFramework === 'VPAID';
	            });

	            var swfVPAIDFiles = vast.filter('ads[0].creatives[0].mediaFiles', function (mediaFile) {
	                return mediaFile.type === MIME.FLASH && mediaFile.apiFramework === 'VPAID';
	            });

	            var files = vast.filter('ads[0].creatives[0].mediaFiles', function () {
	                return true;
	            });

	            if (jsVPAIDFiles.length > 0) {
	                return {
	                    player: new JavaScriptVPAIDPlayer(self.container),
	                    mediaFiles: jsVPAIDFiles
	                };
	            } else if (swfVPAIDFiles.length > 0) {
	                return {
	                    player: new FlashVPAIDPlayer(self.container, VASTPlayer.vpaidSWFLocation),
	                    mediaFiles: swfVPAIDFiles
	                };
	            }

	            return {
	                player: new HTMLVideoPlayer(self.container),
	                mediaFiles: files
	            };
	        }();
	        var parameters = vast.get('ads[0].creatives[0].parameters');
	        var pixels = [].concat(vast.map('ads[0].impressions', function (impression) {
	            return { event: 'impression', uri: impression.uri };
	        }), vast.map('ads[0].errors', function (uri) {
	            return { event: 'error', uri: uri };
	        }), vast.get('ads[0].creatives[0].trackingEvents'), vast.map('ads[0].creatives[0].videoClicks.clickTrackings', function (uri) {
	            return { event: 'clickThrough', uri: uri };
	        }));

	        var player = config.player;
	        var mediaFiles = config.mediaFiles;
	        var proxy = new EventProxy(EVENTS);
	        var reporter = new PixelReporter(pixels, self.config.tracking.mapper);

	        proxy.from(player).to(self);

	        self.__private__.vast = vast;
	        self.__private__.player = player;

	        return player.load(mediaFiles, parameters).then(function setupPixels() {
	            reporter.track(player);
	        });
	    }).then(function setReady() {
	        self.__private__.ready = true;
	        self.emit('ready');

	        return self;
	    }).catch(function emitError(reason) {
	        self.emit('error', reason);

	        throw reason;
	    });
	};

	VASTPlayer.prototype.startAd = proxy('startAd');

	VASTPlayer.prototype.stopAd = proxy('stopAd');

	VASTPlayer.prototype.pauseAd = proxy('pauseAd');

	VASTPlayer.prototype.resumeAd = proxy('resumeAd');

	VASTPlayer.vpaidSWFLocation = 'https://ajax.cdnjs.com/ajax/libs/videojs-vast-vpaid/2.0.2/VPAIDFlash.swf';

	module.exports = VASTPlayer;

/***/ },
/* 131 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(133);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(134);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(59)))

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 134 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.VAST = __webpack_require__(136);

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var LiePromise = __webpack_require__(137);
	var request = __webpack_require__(139);
	var copy = __webpack_require__(145);
	var defaults = __webpack_require__(146);
	var extend = __webpack_require__(147);
	var nodeifyPromise = __webpack_require__(148);
	var push = Array.prototype.push;
	var xmlFromVast = __webpack_require__(149);

	var adDefaults = {
	    inline: inline,
	    wrapper: wrapper
	};

	var inlineDefaults = {
	    linear: linear,
	    companions: companions,
	    nonLinear: nonLinear
	};

	function noop() {}

	function inline(ad) {
	    defaults({
	        description: null,
	        survey: null
	    }, ad);
	}

	function wrapper() {}

	function linear(creative) {
	    defaults({
	        trackingEvents: [],
	        parameters: null,
	        videoClicks: null
	    }, creative);

	    (creative.mediaFiles || []).forEach(function (mediaFile) {
	        defaults({
	            id: null,
	            bitrate: null,
	            scalable: null,
	            maintainAspectRatio: null,
	            apiFramework: null
	        }, mediaFile);
	    });
	}

	function companions(creative) {
	    creative.companions.forEach(function (companion) {
	        defaults({
	            expandedWidth: null,
	            expandedHeight: null,
	            apiFramework: null,
	            trackingEvents: [],
	            clickThrough: null,
	            altText: null,
	            parameters: null
	        }, companion);
	    });
	}

	function nonLinear(creative) {
	    defaults({
	        trackingEvents: []
	    }, creative);

	    creative.ads.forEach(function (ad) {
	        defaults({
	            id: null,
	            expandedWidth: null,
	            expandedHeight: null,
	            scalable: null,
	            maintainAspectRatio: null,
	            minSuggestedDuration: null,
	            apiFramework: null,
	            clickThrough: null,
	            parameters: null
	        }, ad);
	    });
	}

	function VAST(json) {
	    copy(json, this, true);

	    this.ads.forEach(function (ad) {
	        defaults({
	            system: { version: null },
	            errors: []
	        }, ad);

	        ad.creatives.forEach(function (creative) {
	            defaults({
	                id: null,
	                sequence: null,
	                adID: null
	            }, creative);

	            inlineDefaults[creative.type](creative);
	        });

	        adDefaults[ad.type](ad);
	    });

	    this.__private__ = { wrappers: [], inlines: [] };
	}

	Object.defineProperties(VAST.prototype, {
	    wrappers: {
	        get: function getWrappers() {
	            var wrappers = this.__private__.wrappers;

	            wrappers.length = 0;
	            push.apply(wrappers, this.filter('ads', function (ad) {
	                return ad.type === 'wrapper';
	            }));

	            return wrappers;
	        }
	    },

	    inlines: {
	        get: function getInlines() {
	            var inlines = this.__private__.inlines;

	            inlines.length = 0;
	            push.apply(inlines, this.filter('ads', function (ad) {
	                return ad.type === 'inline';
	            }));

	            return inlines;
	        }
	    }
	});

	VAST.prototype.get = function get(prop) {
	    var parts = (prop || '').match(/[^\[\]\.]+/g) || [];

	    return parts.reduce(function (result, part) {
	        return (result || undefined) && result[part];
	    }, this);
	};

	VAST.prototype.set = function set(prop, value) {
	    var parts = function () {
	        var regex = /[^\[\]\.]+/g;
	        var result = [];

	        var match;
	        while (match = regex.exec(prop)) {
	            result.push({
	                token: match[0],
	                type: getType(match, match.index + match[0].length)
	            });
	        }

	        return result;
	    }();
	    var last = parts.pop();
	    var object = parts.reduce(function (object, part) {
	        return object[part.token] || (object[part.token] = new part.type());
	    }, this);

	    function getType(match, index) {
	        switch (match.input.charAt(index)) {
	            case '.':
	                return Object;
	            case '[':
	                return Array;
	            case ']':
	                return getType(match, index + 1);
	            default:
	                return null;
	        }
	    }

	    if (!prop) {
	        throw new Error('prop must be specified.');
	    }

	    return object[last.token] = value;
	};

	VAST.prototype.map = function map(prop, mapper) {
	    var array = this.get(prop) || [];
	    var length = array.length;
	    var result = [];

	    if (!(array instanceof Array)) {
	        return result;
	    }

	    var index = 0;
	    for (; index < length; index++) {
	        result.push(mapper.call(this, array[index], index, array));
	    }

	    return result;
	};

	VAST.prototype.filter = function filter(prop, predicate) {
	    var array = this.get(prop) || [];
	    var length = array.length;
	    var result = [];

	    if (!(array instanceof Array)) {
	        return result;
	    }

	    var index = 0;
	    for (; index < length; index++) {
	        if (predicate.call(this, array[index], index, array)) {
	            result.push(array[index]);
	        }
	    }

	    return result;
	};

	VAST.prototype.find = function find(prop, predicate) {
	    var array = this.get(prop) || [];
	    var length = array.length;

	    if (!(array instanceof Array)) {
	        return undefined;
	    }

	    var index = 0;
	    for (; index < length; index++) {
	        if (predicate.call(this, array[index], index, array)) {
	            return array[index];
	        }
	    }

	    return undefined;
	};

	VAST.prototype.toPOJO = function toPOJO() {
	    var pojo = JSON.parse(JSON.stringify(this));
	    delete pojo.__private__;

	    return pojo;
	};

	VAST.prototype.copy = function copy() {
	    return new this.constructor(this.toPOJO());
	};

	VAST.prototype.resolveWrappers = function resolveWrappers() /*maxRedirects, callback*/{
	    var maxRedirects = isNaN(arguments[0]) ? Infinity : arguments[0];
	    var callback = typeof arguments[0] === 'function' ? arguments[0] : arguments[1];

	    var VAST = this.constructor;
	    var vast = this;

	    function decorateWithWrapper(wrapper, ad) {
	        var wrapperCreativesByType = byType(wrapper.creatives);

	        function typeIs(type) {
	            return function checkType(creative) {
	                return creative.type === type;
	            };
	        }

	        function byType(creatives) {
	            return {
	                linear: creatives.filter(typeIs('linear')),
	                companions: creatives.filter(typeIs('companions')),
	                nonLinear: creatives.filter(typeIs('nonLinear'))
	            };
	        }

	        // Extend the ad with the impressions and errors from the wrapper
	        defaults(wrapper.impressions, ad.impressions);
	        defaults(wrapper.errors, ad.errors);

	        // Extend the ad's creatives with the creatives in the wrapper
	        ad.creatives.forEach(function (creative) {
	            defaults(wrapperCreativesByType[creative.type].shift() || {}, creative);
	        });

	        // If the ad is also a wrapper, add any of the wrapper's unused creatives to the ad so that
	        // the final inline ad can use all of the creatives from the wrapper.
	        push.apply(ad.creatives, ad.type !== 'wrapper' ? [] : ['linear', 'companions', 'nonLinear'].reduce(function (result, type) {
	            return result.concat(wrapperCreativesByType[type]);
	        }, []));

	        return ad;
	    }

	    if (maxRedirects === 0) {
	        return LiePromise.reject(new Error('Too many redirects were made.'));
	    }

	    return nodeifyPromise(LiePromise.all(this.map('wrappers', function requestVAST(wrapper) {
	        return LiePromise.resolve(request.get(wrapper.vastAdTagURI).withCredentials()).then(function makeVAST(response) {
	            return {
	                wrapper: wrapper,
	                response: VAST.pojoFromXML(response.text).ads
	            };
	        });
	    })).then(function merge(configs) {
	        var wrappers = configs.map(function (config) {
	            return config.wrapper;
	        });
	        var responses = configs.map(function (config) {
	            return config.response;
	        });

	        return new VAST(extend(vast.toPOJO(), {
	            ads: vast.map('ads', function (ad) {
	                var wrapperIndex = wrappers.indexOf(ad);
	                var wrapper = wrappers[wrapperIndex];
	                var response = responses[wrapperIndex];

	                return response ? response.map(decorateWithWrapper.bind(null, wrapper)) : [ad];
	            }).reduce(function (result, array) {
	                return result.concat(array);
	            })
	        }));
	    }).then(function recurse(result) {
	        if (result.get('wrappers.length') > 0) {
	            return result.resolveWrappers(maxRedirects - 1);
	        }

	        return result;
	    }), callback);
	};

	VAST.prototype.toXML = function toXML() {
	    var check = this.validate();

	    if (!check.valid) {
	        throw new Error('VAST is invalid: ' + check.reasons.join(', '));
	    }

	    return xmlFromVast(this);
	};

	VAST.prototype.validate = function validate() {
	    var vast = this;
	    var reasons = [];
	    var adValidators = {
	        inline: function validateInlineAd(getAdProp) {
	            var creativeValidators = {
	                linear: function validateLinearCreative(getCreativeProp) {
	                    makeAssertions(getCreativeProp, {
	                        exists: ['duration'],
	                        atLeastOne: ['mediaFiles']
	                    });
	                },
	                companions: function validateCompanionsCreative(getCreativeProp) {
	                    vast.get(getCreativeProp('companions')).forEach(function (companion, index) {
	                        function getCompanionProp(prop) {
	                            return getCreativeProp('companions[' + index + '].' + prop);
	                        }

	                        makeAssertions(getCompanionProp, {
	                            exists: [],
	                            atLeastOne: ['resources']
	                        });
	                    });
	                },
	                nonLinear: function validateNonLinearCreative(getCreativeProp) {
	                    vast.get(getCreativeProp('ads')).forEach(function (ad, index) {
	                        function getAdProp(prop) {
	                            return getCreativeProp('ads[' + index + '].' + prop);
	                        }

	                        makeAssertions(getAdProp, {
	                            exists: [],
	                            atLeastOne: ['resources']
	                        });
	                    });
	                }
	            };

	            makeAssertions(getAdProp, {
	                exists: ['title'],
	                atLeastOne: ['creatives']
	            });

	            vast.get(getAdProp('creatives')).forEach(function (creative, index) {
	                function getCreativeProp(prop) {
	                    return getAdProp('creatives[' + index + '].' + prop);
	                }

	                makeAssertions(getCreativeProp, {
	                    exists: ['type'],
	                    atLeastOne: []
	                });

	                (creativeValidators[creative.type] || noop)(getCreativeProp);
	            });
	        },
	        wrapper: function validateWrapperAd(getAdProp) {
	            makeAssertions(getAdProp, {
	                exists: ['vastAdTagURI'],
	                atLeastOne: []
	            });
	        }
	    };

	    function assert(truthy, reason) {
	        if (!truthy) {
	            reasons.push(reason);
	        }
	    }

	    function assertExists(prop) {
	        assert(vast.get(prop), prop + ' is required');
	    }

	    function assertAtLeastOneValue(prop) {
	        assert(vast.get(prop + '.length') > 0, prop + ' must contain at least one value');
	    }

	    function makeAssertions(getter, types) {
	        types.exists.map(getter).forEach(assertExists);
	        types.atLeastOne.map(getter).forEach(assertAtLeastOneValue);
	    }

	    makeAssertions(function (prop) {
	        return prop;
	    }, {
	        exists: [],
	        atLeastOne: ['ads']
	    });

	    this.get('ads').forEach(function (ad, index) {
	        function getAdProp(prop) {
	            return 'ads[' + index + '].' + prop;
	        }

	        makeAssertions(getAdProp, {
	            exists: ['type', 'system.name'],
	            atLeastOne: ['impressions']
	        });

	        (adValidators[ad.type] || noop)(getAdProp);
	    });

	    return { valid: reasons.length === 0, reasons: reasons.length === 0 ? null : reasons };
	};

	VAST.pojoFromXML = __webpack_require__(152);

	VAST.fetch = function fetch(uri /*, options, callback*/) {
	    var options = _typeof(arguments[1]) === 'object' ? arguments[1] || {} : {};
	    var callback = typeof arguments[2] === 'function' ? arguments[2] : arguments[1];

	    var VAST = this;

	    return nodeifyPromise(LiePromise.resolve(request.get(uri).set(options.headers || {})).then(function makeVAST(response) {
	        var vast = new VAST(VAST.pojoFromXML(response.text));
	        return options.resolveWrappers ? vast.resolveWrappers(options.maxRedirects) : vast;
	    }), callback);
	};

	module.exports = VAST;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var immediate = __webpack_require__(138);

	/* istanbul ignore next */
	function INTERNAL() {}

	var handlers = {};

	var REJECTED = ['REJECTED'];
	var FULFILLED = ['FULFILLED'];
	var PENDING = ['PENDING'];

	module.exports = Promise;

	function Promise(resolver) {
	  if (typeof resolver !== 'function') {
	    throw new TypeError('resolver must be a function');
	  }
	  this.state = PENDING;
	  this.queue = [];
	  this.outcome = void 0;
	  if (resolver !== INTERNAL) {
	    safelyResolveThenable(this, resolver);
	  }
	}

	Promise.prototype["catch"] = function (onRejected) {
	  return this.then(null, onRejected);
	};
	Promise.prototype.then = function (onFulfilled, onRejected) {
	  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
	    typeof onRejected !== 'function' && this.state === REJECTED) {
	    return this;
	  }
	  var promise = new this.constructor(INTERNAL);
	  if (this.state !== PENDING) {
	    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
	    unwrap(promise, resolver, this.outcome);
	  } else {
	    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
	  }

	  return promise;
	};
	function QueueItem(promise, onFulfilled, onRejected) {
	  this.promise = promise;
	  if (typeof onFulfilled === 'function') {
	    this.onFulfilled = onFulfilled;
	    this.callFulfilled = this.otherCallFulfilled;
	  }
	  if (typeof onRejected === 'function') {
	    this.onRejected = onRejected;
	    this.callRejected = this.otherCallRejected;
	  }
	}
	QueueItem.prototype.callFulfilled = function (value) {
	  handlers.resolve(this.promise, value);
	};
	QueueItem.prototype.otherCallFulfilled = function (value) {
	  unwrap(this.promise, this.onFulfilled, value);
	};
	QueueItem.prototype.callRejected = function (value) {
	  handlers.reject(this.promise, value);
	};
	QueueItem.prototype.otherCallRejected = function (value) {
	  unwrap(this.promise, this.onRejected, value);
	};

	function unwrap(promise, func, value) {
	  immediate(function () {
	    var returnValue;
	    try {
	      returnValue = func(value);
	    } catch (e) {
	      return handlers.reject(promise, e);
	    }
	    if (returnValue === promise) {
	      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
	    } else {
	      handlers.resolve(promise, returnValue);
	    }
	  });
	}

	handlers.resolve = function (self, value) {
	  var result = tryCatch(getThen, value);
	  if (result.status === 'error') {
	    return handlers.reject(self, result.value);
	  }
	  var thenable = result.value;

	  if (thenable) {
	    safelyResolveThenable(self, thenable);
	  } else {
	    self.state = FULFILLED;
	    self.outcome = value;
	    var i = -1;
	    var len = self.queue.length;
	    while (++i < len) {
	      self.queue[i].callFulfilled(value);
	    }
	  }
	  return self;
	};
	handlers.reject = function (self, error) {
	  self.state = REJECTED;
	  self.outcome = error;
	  var i = -1;
	  var len = self.queue.length;
	  while (++i < len) {
	    self.queue[i].callRejected(error);
	  }
	  return self;
	};

	function getThen(obj) {
	  // Make sure we only access the accessor once as required by the spec
	  var then = obj && obj.then;
	  if (obj && typeof obj === 'object' && typeof then === 'function') {
	    return function appyThen() {
	      then.apply(obj, arguments);
	    };
	  }
	}

	function safelyResolveThenable(self, thenable) {
	  // Either fulfill, reject or reject with error
	  var called = false;
	  function onError(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.reject(self, value);
	  }

	  function onSuccess(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.resolve(self, value);
	  }

	  function tryToUnwrap() {
	    thenable(onSuccess, onError);
	  }

	  var result = tryCatch(tryToUnwrap);
	  if (result.status === 'error') {
	    onError(result.value);
	  }
	}

	function tryCatch(func, value) {
	  var out = {};
	  try {
	    out.value = func(value);
	    out.status = 'success';
	  } catch (e) {
	    out.status = 'error';
	    out.value = e;
	  }
	  return out;
	}

	Promise.resolve = resolve;
	function resolve(value) {
	  if (value instanceof this) {
	    return value;
	  }
	  return handlers.resolve(new this(INTERNAL), value);
	}

	Promise.reject = reject;
	function reject(reason) {
	  var promise = new this(INTERNAL);
	  return handlers.reject(promise, reason);
	}

	Promise.all = all;
	function all(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var values = new Array(len);
	  var resolved = 0;
	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    allResolver(iterable[i], i);
	  }
	  return promise;
	  function allResolver(value, i) {
	    self.resolve(value).then(resolveFromAll, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	    function resolveFromAll(outValue) {
	      values[i] = outValue;
	      if (++resolved === len && !called) {
	        called = true;
	        handlers.resolve(promise, values);
	      }
	    }
	  }
	}

	Promise.race = race;
	function race(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    resolver(iterable[i]);
	  }
	  return promise;
	  function resolver(value) {
	    self.resolve(value).then(function (response) {
	      if (!called) {
	        called = true;
	        handlers.resolve(promise, response);
	      }
	    }, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	  }
	}


/***/ },
/* 138 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	var Mutation = global.MutationObserver || global.WebKitMutationObserver;

	var scheduleDrain;

	{
	  if (Mutation) {
	    var called = 0;
	    var observer = new Mutation(nextTick);
	    var element = global.document.createTextNode('');
	    observer.observe(element, {
	      characterData: true
	    });
	    scheduleDrain = function () {
	      element.data = (called = ++called % 2);
	    };
	  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
	    var channel = new global.MessageChannel();
	    channel.port1.onmessage = nextTick;
	    scheduleDrain = function () {
	      channel.port2.postMessage(0);
	    };
	  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
	    scheduleDrain = function () {

	      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	      var scriptEl = global.document.createElement('script');
	      scriptEl.onreadystatechange = function () {
	        nextTick();

	        scriptEl.onreadystatechange = null;
	        scriptEl.parentNode.removeChild(scriptEl);
	        scriptEl = null;
	      };
	      global.document.documentElement.appendChild(scriptEl);
	    };
	  } else {
	    scheduleDrain = function () {
	      setTimeout(nextTick, 0);
	    };
	  }
	}

	var draining;
	var queue = [];
	//named nextTick for less confusing stack traces
	function nextTick() {
	  draining = true;
	  var i, oldQueue;
	  var len = queue.length;
	  while (len) {
	    oldQueue = queue;
	    queue = [];
	    i = -1;
	    while (++i < len) {
	      oldQueue[i]();
	    }
	    len = queue.length;
	  }
	  draining = false;
	}

	module.exports = immediate;
	function immediate(task) {
	  if (queue.push(task) === 1 && !draining) {
	    scheduleDrain();
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Emitter = __webpack_require__(140);
	var reduce = __webpack_require__(141);
	var requestBase = __webpack_require__(142);
	var isObject = __webpack_require__(143);

	/**
	 * Root reference for iframes.
	 */

	var root;
	if (typeof window !== 'undefined') { // Browser window
	  root = window;
	} else if (typeof self !== 'undefined') { // Web Worker
	  root = self;
	} else { // Other environments
	  root = this;
	}

	/**
	 * Noop.
	 */

	function noop(){};

	/**
	 * Check if `obj` is a host object,
	 * we don't want to serialize these :)
	 *
	 * TODO: future proof, move to compoent land
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */

	function isHost(obj) {
	  var str = {}.toString.call(obj);

	  switch (str) {
	    case '[object File]':
	    case '[object Blob]':
	    case '[object FormData]':
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Expose `request`.
	 */

	var request = module.exports = __webpack_require__(144).bind(null, Request);

	/**
	 * Determine XHR.
	 */

	request.getXHR = function () {
	  if (root.XMLHttpRequest
	      && (!root.location || 'file:' != root.location.protocol
	          || !root.ActiveXObject)) {
	    return new XMLHttpRequest;
	  } else {
	    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
	  }
	  return false;
	};

	/**
	 * Removes leading and trailing whitespace, added to support IE.
	 *
	 * @param {String} s
	 * @return {String}
	 * @api private
	 */

	var trim = ''.trim
	  ? function(s) { return s.trim(); }
	  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

	/**
	 * Serialize the given `obj`.
	 *
	 * @param {Object} obj
	 * @return {String}
	 * @api private
	 */

	function serialize(obj) {
	  if (!isObject(obj)) return obj;
	  var pairs = [];
	  for (var key in obj) {
	    if (null != obj[key]) {
	      pushEncodedKeyValuePair(pairs, key, obj[key]);
	        }
	      }
	  return pairs.join('&');
	}

	/**
	 * Helps 'serialize' with serializing arrays.
	 * Mutates the pairs array.
	 *
	 * @param {Array} pairs
	 * @param {String} key
	 * @param {Mixed} val
	 */

	function pushEncodedKeyValuePair(pairs, key, val) {
	  if (Array.isArray(val)) {
	    return val.forEach(function(v) {
	      pushEncodedKeyValuePair(pairs, key, v);
	    });
	  }
	  pairs.push(encodeURIComponent(key)
	    + '=' + encodeURIComponent(val));
	}

	/**
	 * Expose serialization method.
	 */

	 request.serializeObject = serialize;

	 /**
	  * Parse the given x-www-form-urlencoded `str`.
	  *
	  * @param {String} str
	  * @return {Object}
	  * @api private
	  */

	function parseString(str) {
	  var obj = {};
	  var pairs = str.split('&');
	  var parts;
	  var pair;

	  for (var i = 0, len = pairs.length; i < len; ++i) {
	    pair = pairs[i];
	    parts = pair.split('=');
	    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
	  }

	  return obj;
	}

	/**
	 * Expose parser.
	 */

	request.parseString = parseString;

	/**
	 * Default MIME type map.
	 *
	 *     superagent.types.xml = 'application/xml';
	 *
	 */

	request.types = {
	  html: 'text/html',
	  json: 'application/json',
	  xml: 'application/xml',
	  urlencoded: 'application/x-www-form-urlencoded',
	  'form': 'application/x-www-form-urlencoded',
	  'form-data': 'application/x-www-form-urlencoded'
	};

	/**
	 * Default serialization map.
	 *
	 *     superagent.serialize['application/xml'] = function(obj){
	 *       return 'generated xml here';
	 *     };
	 *
	 */

	 request.serialize = {
	   'application/x-www-form-urlencoded': serialize,
	   'application/json': JSON.stringify
	 };

	 /**
	  * Default parsers.
	  *
	  *     superagent.parse['application/xml'] = function(str){
	  *       return { object parsed from str };
	  *     };
	  *
	  */

	request.parse = {
	  'application/x-www-form-urlencoded': parseString,
	  'application/json': JSON.parse
	};

	/**
	 * Parse the given header `str` into
	 * an object containing the mapped fields.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */

	function parseHeader(str) {
	  var lines = str.split(/\r?\n/);
	  var fields = {};
	  var index;
	  var line;
	  var field;
	  var val;

	  lines.pop(); // trailing CRLF

	  for (var i = 0, len = lines.length; i < len; ++i) {
	    line = lines[i];
	    index = line.indexOf(':');
	    field = line.slice(0, index).toLowerCase();
	    val = trim(line.slice(index + 1));
	    fields[field] = val;
	  }

	  return fields;
	}

	/**
	 * Check if `mime` is json or has +json structured syntax suffix.
	 *
	 * @param {String} mime
	 * @return {Boolean}
	 * @api private
	 */

	function isJSON(mime) {
	  return /[\/+]json\b/.test(mime);
	}

	/**
	 * Return the mime type for the given `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */

	function type(str){
	  return str.split(/ *; */).shift();
	};

	/**
	 * Return header field parameters.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */

	function params(str){
	  return reduce(str.split(/ *; */), function(obj, str){
	    var parts = str.split(/ *= */)
	      , key = parts.shift()
	      , val = parts.shift();

	    if (key && val) obj[key] = val;
	    return obj;
	  }, {});
	};

	/**
	 * Initialize a new `Response` with the given `xhr`.
	 *
	 *  - set flags (.ok, .error, etc)
	 *  - parse header
	 *
	 * Examples:
	 *
	 *  Aliasing `superagent` as `request` is nice:
	 *
	 *      request = superagent;
	 *
	 *  We can use the promise-like API, or pass callbacks:
	 *
	 *      request.get('/').end(function(res){});
	 *      request.get('/', function(res){});
	 *
	 *  Sending data can be chained:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' })
	 *        .end(function(res){});
	 *
	 *  Or passed to `.send()`:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' }, function(res){});
	 *
	 *  Or passed to `.post()`:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' })
	 *        .end(function(res){});
	 *
	 * Or further reduced to a single call for simple cases:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' }, function(res){});
	 *
	 * @param {XMLHTTPRequest} xhr
	 * @param {Object} options
	 * @api private
	 */

	function Response(req, options) {
	  options = options || {};
	  this.req = req;
	  this.xhr = this.req.xhr;
	  // responseText is accessible only if responseType is '' or 'text' and on older browsers
	  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
	     ? this.xhr.responseText
	     : null;
	  this.statusText = this.req.xhr.statusText;
	  this.setStatusProperties(this.xhr.status);
	  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
	  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
	  // getResponseHeader still works. so we get content-type even if getting
	  // other headers fails.
	  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
	  this.setHeaderProperties(this.header);
	  this.body = this.req.method != 'HEAD'
	    ? this.parseBody(this.text ? this.text : this.xhr.response)
	    : null;
	}

	/**
	 * Get case-insensitive `field` value.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api public
	 */

	Response.prototype.get = function(field){
	  return this.header[field.toLowerCase()];
	};

	/**
	 * Set header related properties:
	 *
	 *   - `.type` the content type without params
	 *
	 * A response of "Content-Type: text/plain; charset=utf-8"
	 * will provide you with a `.type` of "text/plain".
	 *
	 * @param {Object} header
	 * @api private
	 */

	Response.prototype.setHeaderProperties = function(header){
	  // content-type
	  var ct = this.header['content-type'] || '';
	  this.type = type(ct);

	  // params
	  var obj = params(ct);
	  for (var key in obj) this[key] = obj[key];
	};

	/**
	 * Parse the given body `str`.
	 *
	 * Used for auto-parsing of bodies. Parsers
	 * are defined on the `superagent.parse` object.
	 *
	 * @param {String} str
	 * @return {Mixed}
	 * @api private
	 */

	Response.prototype.parseBody = function(str){
	  var parse = request.parse[this.type];
	  if (!parse && isJSON(this.type)) {
	    parse = request.parse['application/json'];
	  }
	  return parse && str && (str.length || str instanceof Object)
	    ? parse(str)
	    : null;
	};

	/**
	 * Set flags such as `.ok` based on `status`.
	 *
	 * For example a 2xx response will give you a `.ok` of __true__
	 * whereas 5xx will be __false__ and `.error` will be __true__. The
	 * `.clientError` and `.serverError` are also available to be more
	 * specific, and `.statusType` is the class of error ranging from 1..5
	 * sometimes useful for mapping respond colors etc.
	 *
	 * "sugar" properties are also defined for common cases. Currently providing:
	 *
	 *   - .noContent
	 *   - .badRequest
	 *   - .unauthorized
	 *   - .notAcceptable
	 *   - .notFound
	 *
	 * @param {Number} status
	 * @api private
	 */

	Response.prototype.setStatusProperties = function(status){
	  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	  if (status === 1223) {
	    status = 204;
	  }

	  var type = status / 100 | 0;

	  // status / class
	  this.status = this.statusCode = status;
	  this.statusType = type;

	  // basics
	  this.info = 1 == type;
	  this.ok = 2 == type;
	  this.clientError = 4 == type;
	  this.serverError = 5 == type;
	  this.error = (4 == type || 5 == type)
	    ? this.toError()
	    : false;

	  // sugar
	  this.accepted = 202 == status;
	  this.noContent = 204 == status;
	  this.badRequest = 400 == status;
	  this.unauthorized = 401 == status;
	  this.notAcceptable = 406 == status;
	  this.notFound = 404 == status;
	  this.forbidden = 403 == status;
	};

	/**
	 * Return an `Error` representative of this response.
	 *
	 * @return {Error}
	 * @api public
	 */

	Response.prototype.toError = function(){
	  var req = this.req;
	  var method = req.method;
	  var url = req.url;

	  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
	  var err = new Error(msg);
	  err.status = this.status;
	  err.method = method;
	  err.url = url;

	  return err;
	};

	/**
	 * Expose `Response`.
	 */

	request.Response = Response;

	/**
	 * Initialize a new `Request` with the given `method` and `url`.
	 *
	 * @param {String} method
	 * @param {String} url
	 * @api public
	 */

	function Request(method, url) {
	  var self = this;
	  this._query = this._query || [];
	  this.method = method;
	  this.url = url;
	  this.header = {}; // preserves header name case
	  this._header = {}; // coerces header names to lowercase
	  this.on('end', function(){
	    var err = null;
	    var res = null;

	    try {
	      res = new Response(self);
	    } catch(e) {
	      err = new Error('Parser is unable to parse the response');
	      err.parse = true;
	      err.original = e;
	      // issue #675: return the raw response if the response parsing fails
	      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
	      // issue #876: return the http status code if the response parsing fails
	      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
	      return self.callback(err);
	    }

	    self.emit('response', res);

	    if (err) {
	      return self.callback(err, res);
	    }

	    if (res.status >= 200 && res.status < 300) {
	      return self.callback(err, res);
	    }

	    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
	    new_err.original = err;
	    new_err.response = res;
	    new_err.status = res.status;

	    self.callback(new_err, res);
	  });
	}

	/**
	 * Mixin `Emitter` and `requestBase`.
	 */

	Emitter(Request.prototype);
	for (var key in requestBase) {
	  Request.prototype[key] = requestBase[key];
	}

	/**
	 * Abort the request, and clear potential timeout.
	 *
	 * @return {Request}
	 * @api public
	 */

	Request.prototype.abort = function(){
	  if (this.aborted) return;
	  this.aborted = true;
	  this.xhr && this.xhr.abort();
	  this.clearTimeout();
	  this.emit('abort');
	  return this;
	};

	/**
	 * Set Content-Type to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.xml = 'application/xml';
	 *
	 *      request.post('/')
	 *        .type('xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 *      request.post('/')
	 *        .type('application/xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 * @param {String} type
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.type = function(type){
	  this.set('Content-Type', request.types[type] || type);
	  return this;
	};

	/**
	 * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
	 * 'arraybuffer'.
	 *
	 * Examples:
	 *
	 *      req.get('/')
	 *        .responseType('blob')
	 *        .end(callback);
	 *
	 * @param {String} val
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.responseType = function(val){
	  this._responseType = val;
	  return this;
	};

	/**
	 * Set Accept to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.json = 'application/json';
	 *
	 *      request.get('/agent')
	 *        .accept('json')
	 *        .end(callback);
	 *
	 *      request.get('/agent')
	 *        .accept('application/json')
	 *        .end(callback);
	 *
	 * @param {String} accept
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.accept = function(type){
	  this.set('Accept', request.types[type] || type);
	  return this;
	};

	/**
	 * Set Authorization field value with `user` and `pass`.
	 *
	 * @param {String} user
	 * @param {String} pass
	 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.auth = function(user, pass, options){
	  if (!options) {
	    options = {
	      type: 'basic'
	    }
	  }

	  switch (options.type) {
	    case 'basic':
	      var str = btoa(user + ':' + pass);
	      this.set('Authorization', 'Basic ' + str);
	    break;

	    case 'auto':
	      this.username = user;
	      this.password = pass;
	    break;
	  }
	  return this;
	};

	/**
	* Add query-string `val`.
	*
	* Examples:
	*
	*   request.get('/shoes')
	*     .query('size=10')
	*     .query({ color: 'blue' })
	*
	* @param {Object|String} val
	* @return {Request} for chaining
	* @api public
	*/

	Request.prototype.query = function(val){
	  if ('string' != typeof val) val = serialize(val);
	  if (val) this._query.push(val);
	  return this;
	};

	/**
	 * Queue the given `file` as an attachment to the specified `field`,
	 * with optional `filename`.
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
	 *   .end(callback);
	 * ```
	 *
	 * @param {String} field
	 * @param {Blob|File} file
	 * @param {String} filename
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.attach = function(field, file, filename){
	  this._getFormData().append(field, file, filename || file.name);
	  return this;
	};

	Request.prototype._getFormData = function(){
	  if (!this._formData) {
	    this._formData = new root.FormData();
	  }
	  return this._formData;
	};

	/**
	 * Send `data` as the request body, defaulting the `.type()` to "json" when
	 * an object is given.
	 *
	 * Examples:
	 *
	 *       // manual json
	 *       request.post('/user')
	 *         .type('json')
	 *         .send('{"name":"tj"}')
	 *         .end(callback)
	 *
	 *       // auto json
	 *       request.post('/user')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // manual x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send('name=tj')
	 *         .end(callback)
	 *
	 *       // auto x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // defaults to x-www-form-urlencoded
	  *      request.post('/user')
	  *        .send('name=tobi')
	  *        .send('species=ferret')
	  *        .end(callback)
	 *
	 * @param {String|Object} data
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.send = function(data){
	  var obj = isObject(data);
	  var type = this._header['content-type'];

	  // merge
	  if (obj && isObject(this._data)) {
	    for (var key in data) {
	      this._data[key] = data[key];
	    }
	  } else if ('string' == typeof data) {
	    if (!type) this.type('form');
	    type = this._header['content-type'];
	    if ('application/x-www-form-urlencoded' == type) {
	      this._data = this._data
	        ? this._data + '&' + data
	        : data;
	    } else {
	      this._data = (this._data || '') + data;
	    }
	  } else {
	    this._data = data;
	  }

	  if (!obj || isHost(data)) return this;
	  if (!type) this.type('json');
	  return this;
	};

	/**
	 * @deprecated
	 */
	Response.prototype.parse = function serialize(fn){
	  if (root.console) {
	    console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
	  }
	  this.serialize(fn);
	  return this;
	};

	Response.prototype.serialize = function serialize(fn){
	  this._parser = fn;
	  return this;
	};

	/**
	 * Invoke the callback with `err` and `res`
	 * and handle arity check.
	 *
	 * @param {Error} err
	 * @param {Response} res
	 * @api private
	 */

	Request.prototype.callback = function(err, res){
	  var fn = this._callback;
	  this.clearTimeout();
	  fn(err, res);
	};

	/**
	 * Invoke callback with x-domain error.
	 *
	 * @api private
	 */

	Request.prototype.crossDomainError = function(){
	  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
	  err.crossDomain = true;

	  err.status = this.status;
	  err.method = this.method;
	  err.url = this.url;

	  this.callback(err);
	};

	/**
	 * Invoke callback with timeout error.
	 *
	 * @api private
	 */

	Request.prototype.timeoutError = function(){
	  var timeout = this._timeout;
	  var err = new Error('timeout of ' + timeout + 'ms exceeded');
	  err.timeout = timeout;
	  this.callback(err);
	};

	/**
	 * Enable transmission of cookies with x-domain requests.
	 *
	 * Note that for this to work the origin must not be
	 * using "Access-Control-Allow-Origin" with a wildcard,
	 * and also must set "Access-Control-Allow-Credentials"
	 * to "true".
	 *
	 * @api public
	 */

	Request.prototype.withCredentials = function(){
	  this._withCredentials = true;
	  return this;
	};

	/**
	 * Initiate request, invoking callback `fn(res)`
	 * with an instanceof `Response`.
	 *
	 * @param {Function} fn
	 * @return {Request} for chaining
	 * @api public
	 */

	Request.prototype.end = function(fn){
	  var self = this;
	  var xhr = this.xhr = request.getXHR();
	  var query = this._query.join('&');
	  var timeout = this._timeout;
	  var data = this._formData || this._data;

	  // store callback
	  this._callback = fn || noop;

	  // state change
	  xhr.onreadystatechange = function(){
	    if (4 != xhr.readyState) return;

	    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
	    // result in the error "Could not complete the operation due to error c00c023f"
	    var status;
	    try { status = xhr.status } catch(e) { status = 0; }

	    if (0 == status) {
	      if (self.timedout) return self.timeoutError();
	      if (self.aborted) return;
	      return self.crossDomainError();
	    }
	    self.emit('end');
	  };

	  // progress
	  var handleProgress = function(e){
	    if (e.total > 0) {
	      e.percent = e.loaded / e.total * 100;
	    }
	    e.direction = 'download';
	    self.emit('progress', e);
	  };
	  if (this.hasListeners('progress')) {
	    xhr.onprogress = handleProgress;
	  }
	  try {
	    if (xhr.upload && this.hasListeners('progress')) {
	      xhr.upload.onprogress = handleProgress;
	    }
	  } catch(e) {
	    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
	    // Reported here:
	    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
	  }

	  // timeout
	  if (timeout && !this._timer) {
	    this._timer = setTimeout(function(){
	      self.timedout = true;
	      self.abort();
	    }, timeout);
	  }

	  // querystring
	  if (query) {
	    query = request.serializeObject(query);
	    this.url += ~this.url.indexOf('?')
	      ? '&' + query
	      : '?' + query;
	  }

	  // initiate request
	  if (this.username && this.password) {
	    xhr.open(this.method, this.url, true, this.username, this.password);
	  } else {
	    xhr.open(this.method, this.url, true);
	  }

	  // CORS
	  if (this._withCredentials) xhr.withCredentials = true;

	  // body
	  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
	    // serialize stuff
	    var contentType = this._header['content-type'];
	    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
	    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
	    if (serialize) data = serialize(data);
	  }

	  // set header fields
	  for (var field in this.header) {
	    if (null == this.header[field]) continue;
	    xhr.setRequestHeader(field, this.header[field]);
	  }

	  if (this._responseType) {
	    xhr.responseType = this._responseType;
	  }

	  // send stuff
	  this.emit('request', this);

	  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
	  // We need null here if data is undefined
	  xhr.send(typeof data !== 'undefined' ? data : null);
	  return this;
	};


	/**
	 * Expose `Request`.
	 */

	request.Request = Request;

	/**
	 * GET `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	request.get = function(url, data, fn){
	  var req = request('GET', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.query(data);
	  if (fn) req.end(fn);
	  return req;
	};

	/**
	 * HEAD `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	request.head = function(url, data, fn){
	  var req = request('HEAD', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};

	/**
	 * DELETE `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	function del(url, fn){
	  var req = request('DELETE', url);
	  if (fn) req.end(fn);
	  return req;
	};

	request['del'] = del;
	request['delete'] = del;

	/**
	 * PATCH `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} data
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	request.patch = function(url, data, fn){
	  var req = request('PATCH', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};

	/**
	 * POST `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} data
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	request.post = function(url, data, fn){
	  var req = request('POST', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};

	/**
	 * PUT `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */

	request.put = function(url, data, fn){
	  var req = request('PUT', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `Emitter`.
	 */

	if (true) {
	  module.exports = Emitter;
	}

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 141 */
/***/ function(module, exports) {

	
	/**
	 * Reduce `arr` with `fn`.
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Mixed} initial
	 *
	 * TODO: combatible error handling?
	 */

	module.exports = function(arr, fn, initial){  
	  var idx = 0;
	  var len = arr.length;
	  var curr = arguments.length == 3
	    ? initial
	    : arr[idx++];

	  while (idx < len) {
	    curr = fn.call(null, curr, arr[idx], ++idx, arr);
	  }
	  
	  return curr;
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module of mixed-in functions shared between node and client code
	 */
	var isObject = __webpack_require__(143);

	/**
	 * Clear previous timeout.
	 *
	 * @return {Request} for chaining
	 * @api public
	 */

	exports.clearTimeout = function _clearTimeout(){
	  this._timeout = 0;
	  clearTimeout(this._timer);
	  return this;
	};

	/**
	 * Force given parser
	 *
	 * Sets the body parser no matter type.
	 *
	 * @param {Function}
	 * @api public
	 */

	exports.parse = function parse(fn){
	  this._parser = fn;
	  return this;
	};

	/**
	 * Set timeout to `ms`.
	 *
	 * @param {Number} ms
	 * @return {Request} for chaining
	 * @api public
	 */

	exports.timeout = function timeout(ms){
	  this._timeout = ms;
	  return this;
	};

	/**
	 * Faux promise support
	 *
	 * @param {Function} fulfill
	 * @param {Function} reject
	 * @return {Request}
	 */

	exports.then = function then(fulfill, reject) {
	  return this.end(function(err, res) {
	    err ? reject(err) : fulfill(res);
	  });
	}

	/**
	 * Allow for extension
	 */

	exports.use = function use(fn) {
	  fn(this);
	  return this;
	}


	/**
	 * Get request header `field`.
	 * Case-insensitive.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api public
	 */

	exports.get = function(field){
	  return this._header[field.toLowerCase()];
	};

	/**
	 * Get case-insensitive header `field` value.
	 * This is a deprecated internal API. Use `.get(field)` instead.
	 *
	 * (getHeader is no longer used internally by the superagent code base)
	 *
	 * @param {String} field
	 * @return {String}
	 * @api private
	 * @deprecated
	 */

	exports.getHeader = exports.get;

	/**
	 * Set header `field` to `val`, or multiple fields with one object.
	 * Case-insensitive.
	 *
	 * Examples:
	 *
	 *      req.get('/')
	 *        .set('Accept', 'application/json')
	 *        .set('X-API-Key', 'foobar')
	 *        .end(callback);
	 *
	 *      req.get('/')
	 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
	 *        .end(callback);
	 *
	 * @param {String|Object} field
	 * @param {String} val
	 * @return {Request} for chaining
	 * @api public
	 */

	exports.set = function(field, val){
	  if (isObject(field)) {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	    return this;
	  }
	  this._header[field.toLowerCase()] = val;
	  this.header[field] = val;
	  return this;
	};

	/**
	 * Remove header `field`.
	 * Case-insensitive.
	 *
	 * Example:
	 *
	 *      req.get('/')
	 *        .unset('User-Agent')
	 *        .end(callback);
	 *
	 * @param {String} field
	 */
	exports.unset = function(field){
	  delete this._header[field.toLowerCase()];
	  delete this.header[field];
	  return this;
	};

	/**
	 * Write the field `name` and `val` for "multipart/form-data"
	 * request bodies.
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .field('foo', 'bar')
	 *   .end(callback);
	 * ```
	 *
	 * @param {String} name
	 * @param {String|Blob|File|Buffer|fs.ReadStream} val
	 * @return {Request} for chaining
	 * @api public
	 */
	exports.field = function(name, val) {
	  this._getFormData().append(name, val);
	  return this;
	};


/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Check if `obj` is an object.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */

	function isObject(obj) {
	  return null != obj && 'object' == typeof obj;
	}

	module.exports = isObject;


/***/ },
/* 144 */
/***/ function(module, exports) {

	// The node and browser modules expose versions of this with the
	// appropriate constructor function bound as first argument
	/**
	 * Issue a request:
	 *
	 * Examples:
	 *
	 *    request('GET', '/users').end(callback)
	 *    request('/users').end(callback)
	 *    request('/users', callback)
	 *
	 * @param {String} method
	 * @param {String|Function} url or callback
	 * @return {Request}
	 * @api public
	 */

	function request(RequestConstructor, method, url) {
	  // callback
	  if ('function' == typeof url) {
	    return new RequestConstructor('GET', method).end(url);
	  }

	  // url first
	  if (2 == arguments.length) {
	    return new RequestConstructor('GET', method);
	  }

	  return new RequestConstructor(method, url);
	}

	module.exports = request;


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var push = Array.prototype.push;

	function copyObject(object, target, deep) {
	    return Object.keys(object).reduce(function (result, key) {
	        result[key] = deep ? copy(object[key], null, true) : object[key];
	        return result;
	    }, target || {});
	}

	function copyArray(array, _target_, deep) {
	    var target = _target_ || [];

	    push.apply(target, deep ? array.map(function (item) {
	        return copy(item, null, true);
	    }) : array);

	    return target;
	}

	function copy(object /*, target, deep*/) {
	    var target = (_typeof(arguments[1]) === 'object' || null) && arguments[1];
	    var deep = typeof arguments[1] === 'boolean' ? arguments[1] : arguments[2];

	    if (Object(object) !== object) {
	        return object;
	    }

	    return object instanceof Array ? copyArray(object, target, deep) : copyObject(object, target, deep);
	}

	module.exports = copy;

/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';

	var push = Array.prototype.push;

	function isObject(value) {
	    return Object(value) === value;
	}

	function isArray(value) {
	    return value instanceof Array;
	}

	module.exports = function defaults(config, target) {
	    if ([config, target].every(isArray)) {
	        push.apply(target, config.filter(function (item) {
	            return target.indexOf(item) < 0;
	        }));

	        return target;
	    }

	    return Object.keys(config).reduce(function (target, key) {
	        var values = [config[key], target[key]];

	        if (values.every(isObject)) {
	            defaults(config[key], target[key]);
	        }

	        if (!(key in target)) {
	            target[key] = config[key];
	        }

	        return target;
	    }, target);
	};

/***/ },
/* 147 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function extend() /*...objects*/{
	    var objects = Array.prototype.slice.call(arguments);

	    return objects.reduce(function (result, object) {
	        return Object.keys(object || {}).reduce(function (result, key) {
	            result[key] = object[key];
	            return result;
	        }, result);
	    }, {});
	};

/***/ },
/* 148 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function nodeifyPromise(promise, callback) {
	    if (typeof callback !== 'function') {
	        return promise;
	    }

	    promise.then(function callbackValue(value) {
	        callback(null, value);
	    }, function callbackReason(reason) {
	        callback(reason);
	    });

	    return promise;
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var secondsToTimestamp = __webpack_require__(150);
	var compileXML = __webpack_require__(151);

	var creativeCompilers = {
	    linear: compileLinear,
	    companions: compileCompanions,
	    nonLinear: compileNonLinear
	};

	function createTrackingEvents(trackingEvents) {
	    return {
	        tag: 'TrackingEvents',
	        children: trackingEvents.map(function (trackingEvent) {
	            return {
	                tag: 'Tracking',
	                attributes: { event: trackingEvent.event },
	                value: trackingEvent.uri,
	                cdata: true
	            };
	        })
	    };
	}

	function createResources(resources) {
	    return resources.map(function (resource) {
	        return {
	            tag: function (type) {
	                switch (type) {
	                    case 'static':
	                        return 'StaticResource';
	                    case 'iframe':
	                        return 'IFrameResource';
	                    case 'html':
	                        return 'HTMLResource';
	                }
	            }(resource.type),
	            attributes: { creativeType: resource.creativeType },
	            value: resource.data,
	            cdata: true
	        };
	    });
	}

	function createAdParameters(creative) {
	    return {
	        tag: 'AdParameters',
	        value: creative.parameters
	    };
	}

	function compileLinear(creative) {
	    return {
	        tag: 'Linear',
	        children: [{
	            tag: 'Duration',
	            value: secondsToTimestamp(creative.duration)
	        }, createTrackingEvents(creative.trackingEvents), createAdParameters(creative)].concat(creative.videoClicks ? [{
	            tag: 'VideoClicks',
	            children: [{
	                tag: 'ClickThrough',
	                value: creative.videoClicks.clickThrough,
	                cdata: true
	            }].concat(creative.videoClicks.clickTrackings.map(function (clickTracking) {
	                return {
	                    tag: 'ClickTracking',
	                    value: clickTracking,
	                    cdata: true
	                };
	            }), creative.videoClicks.customClicks.map(function (customClick) {
	                return {
	                    tag: 'CustomClick',
	                    attributes: { id: customClick.id },
	                    value: customClick.uri,
	                    cdata: true
	                };
	            }))
	        }] : [], [{
	            tag: 'MediaFiles',
	            children: creative.mediaFiles.map(function (mediaFile) {
	                return {
	                    tag: 'MediaFile',
	                    attributes: {
	                        id: mediaFile.id,
	                        width: mediaFile.width,
	                        height: mediaFile.height,
	                        bitrate: mediaFile.bitrate,
	                        type: mediaFile.type,
	                        delivery: mediaFile.delivery,
	                        scalable: mediaFile.scalable,
	                        maintainAspectRatio: mediaFile.maintainAspectRatio,
	                        apiFramework: mediaFile.apiFramework
	                    },
	                    value: mediaFile.uri,
	                    cdata: true
	                };
	            })
	        }])
	    };
	}

	function compileCompanions(creative) {
	    return {
	        tag: 'CompanionAds',
	        children: creative.companions.map(function (companion) {
	            return {
	                tag: 'Companion',
	                attributes: {
	                    id: companion.id,
	                    width: companion.width,
	                    height: companion.height,
	                    expandedWidth: companion.expandedWidth,
	                    expandedHeight: companion.expandedHeight,
	                    apiFramework: companion.apiFramework
	                },
	                children: createResources(companion.resources).concat([createTrackingEvents(companion.trackingEvents), {
	                    tag: 'CompanionClickThrough',
	                    value: companion.clickThrough,
	                    cdata: true
	                }, {
	                    tag: 'AltText',
	                    value: companion.altText
	                }, createAdParameters(companion)])
	            };
	        })
	    };
	}

	function compileNonLinear(creative) {
	    return {
	        tag: 'NonLinearAds',
	        children: creative.ads.map(function (ad) {
	            return {
	                tag: 'NonLinear',
	                attributes: {
	                    id: ad.id,
	                    width: ad.width,
	                    height: ad.height,
	                    expandedWidth: ad.expandedWidth,
	                    expandedHeight: ad.expandedHeight,
	                    scalable: ad.scalable,
	                    maintainAspectRatio: ad.maintainAspectRatio,
	                    minSuggestedDuration: secondsToTimestamp(ad.minSuggestedDuration),
	                    apiFramework: ad.apiFramework
	                },
	                children: createResources(ad.resources).concat([{
	                    tag: 'NonLinearClickThrough',
	                    value: ad.clickThrough,
	                    cdata: true
	                }, createAdParameters(ad)])
	            };
	        }).concat([createTrackingEvents(creative.trackingEvents)])
	    };
	}

	module.exports = function xmlFromVast(vast) {
	    return compileXML({
	        tag: 'VAST',
	        attributes: { version: vast.get('version') },
	        children: vast.map('ads', function (ad) {
	            return {
	                tag: 'Ad',
	                attributes: { id: ad.id },
	                children: [{
	                    tag: function () {
	                        switch (ad.type) {
	                            case 'inline':
	                                return 'InLine';
	                            case 'wrapper':
	                                return 'Wrapper';
	                        }
	                    }(),
	                    children: [{
	                        tag: 'AdSystem',
	                        attributes: { version: ad.system.version },
	                        value: ad.system.name
	                    }, {
	                        tag: 'AdTitle',
	                        value: ad.title
	                    }, {
	                        tag: 'Description',
	                        value: ad.description
	                    }, {
	                        tag: 'Survey',
	                        value: ad.survey,
	                        cdata: true
	                    }, {
	                        tag: 'VASTAdTagURI',
	                        value: ad.vastAdTagURI,
	                        cdata: true
	                    }].concat(ad.errors.map(function (error) {
	                        return {
	                            tag: 'Error',
	                            value: error,
	                            cdata: true
	                        };
	                    }), ad.impressions.map(function (impression) {
	                        return {
	                            tag: 'Impression',
	                            value: impression.uri,
	                            cdata: true,
	                            attributes: { id: impression.id }
	                        };
	                    }), [{
	                        tag: 'Creatives',
	                        children: ad.creatives.map(function (creative) {
	                            return {
	                                tag: 'Creative',
	                                attributes: {
	                                    id: creative.id,
	                                    sequence: creative.sequence,
	                                    AdID: creative.adID
	                                },
	                                children: [function (type) {
	                                    return creativeCompilers[type](creative);
	                                }(creative.type)]
	                            };
	                        }),
	                        required: true
	                    }])
	                }]
	            };
	        })
	    }, true);
	};

/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';

	function pad(number) {
	    return (number > 9 ? '' : '0') + number.toString();
	}

	module.exports = function secondsToTimestamp(seconds) {
	    if (Number(seconds) !== seconds) {
	        return null;
	    }

	    return [Math.floor(seconds / 60 / 60), Math.floor(seconds / 60 % 60), Math.floor(seconds % 60 % 60)].map(pad).join(':');
	};

/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';

	function existy(value) {
	    return value !== null && value !== undefined;
	}

	function escapeXML(string) {
	    return string !== undefined ? String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
	}

	function makeWhitespace(amount) {
	    var result = '';

	    while (amount--) {
	        result += ' ';
	    }

	    return result;
	}

	function makeCDATA(text) {
	    var parts = text !== undefined ? function (text) {
	        var result = [];
	        var regex = /]]>/g;

	        var cursor = 0;
	        var match, end;
	        while (match = regex.exec(text)) {
	            end = match.index + 2;

	            result.push(match.input.substring(cursor, end));
	            cursor = end;
	        }
	        result.push(text.substring(cursor, text.length));

	        return result;
	    }(String(text)) : [''];

	    return parts.reduce(function (result, part) {
	        return result + '<![CDATA[' + part + ']]>';
	    }, '');
	}

	function nodeValue(node) {
	    return node.cdata ? makeCDATA(node.value) : escapeXML(node.value);
	}

	function compileNode(node, indentation, trim) {
	    var tag = node.tag;
	    var attributes = node.attributes || {};
	    var attributeNames = Object.keys(attributes);
	    var children = node.children || [];
	    var value = node.value;
	    var hasChildren = children.length > 0;
	    var hasAttributes = attributeNames.every(function (attribute) {
	        return existy(attributes[attribute]);
	    }) && attributeNames.length > 0;
	    var hasValue = existy(value) || hasChildren || hasAttributes;

	    var whitespace = makeWhitespace(indentation);
	    var openingTag = '<' + tag + Object.keys(attributes).reduce(function (result, attribute) {
	        if (trim && !existy(attributes[attribute])) {
	            return result;
	        }

	        return result + ' ' + attribute + '="' + escapeXML(attributes[attribute]) + '"';
	    }, '') + '>';
	    var closingTag = '</' + tag + '>';

	    if (trim && !hasValue && !node.required) {
	        return [];
	    }

	    if (hasChildren) {
	        return [whitespace + openingTag].concat(node.children.reduce(function compileChild(result, child) {
	            return result.concat(compileNode(child, indentation + 4, trim));
	        }, []), [whitespace + closingTag]);
	    } else {
	        return [whitespace + openingTag + nodeValue(node) + closingTag];
	    }
	}

	module.exports = function compileXML(data, trim) {
	    return ['<?xml version="1.0" encoding="UTF-8"?>'].concat(compileNode(data, 0, trim)).join('\n');
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parseXML = __webpack_require__(153);
	var timestampToSeconds = __webpack_require__(154);
	var stringToBoolean = __webpack_require__(155);
	var extend = __webpack_require__(147);
	var trimObject = __webpack_require__(156);
	var numberify = __webpack_require__(157);

	var creativeParsers = {
	    linear: parseLinear,
	    companions: parseCompanions,
	    nonLinear: parseNonLinear
	};

	var adParsers = {
	    inline: parseInline,
	    wrapper: parseWrapper
	};

	function single(collection) {
	    return collection[0] || { attributes: {} };
	}

	function parseResources(ad) {
	    var resources = ad.find('URL');

	    return resources.map(function (resource) {
	        return {
	            data: resource.value
	        };
	    });
	}

	function parseLinear(creative) {
	    var duration = single(creative.find('Duration'));
	    var linear = single(creative.find('Linear'));
	    var events = creative.find('Tracking');
	    var adParameters = single(creative.find('AdParameters'));
	    var videoClicks = creative.find('VideoClicks')[0];
	    var mediaFiles = creative.find('MediaFile');

	    return {
	        type: 'linear',
	        skipOffset: linear.attributes.skipoffset,
	        duration: timestampToSeconds(duration.value) || undefined,
	        trackingEvents: events.map(function (event) {
	            return { event: event.attributes.event, uri: event.value };
	        }),
	        parameters: adParameters.value,
	        videoClicks: videoClicks && function () {
	            var clickThrough = single(videoClicks.find('ClickThrough'));
	            var trackings = videoClicks.find('ClickTracking');
	            var customClicks = videoClicks.find('CustomClick');

	            return {
	                clickThrough: clickThrough.value,
	                clickTrackings: trackings.map(function (tracking) {
	                    return tracking.value;
	                }),
	                customClicks: customClicks.map(function (click) {
	                    return { id: click.attributes.id, uri: click.value };
	                })
	            };
	        }(),
	        mediaFiles: mediaFiles.map(function (mediaFile) {
	            var attrs = mediaFile.attributes;

	            return {
	                id: attrs.id,
	                delivery: attrs.delivery,
	                type: attrs.type,
	                uri: mediaFile.value,
	                bitrate: numberify(attrs.bitrate),
	                width: numberify(attrs.width),
	                height: numberify(attrs.height),
	                scalable: stringToBoolean(attrs.scalable),
	                maintainAspectRatio: stringToBoolean(attrs.maintainAspectRatio),
	                apiFramework: attrs.apiFramework
	            };
	        })
	    };
	}

	function parseCompanions(creative) {
	    var companions = creative.find('Companion');

	    return {
	        type: 'companions',
	        companions: companions.map(function (companion) {
	            var events = companion.find('Tracking');
	            var companionClickThrough = single(companion.find('CompanionClickThrough'));
	            var altText = single(companion.find('AltText'));
	            var adParameters = single(companion.find('AdParameters'));

	            return {
	                id: companion.attributes.id,
	                width: numberify(companion.attributes.width),
	                height: numberify(companion.attributes.height),
	                expandedWidth: numberify(companion.attributes.expandedWidth),
	                expandedHeight: numberify(companion.attributes.expandedHeight),
	                apiFramework: companion.attributes.apiFramework,
	                resources: parseResources(companion),
	                trackingEvents: events.map(function (event) {
	                    return { event: event.attributes.event, uri: event.value };
	                }),
	                clickThrough: companionClickThrough.value,
	                altText: altText.value,
	                parameters: adParameters.value
	            };
	        })
	    };
	}

	function parseNonLinear(creative) {

	    var ads = creative.find('NonLinear');
	    var events = creative.find('Tracking');

	    return {
	        type: 'nonLinear',
	        ads: ads.map(function (ad) {
	            var nonLinearClickThrough = single(ad.find('NonLinearClickThrough'));
	            var staticResource = single(ad.find('StaticResource'));
	            var adParameters = single(ad.find('AdParameters'));

	            return {
	                id: ad.attributes.id,
	                width: ad.attributes.width,
	                height: ad.attributes.height,
	                expandedWidth: numberify(ad.attributes.expandedWidth),
	                expandedHeight: numberify(ad.attributes.expandedHeight),
	                scalable: stringToBoolean(ad.attributes.scalable),
	                maintainAspectRatio: stringToBoolean(ad.attributes.maintainAspectRatio),
	                minSuggestedDuration: timestampToSeconds(ad.attributes.minSuggestedDuration) || undefined,
	                apiFramework: ad.attributes.apiFramework,
	                resources: staticResource.value,
	                clickThrough: nonLinearClickThrough.value,
	                parameters: adParameters.value
	            };
	        }),
	        trackingEvents: events.map(function (event) {
	            return { event: event.attributes.event, uri: event.value };
	        })
	    };
	}

	function parseInline(ad) {
	    var adTitle = single(ad.find('AdTitle'));
	    var description = single(ad.find('Description'));
	    var survey = single(ad.find('Survey'));

	    return {
	        type: 'inline',
	        title: adTitle.value,
	        description: description.value,
	        survey: survey.value
	    };
	}

	function parseWrapper(ad) {
	    var vastAdTagURI = single(ad.find('VASTAdTagURI'));

	    return {
	        type: 'wrapper',
	        vastAdTagURI: vastAdTagURI.value
	    };
	}

	module.exports = function pojoFromXML(xml) {
	    var $ = parseXML(xml);

	    if (!$('VAST')[0]) {
	        throw new Error('[' + xml + '] is not a valid VAST document.');
	    }

	    return trimObject({
	        version: single($('VAST')).attributes.version,
	        ads: $('Ad').map(function (ad) {
	            var type = single(ad.find('Wrapper,InLine')).tag.toLowerCase();
	            var adSystem = single(ad.find('AdSystem'));
	            var errors = ad.find('Error');
	            var impressions = ad.find('Impression');
	            var creatives = ad.find('Creative');

	            return extend({
	                id: ad.attributes.id,
	                system: {
	                    name: adSystem.value,
	                    version: adSystem.attributes.version
	                },
	                errors: errors.map(function (error) {
	                    return error.value;
	                }),
	                impressions: impressions.map(function (impression) {
	                    return { uri: impression.value, id: impression.attributes.id };
	                }),
	                creatives: creatives.map(function (creative) {
	                    var type = function () {
	                        var element = single(creative.find('Linear,CompanionAds,NonLinearAds'));

	                        switch (element.tag) {
	                            case 'Linear':
	                                return 'linear';
	                            case 'CompanionAds':
	                                return 'companions';
	                            case 'NonLinearAds':
	                                return 'nonLinear';
	                        }
	                    }();

	                    return extend({
	                        id: creative.attributes.id,
	                        sequence: numberify(creative.attributes.sequence),
	                        adID: creative.attributes.AdID
	                    }, creativeParsers[type](creative));
	                })
	            }, adParsers[type](ad));
	        })
	    }, true);
	};

/***/ },
/* 153 */
/***/ function(module, exports) {

	'use strict';

	/* jshint browser:true, browserify:true, node:false */

	var map = Array.prototype.map;
	var filter = Array.prototype.filter;
	var reduce = Array.prototype.reduce;

	var parser = new DOMParser();

	function convertNode(node) {
	    var hasChildren = node.childElementCount > 0;

	    return {
	        tag: node.tagName,
	        value: hasChildren ? null : node.textContent,
	        attributes: reduce.call(node.attributes, function (result, attribute) {
	            result[attribute.name] = attribute.value;
	            return result;
	        }, {}),

	        find: function find(selector) {
	            return convertNodes(node.querySelectorAll(selector));
	        },
	        children: function children() {
	            return filter.call(node.childNodes, function isElement(node) {
	                return node instanceof Element;
	            }).map(convertNode);
	        }
	    };
	}

	function convertNodes(nodes) {
	    return map.call(nodes, convertNode);
	}

	module.exports = function parseXML(xml) {
	    var doc = parser.parseFromString(xml, 'application/xml');

	    return function queryXML(selector) {
	        return convertNodes(doc.querySelectorAll(selector));
	    };
	};

/***/ },
/* 154 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function timestampToSeconds(timestamp) {
	    var parts = (timestamp || '').match(/^(\d\d):(\d\d):(\d\d)$/);

	    return parts && parts.slice(1, 4).map(parseFloat).reduce(function (seconds, time, index) {
	        var multiplier = Math.pow(60, Math.abs(index - 2));

	        return seconds + time * multiplier;
	    }, 0);
	};

/***/ },
/* 155 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function stringToBoolean(string) {
	    switch ((string || '').toLowerCase()) {
	        case 'true':
	            return true;
	        case 'false':
	            return false;
	    }
	};

/***/ },
/* 156 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function trimObject(object, deep) {
	    if (Object(object) !== object) {
	        return object;
	    }

	    return Object.keys(object).reduce(function (result, key) {
	        if (deep && object[key] instanceof Array) {
	            result[key] = object[key].filter(function (value) {
	                return value !== undefined;
	            }).map(function (value) {
	                return trimObject(value, true);
	            });
	        } else if (deep && object[key] instanceof Object) {
	            result[key] = trimObject(object[key], true);
	        } else if (object[key] !== undefined) {
	            result[key] = object[key];
	        }

	        return result;
	    }, {});
	};

/***/ },
/* 157 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	module.exports = function numberify(value) {
	    if (!/string|number|boolean/.test(typeof value === 'undefined' ? 'undefined' : _typeof(value))) {
	        return undefined;
	    }

	    return isNaN(value) ? undefined : Number(value);
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(132).inherits;
	var VPAID = __webpack_require__(159);
	var LiePromise = __webpack_require__(137);
	var EVENTS = __webpack_require__(160);
	var isDesktop = __webpack_require__(161).isDesktop;
	var VPAIDVersion = __webpack_require__(164);

	function JavaScriptVPAID() {
	    VPAID.apply(this, arguments); // call super()

	    this.frame = null;
	}
	inherits(JavaScriptVPAID, VPAID);

	JavaScriptVPAID.prototype.load = function load(mediaFiles, parameters) {
	    var self = this;
	    var uri = mediaFiles[0].uri;
	    var bitrate = mediaFiles[0].bitrate;

	    return new LiePromise(function loadCreative(resolve, reject) {
	        var iframe = document.createElement('iframe');
	        var script = document.createElement('script');
	        var video = document.createElement('video');

	        function cleanup(reason) {
	            self.container.removeChild(iframe);
	            self.frame = null;
	            self.api = null;

	            if (reason) {
	                reject(reason);
	            }
	        }

	        iframe.src = 'about:blank';
	        iframe.style.width = '100%';
	        iframe.style.height = '100%';
	        iframe.style.display = 'block';
	        iframe.style.opacity = '0';
	        iframe.style.border = 'none';

	        video.setAttribute('webkit-playsinline', '');
	        video.setAttribute('playsinline', '');
	        video.style.display = 'block';
	        video.style.width = '100%';
	        video.style.height = '100%';
	        video.style.objectFit = 'contain';

	        self.container.appendChild(iframe);
	        // Opening the iframe document for writing causes it to inherit its parent's location
	        iframe.contentWindow.document.open();
	        iframe.contentWindow.document.close();

	        iframe.contentWindow.document.body.style.margin = '0';
	        self.frame = iframe;

	        script.src = uri;
	        script.onload = function onload() {
	            var vpaid = iframe.contentWindow.getVPAIDAd();
	            var position = iframe.getBoundingClientRect();
	            var slot = iframe.contentWindow.document.body;
	            var version = self.vpaidVersion = new VPAIDVersion(vpaid.handshakeVersion('2.0'));

	            function resizeAd() {
	                var position = iframe.getBoundingClientRect();

	                self.resizeAd(position.width, position.height, 'normal');
	            }

	            if (version.major > 2) {
	                return reject(new Error('VPAID version ' + version + ' is not supported.'));
	            }

	            iframe.contentWindow.addEventListener('resize', resizeAd, false);

	            EVENTS.forEach(function subscribe(event) {
	                return vpaid.subscribe(function handle() /*...args*/{
	                    var args = new Array(arguments.length);
	                    var length = arguments.length;
	                    while (length--) {
	                        args[length] = arguments[length];
	                    }

	                    return self.emit.apply(self, [event].concat(args));
	                }, event);
	            });

	            self.once(EVENTS.AdLoaded, function onAdLoaded() {
	                iframe.style.opacity = '1';
	                self.api = vpaid;
	                resolve(self);
	            });

	            self.once(EVENTS.AdError, function onAdError(reason) {
	                cleanup(new Error(reason));
	            });

	            self.once(EVENTS.AdStopped, cleanup);

	            vpaid.initAd(position.width, position.height, 'normal', bitrate, { AdParameters: parameters }, { slot: slot, videoSlot: video, videoSlotCanAutoPlay: isDesktop });
	        };
	        script.onerror = function onerror() {
	            cleanup(new Error('Failed to load MediaFile [' + uri + '].'));
	        };

	        iframe.contentWindow.document.body.appendChild(video);
	        iframe.contentWindow.document.head.appendChild(script);
	    });
	};

	module.exports = JavaScriptVPAID;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(132).inherits;
	var EventEmitter = __webpack_require__(131).EventEmitter;
	var LiePromise = __webpack_require__(137);
	var EVENTS = __webpack_require__(160);

	function proxy(method, event) {
	    return function callMethod() /*..args*/{
	        var args = arguments;
	        var api = this.api;
	        var self = this;

	        function getError() {
	            return new Error('Ad has not been loaded.');
	        }

	        function call() {
	            return api[method].apply(api, args);
	        }

	        if (!event) {
	            if (!api) {
	                throw getError();
	            }

	            return call();
	        }

	        return new LiePromise(function (resolve, reject) {
	            if (!api) {
	                return reject(getError());
	            }

	            self.once(event, function done() {
	                resolve(self);
	            });

	            return call();
	        });
	    };
	}

	function VPAID(container) {
	    this.container = container;
	    this.api = null;
	    this.vpaidVersion = null;
	}
	inherits(VPAID, EventEmitter);
	Object.defineProperties(VPAID.prototype, {
	    adLinear: { get: proxy('getAdLinear') },
	    adWidth: { get: proxy('getAdWidth') },
	    adHeight: { get: proxy('getAdHeight') },
	    adExpanded: { get: proxy('getAdExpanded') },
	    adSkippableState: { get: proxy('getAdSkippableState') },
	    adRemainingTime: { get: proxy('getAdRemainingTime') },
	    adDuration: { get: proxy('getAdDuration') },
	    adVolume: { get: proxy('getAdVolume'), set: proxy('setAdVolume') },
	    adCompanions: { get: proxy('getAdCompanions') },
	    adIcons: { get: proxy('getAdIcons') }
	});

	VPAID.prototype.load = function load() {
	    throw new Error('VPAID subclass must implement load() method.');
	};

	VPAID.prototype.resizeAd = proxy('resizeAd', EVENTS.AdSizeChange);

	VPAID.prototype.startAd = proxy('startAd', EVENTS.AdStarted);

	VPAID.prototype.stopAd = proxy('stopAd', EVENTS.AdStopped);

	VPAID.prototype.pauseAd = proxy('pauseAd', EVENTS.AdPaused);

	VPAID.prototype.resumeAd = proxy('resumeAd', EVENTS.AdPlaying);

	VPAID.prototype.expandAd = proxy('expandAd', EVENTS.AdExpandedChange);

	VPAID.prototype.collapseAd = proxy('collapseAd', EVENTS.AdExpandedChange);

	VPAID.prototype.skipAd = proxy('skipAd', EVENTS.AdSkipped);

	module.exports = VPAID;

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';

	var VPAID_EVENTS = ['AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange', 'AdSizeChange', 'AdLinearChange', 'AdDurationChange', 'AdExpandedChange', 'AdRemainingTimeChange', 'AdVolumeChange', 'AdImpression', 'AdVideoStart', 'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile', 'AdVideoProgress', 'AdVideoComplete', 'AdClickThru', 'AdInteraction', 'AdUserAcceptInvitation', 'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError', 'AdClickBackground', 'AdClickThruVpaid'];

	VPAID_EVENTS.forEach(function (event) {
	    VPAID_EVENTS[event] = event;
	});

	Object.freeze(VPAID_EVENTS);

	module.exports = VPAID_EVENTS;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var win = __webpack_require__(162);
	var video = document.createElement('video');
	var MIME = __webpack_require__(163);

	exports.isDesktop = !/Android|Silk|Mobile|PlayBook/.test(win.navigator.userAgent);

	exports.canPlay = function canPlay(type) {
	    var mimeTypes = win.navigator.mimeTypes;
	    var ActiveXObject = win.ActiveXObject;

	    switch (type) {
	        case MIME.FLASH:
	            try {
	                return new ActiveXObject('ShockwaveFlash.ShockwaveFlash') ? 2 : 0;
	            } catch (e) {
	                return !!(mimeTypes && mimeTypes[MIME.FLASH]) ? 2 : 0;
	            }
	            return 0;
	        case MIME.JAVASCRIPT:
	        case 'application/x-javascript':
	            return 2;
	        default:
	            if (video.canPlayType) {
	                switch (video.canPlayType(type)) {
	                    case 'probably':
	                        return 2;
	                    case 'maybe':
	                        return 1;
	                    default:
	                        return 0;
	                }
	            }
	    }

	    return 0;
	};

	Object.freeze(exports);

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";

	module.exports = window;

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';

	var MIME = {
	    JAVASCRIPT: 'application/javascript',
	    FLASH: 'application/x-shockwave-flash'
	};

	Object.freeze(MIME);

	module.exports = MIME;

/***/ },
/* 164 */
/***/ function(module, exports) {

	'use strict';

	function VPAIDVersion(versionString) {
	    var parts = versionString.split('.').map(parseFloat);

	    this.string = versionString;

	    this.major = parts[0];
	    this.minor = parts[1];
	    this.patch = parts[2];

	    Object.freeze(this);
	}

	VPAIDVersion.prototype.toString = function toString() {
	    return this.string;
	};

	module.exports = VPAIDVersion;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var VPAID = __webpack_require__(159);
	var inherits = __webpack_require__(132).inherits;
	var LiePromise = __webpack_require__(137);
	var uuid = __webpack_require__(166);
	var querystring = __webpack_require__(167);
	var EVENTS = __webpack_require__(160);
	var VPAIDVersion = __webpack_require__(164);

	function FlashVPAID(container, swfURI) {
	    VPAID.apply(this, arguments); // call super()

	    this.swfURI = swfURI;
	    this.object = null;
	}
	inherits(FlashVPAID, VPAID);

	FlashVPAID.prototype.load = function load(mediaFiles, parameters) {
	    var self = this;
	    var uri = mediaFiles[0].uri;
	    var bitrate = mediaFiles[0].bitrate;

	    return new LiePromise(function loadCreative(resolve, reject) {
	        var vpaid = document.createElement('object');
	        var eventFnName = 'vast_player__' + uuid(20);
	        var flashvars = querystring.stringify({
	            vpaidURI: uri,
	            eventCallback: eventFnName
	        });

	        function cleanup(reason) {
	            self.container.removeChild(vpaid);
	            self.api = null;
	            self.object = null;
	            delete window[eventFnName];

	            if (reason) {
	                reject(reason);
	            }
	        }

	        vpaid.type = 'application/x-shockwave-flash';
	        vpaid.data = self.swfURI + '?' + flashvars;
	        vpaid.style.display = 'block';
	        vpaid.style.width = '100%';
	        vpaid.style.height = '100%';
	        vpaid.style.border = 'none';
	        vpaid.style.opacity = '0';
	        vpaid.innerHTML = ['<param name="movie" value="' + self.swfURI + '">', '<param name="flashvars" value="' + flashvars + '">', '<param name="quality" value="high">', '<param name="play" value="false">', '<param name="loop" value="false">', '<param name="wmode" value="opaque">', '<param name="scale" value="noscale">', '<param name="salign" value="lt">', '<param name="allowScriptAccess" value="always">'].join('\n');

	        self.object = vpaid;

	        window[eventFnName] = function handleVPAIDEvent(event) {
	            switch (event.type) {
	                case EVENTS.AdClickThru:
	                    return self.emit(event.type, event.url, event.Id, event.playerHandles);
	                case EVENTS.AdInteraction:
	                case EVENTS.AdLog:
	                    return self.emit(event.type, event.Id);
	                case EVENTS.AdError:
	                    return self.emit(event.type, event.message);
	                default:
	                    return self.emit(event.type);
	            }
	        };

	        self.once('VPAIDInterfaceReady', function initAd() {
	            var position = vpaid.getBoundingClientRect();
	            var version = self.vpaidVersion = new VPAIDVersion(vpaid.handshakeVersion('2.0'));

	            if (version.major > 2) {
	                return reject(new Error('VPAID version ' + version + ' is not supported.'));
	            }

	            self.on('VPAIDInterfaceResize', function resizeAd() {
	                var position = vpaid.getBoundingClientRect();

	                self.resizeAd(position.width, position.height, 'normal');
	            });

	            vpaid.initAd(position.width, position.height, 'normal', bitrate, parameters, null);
	        });

	        self.once(EVENTS.AdLoaded, function handleAdLoaded() {
	            self.api = vpaid;
	            vpaid.style.opacity = '1';

	            resolve(self);
	        });

	        self.once(EVENTS.AdError, function handleAdError(reason) {
	            cleanup(new Error(reason));
	        });

	        self.once(EVENTS.AdStopped, cleanup);

	        self.container.appendChild(vpaid);
	    });
	};

	module.exports = FlashVPAID;

/***/ },
/* 166 */
/***/ function(module, exports) {

	'use strict';

	var POSSIBILITIES = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
	var POSSIBILITIES_LENGTH = POSSIBILITIES.length;

	module.exports = function uuid(length) {
	    var result = '';

	    while (length--) {
	        result += POSSIBILITIES.charAt(Math.floor(Math.random() * POSSIBILITIES_LENGTH));
	    }

	    return result;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(168);
	exports.encode = exports.stringify = __webpack_require__(169);


/***/ },
/* 168 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 169 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EventEmitter = __webpack_require__(131).EventEmitter;
	var inherits = __webpack_require__(132).inherits;
	var LiePromise = __webpack_require__(137);
	var canPlay = __webpack_require__(161).canPlay;
	var sortBy = __webpack_require__(171);
	var VPAID_EVENTS = __webpack_require__(160);
	var HTML_MEDIA_EVENTS = __webpack_require__(173);
	var HTMLVideoTracker = __webpack_require__(174);
	var EventProxy = __webpack_require__(176);

	function on(video, event, handler) {
	    return video.addEventListener(event, handler, false);
	}

	function off(video, event, handler) {
	    return video.removeEventListener(event, handler, false);
	}

	function once(video, event, handler) {
	    return on(video, event, function onevent() {
	        off(video, event, onevent);
	        return handler.apply(this, arguments);
	    });
	}

	function method(implementation, promiseify) {
	    function getError() {
	        return new Error('The <video> has not been loaded.');
	    }

	    return function callImplementation() /*...args*/{
	        if (!this.video) {
	            if (promiseify) {
	                return LiePromise.reject(getError());
	            } else {
	                throw getError();
	            }
	        }

	        return implementation.apply(this, arguments);
	    };
	}

	function pickMediaFile(mediaFiles, dimensions) {
	    var width = dimensions.width;
	    var items = mediaFiles.map(function (mediaFile) {
	        return {
	            mediaFile: mediaFile,
	            playability: canPlay(mediaFile.type)
	        };
	    }).filter(function (config) {
	        return config.playability > 0;
	    }).sort(sortBy('-playability', '-mediaFile.bitrate'));
	    var distances = items.map(function (item) {
	        return Math.abs(width - item.mediaFile.width);
	    });
	    var item = items[distances.indexOf(Math.min.apply(Math, distances))];

	    return !item || item.playability < 1 ? null : item.mediaFile;
	}

	function HTMLVideo(container) {
	    this.container = container;
	    this.video = null;

	    this.__private__ = {
	        hasPlayed: false
	    };
	}
	inherits(HTMLVideo, EventEmitter);
	Object.defineProperties(HTMLVideo.prototype, {
	    adRemainingTime: { get: method(function getAdRemainingTime() {
	            return this.video.duration - this.video.currentTime;
	        }) },
	    adDuration: { get: method(function getAdDuration() {
	            return this.video.duration;
	        }) },
	    adVolume: {
	        get: method(function getAdVolume() {
	            return this.video.volume;
	        }),
	        set: method(function setAdVolume(volume) {
	            this.video.volume = volume;
	        })
	    }
	});

	HTMLVideo.prototype.load = function load(mediaFiles) {
	    var self = this;

	    return new LiePromise(function loadCreative(resolve, reject) {
	        var video = document.createElement('video');
	        var mediaFile = pickMediaFile(mediaFiles, self.container.getBoundingClientRect());

	        if (!mediaFile) {
	            return reject(new Error('There are no playable <MediaFile>s.'));
	        }

	        video.setAttribute('webkit-playsinline', "");
	        video.setAttribute('playsinline', "");
	        video.src = mediaFile.uri;
	        video.preload = 'auto';

	        video.style.display = 'block';
	        video.style.width = '100%';
	        video.style.height = '100%';
	        video.style.objectFit = 'contain';

	        once(video, HTML_MEDIA_EVENTS.LOADEDMETADATA, function onloadedmetadata() {
	            var tracker = new HTMLVideoTracker(video);
	            var proxy = new EventProxy(VPAID_EVENTS);

	            proxy.from(tracker).to(self);

	            self.video = video;
	            resolve(self);

	            self.emit(VPAID_EVENTS.AdLoaded);

	            on(video, HTML_MEDIA_EVENTS.DURATIONCHANGE, function ondurationchange() {
	                self.emit(VPAID_EVENTS.AdDurationChange);
	            });
	            on(video, HTML_MEDIA_EVENTS.VOLUMECHANGE, function onvolumechange() {
	                self.emit(VPAID_EVENTS.AdVolumeChange);
	            });
	        });

	        once(video, HTML_MEDIA_EVENTS.ERROR, function onerror() {
	            var error = video.error;

	            self.emit(VPAID_EVENTS.AdError, error.message);
	            reject(error);
	        });

	        once(video, HTML_MEDIA_EVENTS.PLAYING, function onplaying() {
	            self.__private__.hasPlayed = true;
	            self.emit(VPAID_EVENTS.AdImpression);
	        });

	        once(video, HTML_MEDIA_EVENTS.ENDED, function onended() {
	            self.stopAd();
	        });

	        on(video, 'click', function onclick() {
	            self.emit(VPAID_EVENTS.AdClickBackground, null, null, true);
	        });

	        self.container.appendChild(video);
	    });
	};

	HTMLVideo.prototype.startAd = method(function startAd() {
	    console.log('start ad');

	    var self = this;
	    var video = this.video;
	    if (this.__private__.hasPlayed) {
	        return LiePromise.reject(new Error('The ad has already been started.'));
	    }

	    return new LiePromise(function callPlay(resolve) {

	        once(video, HTML_MEDIA_EVENTS.PLAYING, function onplaying() {
	            resolve(self);
	            self.emit(VPAID_EVENTS.AdStarted);
	        });

	        // Retry play ad
	        setTimeout(function () {
	            if (!video.isPlaying) {
	                video.play();
	            }
	        }, 1000);

	        return video.play();
	    });
	}, true);

	HTMLVideo.prototype.stopAd = method(function stopAd(isSkip) {
	    this.container.removeChild(this.video);
	    if (isSkip) {
	        this.emit(VPAID_EVENTS.AdSkipped);
	    } else {
	        this.emit(VPAID_EVENTS.AdStopped);
	    }

	    return LiePromise.resolve(this);
	}, true);

	HTMLVideo.prototype.pauseAd = method(function pauseAd() {
	    var self = this;
	    var video = this.video;

	    if (this.video.paused) {
	        return LiePromise.resolve(this);
	    }

	    return new LiePromise(function callPause(resolve) {
	        once(video, HTML_MEDIA_EVENTS.PAUSE, function onpause() {
	            resolve(self);
	            self.emit(VPAID_EVENTS.AdPaused);
	        });

	        return video.pause();
	    });
	}, true);

	HTMLVideo.prototype.resumeAd = method(function resumeAd() {
	    var self = this;
	    var video = this.video;

	    if (!this.__private__.hasPlayed) {
	        return LiePromise.reject(new Error('The ad has not been started yet.'));
	    }

	    if (!this.video.paused) {
	        return LiePromise.resolve(this);
	    }

	    return new LiePromise(function callPlay(resolve) {
	        once(video, HTML_MEDIA_EVENTS.PLAY, function onplay() {
	            resolve(self);
	            self.emit(VPAID_EVENTS.AdPlaying);
	        });

	        return video.play();
	    });
	}, true);

	module.exports = HTMLVideo;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var objectPath = __webpack_require__(172);
	var sortBy;
	var sort;

	/**
	 * Return a comparator function
	 * @param  {String} property The key to sort by
	 * @return {Function}        Returns the comparator function
	 */
	sort = function sort(property) {
	    var sortOrder = 1;
	    var fn;

	    if (property[0] === "-") {
	        sortOrder = -1;
	        property = property.substr(1);
	    }

	    return function fn(a,b) {
	        var result;
	        if (objectPath.get(a, property) < objectPath.get(b, property)) result = -1;
	        if (objectPath.get(a, property) > objectPath.get(b, property)) result = 1;
	        if (objectPath.get(a, property) === objectPath.get(b, property)) result = 0;
	        return result * sortOrder;
	    }
	};

	/**
	 * Return a comparator function that sorts by multiple keys
	 * @return {Function} Returns the comparator function
	 */
	sortBy = function sortBy() {
	    var properties = arguments;
	    var fn;

	    return function fn(obj1, obj2) {
	        var numberOfProperties = properties.length,
	            result = 0,
	            i = 0;

	        /* try getting a different result from 0 (equal)
	         * as long as we have extra properties to compare
	         */
	        while(result === 0 && i < numberOfProperties) {
	            result = sort(properties[i])(obj1, obj2);
	            i++;
	        }
	        return result;
	    };
	};

	/**
	 * Expose `sortBy`
	 * @type {Function}
	 */
	module.exports = sortBy;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){
	  'use strict';

	  /*istanbul ignore next:cant test*/
	  if (typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = factory();
	  } else if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    // Browser globals
	    root.objectPath = factory();
	  }
	})(this, function(){
	  'use strict';

	  var
	    toStr = Object.prototype.toString,
	    _hasOwnProperty = Object.prototype.hasOwnProperty;

	  function isEmpty(value){
	    if (!value) {
	      return true;
	    }
	    if (isArray(value) && value.length === 0) {
	      return true;
	    } else {
	      for (var i in value) {
	        if (_hasOwnProperty.call(value, i)) {
	          return false;
	        }
	      }
	      return true;
	    }
	  }

	  function toString(type){
	    return toStr.call(type);
	  }

	  function isNumber(value){
	    return typeof value === 'number' || toString(value) === "[object Number]";
	  }

	  function isString(obj){
	    return typeof obj === 'string' || toString(obj) === "[object String]";
	  }

	  function isObject(obj){
	    return typeof obj === 'object' && toString(obj) === "[object Object]";
	  }

	  function isArray(obj){
	    return typeof obj === 'object' && typeof obj.length === 'number' && toString(obj) === '[object Array]';
	  }

	  function isBoolean(obj){
	    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';
	  }

	  function getKey(key){
	    var intKey = parseInt(key);
	    if (intKey.toString() === key) {
	      return intKey;
	    }
	    return key;
	  }

	  function set(obj, path, value, doNotReplace){
	    if (isNumber(path)) {
	      path = [path];
	    }
	    if (isEmpty(path)) {
	      return obj;
	    }
	    if (isString(path)) {
	      return set(obj, path.split('.'), value, doNotReplace);
	    }
	    var currentPath = getKey(path[0]);

	    if (path.length === 1) {
	      var oldVal = obj[currentPath];
	      if (oldVal === void 0 || !doNotReplace) {
	        obj[currentPath] = value;
	      }
	      return oldVal;
	    }

	    if (obj[currentPath] === void 0) {
	      if (isNumber(currentPath)) {
	        obj[currentPath] = [];
	      } else {
	        obj[currentPath] = {};
	      }
	    }

	    return set(obj[currentPath], path.slice(1), value, doNotReplace);
	  }

	  function del(obj, path) {
	    if (isNumber(path)) {
	      path = [path];
	    }

	    if (isEmpty(obj)) {
	      return void 0;
	    }

	    if (isEmpty(path)) {
	      return obj;
	    }
	    if(isString(path)) {
	      return del(obj, path.split('.'));
	    }

	    var currentPath = getKey(path[0]);
	    var oldVal = obj[currentPath];

	    if(path.length === 1) {
	      if (oldVal !== void 0) {
	        if (isArray(obj)) {
	          obj.splice(currentPath, 1);
	        } else {
	          delete obj[currentPath];
	        }
	      }
	    } else {
	      if (obj[currentPath] !== void 0) {
	        return del(obj[currentPath], path.slice(1));
	      }
	    }

	    return obj;
	  }

	  var objectPath = {};

	  objectPath.ensureExists = function (obj, path, value){
	    return set(obj, path, value, true);
	  };

	  objectPath.set = function (obj, path, value, doNotReplace){
	    return set(obj, path, value, doNotReplace);
	  };

	  objectPath.insert = function (obj, path, value, at){
	    var arr = objectPath.get(obj, path);
	    at = ~~at;
	    if (!isArray(arr)) {
	      arr = [];
	      objectPath.set(obj, path, arr);
	    }
	    arr.splice(at, 0, value);
	  };

	  objectPath.empty = function(obj, path) {
	    if (isEmpty(path)) {
	      return obj;
	    }
	    if (isEmpty(obj)) {
	      return void 0;
	    }

	    var value, i;
	    if (!(value = objectPath.get(obj, path))) {
	      return obj;
	    }

	    if (isString(value)) {
	      return objectPath.set(obj, path, '');
	    } else if (isBoolean(value)) {
	      return objectPath.set(obj, path, false);
	    } else if (isNumber(value)) {
	      return objectPath.set(obj, path, 0);
	    } else if (isArray(value)) {
	      value.length = 0;
	    } else if (isObject(value)) {
	      for (i in value) {
	        if (_hasOwnProperty.call(value, i)) {
	          delete value[i];
	        }
	      }
	    } else {
	      return objectPath.set(obj, path, null);
	    }
	  };

	  objectPath.push = function (obj, path /*, values */){
	    var arr = objectPath.get(obj, path);
	    if (!isArray(arr)) {
	      arr = [];
	      objectPath.set(obj, path, arr);
	    }

	    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
	  };

	  objectPath.coalesce = function (obj, paths, defaultValue) {
	    var value;

	    for (var i = 0, len = paths.length; i < len; i++) {
	      if ((value = objectPath.get(obj, paths[i])) !== void 0) {
	        return value;
	      }
	    }

	    return defaultValue;
	  };

	  objectPath.get = function (obj, path, defaultValue){
	    if (isNumber(path)) {
	      path = [path];
	    }
	    if (isEmpty(path)) {
	      return obj;
	    }
	    if (isEmpty(obj)) {
	      return defaultValue;
	    }
	    if (isString(path)) {
	      return objectPath.get(obj, path.split('.'), defaultValue);
	    }

	    var currentPath = getKey(path[0]);

	    if (path.length === 1) {
	      if (obj[currentPath] === void 0) {
	        return defaultValue;
	      }
	      return obj[currentPath];
	    }

	    return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
	  };

	  objectPath.del = function(obj, path) {
	    return del(obj, path);
	  };

	  return objectPath;
	});

/***/ },
/* 173 */
/***/ function(module, exports) {

	'use strict';

	var HTML_MEDIA_EVENTS = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'interruptbegin', 'interruptend', 'loadeddata', 'loadedmetadata', 'loadstart', 'mozaudioavailable', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting'];

	HTML_MEDIA_EVENTS.forEach(function (event) {
	    this[event.toUpperCase()] = event;
	}, HTML_MEDIA_EVENTS);

	Object.freeze(HTML_MEDIA_EVENTS);

	module.exports = HTML_MEDIA_EVENTS;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var VideoTracker = __webpack_require__(175);
	var inherits = __webpack_require__(132).inherits;
	var EVENTS = __webpack_require__(173);

	function HTMLVideoTracker(video) {
	    var self = this;

	    VideoTracker.call(this, Math.floor(video.duration || 0)); // call super()

	    this.video = video;

	    [EVENTS.PLAYING, EVENTS.PAUSE, EVENTS.TIMEUPDATE].forEach(function (event) {
	        return video.addEventListener(event, function onevent() {
	            return self.tick();
	        }, false);
	    });
	}
	inherits(HTMLVideoTracker, VideoTracker);

	HTMLVideoTracker.prototype._getState = function _getState() {
	    return {
	        playing: !this.video.paused,
	        currentTime: this.video.currentTime
	    };
	};

	module.exports = HTMLVideoTracker;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EventEmitter = __webpack_require__(131).EventEmitter;
	var inherits = __webpack_require__(132).inherits;
	var EVENTS = __webpack_require__(160);

	function fire(event, tracker) {
	    if (tracker.fired[event]) {
	        return;
	    }

	    tracker.emit(event);
	    tracker.fired[event] = true;
	}

	function VideoTracker(duration) {
	    EventEmitter.apply(this, arguments); // call super()

	    this.duration = duration;
	    this.seconds = Array.apply([], new Array(duration)).map(function () {
	        return false;
	    });

	    this.fired = [EVENTS.AdVideoStart, EVENTS.AdVideoFirstQuartile, EVENTS.AdVideoMidpoint, EVENTS.AdVideoThirdQuartile, EVENTS.AdVideoProgress, EVENTS.AdVideoComplete].reduce(function (fired, event) {
	        fired[event] = false;
	        return fired;
	    }, {});
	}
	inherits(VideoTracker, EventEmitter);

	VideoTracker.prototype.tick = function tick() {
	    var seconds = this.seconds;
	    var state = this._getState();
	    var index = Math.round(state.currentTime) - 1;
	    var quartileIndices = [1, 2, 3, 4].map(function (quartile) {
	        return Math.floor(this.duration / 4 * quartile);
	    }, this);

	    // Add tracking progress for video has duration > 30s
	    if (this.duration > 30) {
	        quartileIndices.push(30);
	    }

	    function quartileViewed(quartile) {
	        var end = quartileIndices[quartile - 1];

	        return seconds.slice(0, end).every(function (second) {
	            return second === true;
	        });
	    }

	    if (state.playing) {
	        fire(EVENTS.AdVideoStart, this);

	        if (index > -1) {
	            this.seconds[index] = true;
	        }
	    }

	    if (quartileViewed(1)) {
	        fire(EVENTS.AdVideoFirstQuartile, this);
	    }

	    if (quartileViewed(2)) {
	        fire(EVENTS.AdVideoMidpoint, this);
	    }

	    if (quartileViewed(3)) {
	        fire(EVENTS.AdVideoThirdQuartile, this);
	    }

	    if (quartileViewed(4)) {
	        fire(EVENTS.AdVideoComplete, this);
	    }

	    // Tracking progress event for video has duration > 30s
	    if (quartileViewed(5)) {
	        fire(EVENTS.AdVideoProgress, this);
	    }
	};

	module.exports = VideoTracker;

/***/ },
/* 176 */
/***/ function(module, exports) {

	'use strict';

	function proxy(event, source, target) {
	    source.on(event, function emit() /*...args*/{
	        var args = [],
	            length = arguments.length;
	        while (length--) {
	            args[length] = arguments[length];
	        }

	        target.emit.apply(target, [event].concat(args));
	    });
	}

	function init(source, target, events) {
	    events.forEach(function (event) {
	        if (target.listeners(event).length > 0) {
	            proxy(event, source, target);
	        }
	    });

	    target.on('newListener', function handleNewListener(type) {
	        if (events.indexOf(type) > -1 && target.listeners(type).length < 1) {
	            proxy(type, source, target);
	        }
	    });
	}

	function EventProxy(events) {
	    this.events = events.slice();

	    this.__private__ = {
	        target: null,
	        source: null
	    };
	}

	EventProxy.prototype.from = function from(source) {
	    this.__private__.source = source;

	    if (this.__private__.target) {
	        init(source, this.__private__.target, this.events);
	    }

	    return this;
	};

	EventProxy.prototype.to = function to(target) {
	    this.__private__.target = target;

	    if (this.__private__.source) {
	        init(this.__private__.source, target, this.events);
	    }

	    return this;
	};

	module.exports = EventProxy;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EVENTS = __webpack_require__(160);

	function identity(value) {
	    return value;
	}

	function fire(pixels, mapper) {
	    (pixels || []).forEach(function (src) {
	        new Image().src = mapper(src);
	    });
	}

	function PixelReporter(pixels, mapper) {
	    this.pixels = pixels.reduce(function (pixels, item) {
	        (pixels[item.event] || (pixels[item.event] = [])).push(item.uri);
	        return pixels;
	    }, {});

	    this.__private__ = {
	        mapper: mapper || identity
	    };
	}

	PixelReporter.prototype.track = function track(vpaid) {
	    var pixels = this.pixels;
	    var customMapper = this.__private__.mapper;
	    var lastVolume = vpaid.adVolume;

	    function fireType(type, mapper, predicate) {
	        function pixelMapper(url) {
	            return customMapper((mapper || identity)(url));
	        }

	        return function firePixels() {
	            if (!predicate || predicate()) {
	                fire(pixels[type], pixelMapper);
	            }
	        };
	    }

	    vpaid.on(EVENTS.AdSkipped, fireType('skip'));
	    vpaid.on(EVENTS.AdStarted, fireType('creativeView'));
	    vpaid.on(EVENTS.AdVolumeChange, fireType('unmute', null, function () {
	        return lastVolume === 0 && vpaid.adVolume > 0;
	    }));
	    vpaid.on(EVENTS.AdVolumeChange, fireType('mute', null, function () {
	        return lastVolume > 0 && vpaid.adVolume === 0;
	    }));
	    vpaid.on(EVENTS.AdImpression, fireType('impression'));
	    vpaid.on(EVENTS.AdVideoStart, fireType('start'));
	    vpaid.on(EVENTS.AdVideoFirstQuartile, fireType('firstQuartile'));
	    vpaid.on(EVENTS.AdVideoMidpoint, fireType('midpoint'));
	    vpaid.on(EVENTS.AdVideoThirdQuartile, fireType('thirdQuartile'));
	    vpaid.on(EVENTS.AdVideoProgress, fireType('progress'));
	    vpaid.on(EVENTS.AdVideoComplete, fireType('complete'));
	    vpaid.on(EVENTS.AdClickThru, fireType('clickThrough'));
	    vpaid.on(EVENTS.AdUserAcceptInvitation, fireType('acceptInvitationLinear'));
	    vpaid.on(EVENTS.AdUserMinimize, fireType('collapse'));
	    vpaid.on(EVENTS.AdUserClose, fireType('closeLinear'));
	    vpaid.on(EVENTS.AdPaused, fireType('pause'));
	    vpaid.on(EVENTS.AdPlaying, fireType('resume'));
	    vpaid.on(EVENTS.AdError, fireType('error', function (pixel) {
	        return pixel.replace(/\[ERRORCODE\]/g, 901);
	    }));

	    vpaid.on(EVENTS.AdVolumeChange, function updateLastVolume() {
	        lastVolume = vpaid.adVolume;
	    });
	};

	module.exports = PixelReporter;

/***/ },
/* 178 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (cb, secure, timeout) {
	  var win = window,
	      doc = document,
	      el = 'script';

	  var onLoad = function onLoad(r) {
	    win.clearTimeout(timer);
	    if (typeof cb === 'function') cb(r);
	  };

	  if (win.google && win.google.ima) {
	    onLoad(true);

	    return;
	  }

	  var timer = null;
	  var s = secure === true ? 'https:' : '';
	  var first = doc.getElementsByTagName(el)[0];
	  var script = doc.createElement(el);

	  script.src = s + '//imasdk.googleapis.com/js/sdkloader/ima3.js';
	  script.async = true;
	  if (typeof cb === 'function') script.onload = function () {
	    onLoad(true);
	  };
	  first.parentNode.insertBefore(script, first);
	  if (timeout) {
	    timer = win.setTimeout(function () {
	      onLoad(false);
	    }, timeout);
	  }
	};

	module.exports = exports['default']; /**
	                                      * Google IMA HTML5 SDK lazy loader.
	                                      * @function
	                                      * @param {function} The library loaded callback.
	                                      * @param {boolean} Set to true to force HTTPS load protocol. (Default behaviour is to match current protocol)
	                                      * @param {number} The load timeout in milliseconds
	                                      */

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(180);

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _ui_container_plugin = __webpack_require__(104);

	var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _browser = __webpack_require__(3);

	var _browser2 = _interopRequireDefault(_browser);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _poster = __webpack_require__(181);

	var _poster2 = _interopRequireDefault(_poster);

	var _poster3 = __webpack_require__(182);

	var _poster4 = _interopRequireDefault(_poster3);

	var _play = __webpack_require__(65);

	var _play2 = _interopRequireDefault(_play);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PosterPlugin = function (_UIContainerPlugin) {
	  _inherits(PosterPlugin, _UIContainerPlugin);

	  _createClass(PosterPlugin, [{
	    key: 'name',
	    get: function get() {
	      return 'poster';
	    }
	  }, {
	    key: 'template',
	    get: function get() {
	      return (0, _template2.default)(_poster4.default);
	    }
	  }, {
	    key: 'shouldRender',
	    get: function get() {
	      return this.container.playback.name !== 'html_img';
	    }
	  }, {
	    key: 'attributes',
	    get: function get() {
	      return {
	        'class': 'player-poster',
	        'data-poster': ''
	      };
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return {
	        'click': 'clicked',
	        'touch': 'clicked'
	      };
	    }
	  }]);

	  function PosterPlugin(container) {
	    _classCallCheck(this, PosterPlugin);

	    var _this = _possibleConstructorReturn(this, _UIContainerPlugin.call(this, container));

	    _this.isPaused = false;
	    _this.isEnded = false;
	    _this.hasStartedPlaying = false;
	    _this.playRequested = false;
	    _this.render();

	    if (!_browser2.default.isMobile) {
	      _this.$el.css('z-index', '10010 !important');
	    }

	    process.nextTick(function () {
	      return _this.update();
	    });
	    return _this;
	  }

	  PosterPlugin.prototype.bindEvents = function bindEvents() {
	    this.listenTo(this.container, _events2.default.CT_STOP, this.onStop);
	    this.listenTo(this.container, _events2.default.CT_PAUSE, this.onPause);
	    this.listenTo(this.container, _events2.default.CT_PLAY, this.onPlay);
	    this.listenTo(this.container, _events2.default.CT_STATE_BUFFERING, this.update);
	    this.listenTo(this.container, _events2.default.CT_STATE_BUFFERFULL, this.update);
	    this.listenTo(this.container, _events2.default.CT_OPTIONS_CHANGE, this.render);
	    this.listenTo(this.container, _events2.default.CT_ENDED, this.onEnd);
	    this.listenTo(this.container, _events2.default.CT_SHOWNEXT, this.onShowNext);
	    this.listenTo(this.container.playback, _events2.default.PB_PLAY_ERROR_SOURCE, this.onErrorSource);
	  };

	  PosterPlugin.prototype.stopListening = function stopListening() {
	    _UIContainerPlugin.prototype.stopListening.call(this);
	  };

	  PosterPlugin.prototype.onPlay = function onPlay() {
	    this.hasStartedPlaying = true;
	    this.update();
	  };

	  PosterPlugin.prototype.onPause = function onPause() {
	    this.isPaused = true;
	    this.hasStartedPlaying = false;
	    this.playRequested = false;
	    this.update();
	  };

	  PosterPlugin.prototype.onStop = function onStop() {
	    this.hasStartedPlaying = false;
	    this.playRequested = false;
	    this.update();
	  };

	  PosterPlugin.prototype.onEnd = function onEnd() {
	    this.hasStartedPlaying = false;
	    this.playRequested = false;
	    this.isEnded = true;
	    this.update();
	  };

	  PosterPlugin.prototype.onShowNext = function onShowNext() {
	    // this.$el.hide();
	  };

	  PosterPlugin.prototype.onErrorSource = function onErrorSource() {
	    this.$el.show();
	  };

	  PosterPlugin.prototype.showPlayButton = function showPlayButton(show) {
	    if (!this.options.posterPlay || this.options.mimeType == 'audio/mp3') {
	      return;
	    }

	    if (show && (!this.options.chromeless || this.options.allowUserInteraction)) {
	      this.$playButton.show();
	      this.$el.addClass('clickable');
	    } else {
	      this.$playButton.hide();
	      this.$el.removeClass('clickable');
	    }
	  };

	  PosterPlugin.prototype.clicked = function clicked() {
	    if (!this.options.chromeless || this.options.allowUserInteraction) {
	      this.playRequested = true;
	      this.update();
	      this.container.play();
	      this.container.trigger(_events2.default.CT_PRESS_PLAY);
	    }
	    return false;
	  };

	  PosterPlugin.prototype.shouldHideOnPlay = function shouldHideOnPlay() {
	    // Audio broadcasts should keep the poster up; video should hide poster while playing.
	    return !(this.container.playback.name == 'html5_audio' || this.container.playback.isAudioOnly);
	  };

	  PosterPlugin.prototype.update = function update() {
	    if (!this.shouldRender) {
	      return;
	    }
	    var showPlayButton = !this.playRequested && !this.hasStartedPlaying && !this.container.buffering;
	    this.showPlayButton(showPlayButton);
	    if (!this.hasStartedPlaying) {
	      this.$el.show();
	      if (this.isPaused) {
	        this.shouldHideOnPlay() && this.$el.css({ 'background-image': 'none' });
	      }
	    } else {
	      this.container.enableMediaControl();
	      if (this.shouldHideOnPlay()) {
	        this.$el.hide();
	      }
	    }
	  };

	  PosterPlugin.prototype.render = function render() {
	    if (!this.shouldRender) {
	      return;
	    }
	    var style = _styler2.default.getStyleFor(_poster2.default, { baseUrl: this.options.baseUrl, customCSS: this.options.customCSS });
	    this.$el.html(this.template());
	    !this.options.hasAnPlayerInstance && this.$el.append(style);
	    this.getPosterConfig();
	    this.container.$el.append(this.el);
	    this.update();

	    return this;
	  };

	  PosterPlugin.prototype.getPosterConfig = function getPosterConfig() {
	    this.getPosterBackgroundConfig();
	    this.getPosterPlayButtonConfig();
	  };

	  PosterPlugin.prototype.getPosterPlayButtonConfig = function getPosterPlayButtonConfig() {
	    if (this.options.posterPlay) {
	      this.$playWrapper = this.$el.find('.play-wrapper');
	      this.$playWrapper.append(_play2.default);
	      this.$playButton = this.$playWrapper.find('svg');
	      this.$playButton.addClass('poster-icon');
	      this.$playButton.attr('data-poster', '');

	      var playButtonColor = this.options.posterPlayColor;
	      var playButtonOpacity = this.options.posterPlayOpacity;
	      var posterPlayScale = this.options.posterPlayScale;

	      if (playButtonColor) {
	        this.$el.find('svg path').css('fill', playButtonColor);
	      }
	      if (playButtonOpacity && !isNaN(playButtonOpacity)) {
	        this.$playWrapper.css('opacity', playButtonOpacity);
	      }
	      if (posterPlayScale && !isNaN(posterPlayScale)) {
	        this.$playWrapper.css('height', posterPlayScale * 25 + '%');
	      }
	    }

	    if (this.options.mimeType == 'audio/mp3' && this.$playButton) {
	      this.$playButton.hide();
	    }
	  };

	  PosterPlugin.prototype.getPosterBackgroundConfig = function getPosterBackgroundConfig() {
	    if (this.options.type === 'youtube') {
	      this.posterUrl = 'https://img.youtube.com/vi/' + this.options.source + '/0.jpg';
	    }
	    if (this.options.poster) {
	      this.posterUrl = this.options.poster.url || this.options.poster;
	      this.$el.css({ 'background-image': 'url(' + this.posterUrl + ')' });
	    }

	    var posterOpacity = this.options.posterOpacity;
	    if (posterOpacity && !isNaN(posterOpacity)) {
	      this.$el.css('opacity', posterOpacity);
	    }
	  };

	  return PosterPlugin;
	}(_ui_container_plugin2.default);

	exports.default = PosterPlugin;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".player-poster[data-poster] {\n  display: -webkit-box;\n  display: -moz-box;\n  display: box;\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -moz-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  -moz-justify-content: center;\n  -ms-justify-content: center;\n  -o-justify-content: center;\n  justify-content: center;\n  -ms-flex-pack: center;\n  -webkit-box-align: center;\n  -moz-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  -moz-align-items: center;\n  -ms-align-items: center;\n  -o-align-items: center;\n  align-items: center;\n  -ms-flex-align: center;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 10099 !important;\n  top: 0;\n  left: 0;\n  background-color: rgba(255, 255, 255, 0);\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-position: 50% 50%;\n  opacity: 0.5; }\n  .player-poster[data-poster].clickable {\n    cursor: pointer; }\n  .player-poster[data-poster]:hover .play-wrapper[data-poster] {\n    opacity: 1; }\n  .player-poster[data-poster] .play-wrapper[data-poster] {\n    z-index: 10099 !important;\n    width: 100%;\n    height: 35%;\n    margin: 0 auto;\n    opacity: 1;\n    -webkit-transition: opacity 0.1s ease;\n    -moz-transition: opacity 0.1s ease;\n    transition: opacity 0.1s ease; }\n    .player-poster[data-poster] .play-wrapper[data-poster] svg {\n      height: 100%; }\n      .player-poster[data-poster] .play-wrapper[data-poster] svg path {\n        fill: #fff; }\n", ""]);

	// exports


/***/ },
/* 182 */
/***/ function(module, exports) {

	module.exports = "<div class=\"play-wrapper\" data-poster></div>\n";

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(184);

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _html5_video = __webpack_require__(93);

	var _html5_video2 = _interopRequireDefault(_html5_video);

	var _hls = __webpack_require__(185);

	var _hls2 = _interopRequireDefault(_hls);

	var _lodash = __webpack_require__(186);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _utils = __webpack_require__(2);

	var _log = __webpack_require__(6);

	var _log2 = _interopRequireDefault(_log);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AUTO = -1;

	var HLS = function (_HTML5VideoPlayback) {
	  _inherits(HLS, _HTML5VideoPlayback);

	  HLS.prototype._now = function _now() {
	    return (0, _utils.now)();
	  };

	  // the time in the video element which should represent the start of the sliding window
	  // extrapolated to increase in real time (instead of jumping as the early segments are removed)


	  _createClass(HLS, [{
	    key: 'name',
	    get: function get() {
	      return 'hls';
	    }
	  }, {
	    key: 'levels',
	    get: function get() {
	      return this._levels || [];
	    }
	  }, {
	    key: 'currentLevel',
	    get: function get() {
	      if (this._currentLevel === null || this._currentLevel === undefined) {
	        return AUTO;
	      } else {
	        // 0 is a valid level ID
	        return this._currentLevel;
	      }
	    },
	    set: function set(id) {
	      this._currentLevel = id;
	      this.trigger(_events2.default.PB_LEVEL_SWITCH_START);
	      if (this._hls) {
	        this._hls.currentLevel = this._currentLevel;
	      }
	    }
	  }, {
	    key: '_startTime',
	    get: function get() {
	      if (this._playbackType === _playback2.default.LIVE && this._playlistType !== 'EVENT') {
	        return this._extrapolatedStartTime;
	      }
	      return this._playableRegionStartTime;
	    }
	  }, {
	    key: '_extrapolatedStartTime',
	    get: function get() {
	      if (!this._localStartTimeCorrelation) {
	        return this._playableRegionStartTime;
	      }
	      var corr = this._localStartTimeCorrelation;
	      var timePassed = this._now() - corr.local;
	      var extrapolatedWindowStartTime = (corr.remote + timePassed) / 1000;
	      // cap at the end of the extrapolated window duration
	      return Math.min(extrapolatedWindowStartTime, this._playableRegionStartTime + this._extrapolatedWindowDuration);
	    }

	    // the time in the video element which should represent the end of the content
	    // extrapolated to increase in real time (instead of jumping as segments are added)

	  }, {
	    key: '_extrapolatedEndTime',
	    get: function get() {
	      var actualEndTime = this._playableRegionStartTime + this._playableRegionDuration;
	      if (!this._localEndTimeCorrelation) {
	        return actualEndTime;
	      }
	      var corr = this._localEndTimeCorrelation;
	      var timePassed = this._now() - corr.local;
	      var extrapolatedEndTime = (corr.remote + timePassed) / 1000;
	      return Math.max(actualEndTime - this._extrapolatedWindowDuration, Math.min(extrapolatedEndTime, actualEndTime));
	    }
	  }, {
	    key: '_duration',
	    get: function get() {
	      return this._extrapolatedEndTime - this._startTime;
	    }

	    // Returns the duration (seconds) of the window that the extrapolated start time is allowed
	    // to move in before being capped.
	    // The extrapolated start time should never reach the cap at the end of the window as the
	    // window should slide as chunks are removed from the start.
	    // This also applies to the extrapolated end time in the same way.
	    //
	    // If chunks aren't being removed for some reason that the start time will reach and remain fixed at
	    // playableRegionStartTime + extrapolatedWindowDuration
	    //
	    //                                <-- window duration -->
	    // I.e   playableRegionStartTime |-----------------------|
	    //                               | -->   .       .       .
	    //                               .   --> | -->   .       .
	    //                               .       .   --> | -->   .
	    //                               .       .       .   --> |
	    //                               .       .       .       .
	    //                                 extrapolatedStartTime

	  }, {
	    key: '_extrapolatedWindowDuration',
	    get: function get() {
	      if (this._segmentTargetDuration === null) {
	        return 0;
	      }
	      return this._extrapolatedWindowNumSegments * this._segmentTargetDuration;
	    }
	  }]);

	  function HLS() {
	    _classCallCheck(this, HLS);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    // backwards compatibility (TODO: remove on 0.3.0)
	    var _this = _possibleConstructorReturn(this, _HTML5VideoPlayback.call.apply(_HTML5VideoPlayback, [this].concat(args)));

	    _this.options.playback || (_this.options.playback = _this.options);
	    _this._minDvrSize = typeof _this.options.hlsMinimumDvrSize === 'undefined' ? 60 : _this.options.hlsMinimumDvrSize;
	    // The size of the start time extrapolation window measured as a multiple of segments.
	    // Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is
	    // removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are
	    // added/removed every 5.
	    _this._extrapolatedWindowNumSegments = !_this.options.playback || typeof _this.options.playback.extrapolatedWindowNumSegments === 'undefined' ? 2 : _this.options.playback.extrapolatedWindowNumSegments;

	    _this._playbackType = _playback2.default.VOD;
	    _this._lastTimeUpdate = null;
	    _this._lastDuration = null;
	    // for hls streams which have dvr with a sliding window,
	    // the content at the start of the playlist is removed as new
	    // content is appended at the end.
	    // this means the actual playable start time will increase as the
	    // start content is deleted
	    // For streams with dvr where the entire recording is kept from the
	    // beginning this should stay as 0
	    _this._playableRegionStartTime = 0;
	    // {local, remote} remote is the time in the video element that should represent 0
	    //                 local is the system time when the 'remote' measurment took place
	    _this._localStartTimeCorrelation = null;
	    // {local, remote} remote is the time in the video element that should represents the end
	    //                 local is the system time when the 'remote' measurment took place
	    _this._localEndTimeCorrelation = null;
	    // if content is removed from the beginning then this empty area should
	    // be ignored. "playableRegionDuration" excludes the empty area
	    _this._playableRegionDuration = 0;
	    // true when the actual duration is longer than hlsjs's live sync point
	    // when this is false playableRegionDuration will be the actual duration
	    // when this is true playableRegionDuration will exclude the time after the sync point
	    _this._durationExcludesAfterLiveSyncPoint = false;
	    // #EXT-X-TARGETDURATION
	    _this._segmentTargetDuration = null;
	    // #EXT-X-PLAYLIST-TYPE
	    _this._playlistType = null;
	    _this._recoverAttemptsRemaining = _this.options.hlsRecoverAttempts || 16;
	    _this._startTimeUpdateTimer();
	    _this._updateSettings();
	    return _this;
	  }

	  HLS.prototype._setupHls = function _setupHls() {
	    var _this2 = this;

	    this._hls = new _hls2.default(this.options.playback.hlsjsConfig || { capLevelToPlayerSize: true, startLevel: -1 });
	    this._hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
	      return _this2._hls.loadSource(_this2.options.src);
	    });
	    this._hls.on(_hls2.default.Events.LEVEL_LOADED, function (evt, data) {
	      return _this2._updatePlaybackType(evt, data);
	    });
	    this._hls.on(_hls2.default.Events.LEVEL_UPDATED, function (evt, data) {
	      return _this2._onLevelUpdated(evt, data);
	    });
	    this._hls.on(_hls2.default.Events.LEVEL_SWITCH, function (evt, data) {
	      return _this2._onLevelSwitch(evt, data);
	    });
	    this._hls.on(_hls2.default.Events.FRAG_LOADED, function (evt, data) {
	      return _this2._onFragmentLoaded(evt, data);
	    });
	    this._hls.on(_hls2.default.Events.ERROR, function (evt, data) {
	      return _this2._onHLSJSError(evt, data);
	    });
	    this._hls.attachMedia(this.el);
	  };

	  HLS.prototype._recover = function _recover(evt, data) {
	    if (!this._recoveredDecodingError) {
	      this._recoveredDecodingError = true;
	      this._hls.recoverMediaError();
	    } else if (!this._recoveredAudioCodecError) {
	      this._recoveredAudioCodecError = true;
	      this._hls.swapAudioCodec();
	      this._hls.recoverMediaError();
	    } else {
	      _log2.default.error('hlsjs: failed to recover');
	      this.trigger(_events2.default.PB_ERROR, 'hlsjs: could not recover from error, evt ' + evt + ', data ' + data + ' ', this.name);
	    }
	  };

	  // override


	  HLS.prototype._setupSrc = function _setupSrc(srcUrl) {// eslint-disable-line no-unused-vars
	    // this playback manages the src on the video element itself
	  };

	  HLS.prototype._startTimeUpdateTimer = function _startTimeUpdateTimer() {
	    var _this3 = this;

	    this._timeUpdateTimer = setInterval(function () {
	      _this3._onDurationChange();
	      _this3._onTimeUpdate();
	    }, 100);
	  };

	  HLS.prototype._stopTimeUpdateTimer = function _stopTimeUpdateTimer() {
	    clearInterval(this._timeUpdateTimer);
	  };

	  // the duration on the video element itself should not be used
	  // as this does not necesarily represent the duration of the stream
	  // https://github.com/zplayer/zplayer/issues/668#issuecomment-157036678


	  HLS.prototype.getDuration = function getDuration() {
	    return this._duration;
	  };

	  HLS.prototype.getCurrentTime = function getCurrentTime() {
	    // e.g. can be < 0 if user pauses near the start
	    // eventually they will then be kicked to the end by hlsjs if they run out of buffer
	    // before the official start time
	    return Math.max(0, this.el.currentTime - this._startTime);
	  };

	  // the time that "0" now represents relative to when playback started
	  // for a stream with a sliding window this will increase as content is
	  // removed from the beginning


	  HLS.prototype.getStartTimeOffset = function getStartTimeOffset() {
	    return this._startTime;
	  };

	  HLS.prototype.seekPercentage = function seekPercentage(percentage) {
	    var seekTo = this._duration;
	    if (percentage > 0) {
	      seekTo = this._duration * (percentage / 100);
	    }
	    this.seek(seekTo);
	  };

	  HLS.prototype.seek = function seek(time) {
	    if (time < 0) {
	      _log2.default.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.');
	      time = this.getDuration();
	    }
	    // assume live if time within 3 seconds of end of stream
	    this.dvrEnabled && this._updateDvr(time < this.getDuration() - 3);
	    time += this._startTime;
	    _HTML5VideoPlayback.prototype.seek.call(this, time);
	  };

	  HLS.prototype.seekToLivePoint = function seekToLivePoint() {
	    this.seek(this.getDuration());
	  };

	  HLS.prototype._updateDvr = function _updateDvr(status) {
	    this.trigger(_events2.default.PB_DVR, status);
	    this.trigger(_events2.default.PB_STATS_ADD, { 'dvr': status });
	  };

	  HLS.prototype._updateSettings = function _updateSettings() {
	    if (this._playbackType === _playback2.default.VOD) {
	      this.settings.left = ['playpause', 'position', 'duration', 'volume'];
	    } else if (this.dvrEnabled) {
	      this.settings.left = ['playpause', 'volume'];
	    } else {
	      this.settings.left = ['playstop', 'volume'];
	    }

	    this.settings.right = ['fullscreen'];

	    this.settings.seekEnabled = this.isSeekEnabled();
	    this.trigger(_events2.default.PB_SETTINGSUPDATE);
	  };

	  HLS.prototype._onHLSJSError = function _onHLSJSError(evt, data) {
	    // only report/handle errors if they are fatal
	    // hlsjs should automatically handle non fatal errors
	    if (data.fatal) {
	      if (this._recoverAttemptsRemaining > 0) {
	        this._recoverAttemptsRemaining -= 1;
	        switch (data.type) {
	          case _hls2.default.ErrorTypes.NETWORK_ERROR:
	            _log2.default.warn('hlsjs: trying to recover from network error, evt ' + evt + ', data ' + data + ' ', _events2.default.PB_ERROR);
	            this._hls.startLoad();
	            break;
	          case _hls2.default.ErrorTypes.MEDIA_ERROR:
	            _log2.default.warn('hlsjs: trying to recover from media error, evt ' + evt + ', data ' + data + ' ');
	            this._recover(evt, data);
	            break;
	          default:
	            _log2.default.error('hlsjs: trying to recover from error, evt ' + evt + ', data ' + data + ' ');
	            this.trigger(_events2.default.PB_ERROR, 'hlsjs: could not recover from error, evt ' + evt + ', data ' + data + ' ', this.name);
	            break;
	        }
	      } else {
	        _log2.default.error('hlsjs: could not recover from error after maximum number of attempts, evt ' + evt + ', data ' + data + ' ');
	        this.trigger(_events2.default.PB_ERROR, { evt: evt, data: data }, this.name);
	      }
	    } else {
	      if (data.type == _hls2.default.ErrorTypes.NETWORK_ERROR) {
	        this.trigger(_events2.default.PB_ERROR, { evt: evt, data: data }, this.name);
	      }
	      _log2.default.warn('hlsjs: non-fatal error occurred, evt ' + evt + ', data ' + data + ' ');
	    }
	  };

	  HLS.prototype._onTimeUpdate = function _onTimeUpdate() {
	    var update = { current: this.getCurrentTime(), total: this.getDuration() };
	    if ((0, _lodash2.default)(update, this._lastTimeUpdate)) {
	      return;
	    }
	    this._lastTimeUpdate = update;
	    this.trigger(_events2.default.PB_TIMEUPDATE, update, this.name);
	  };

	  HLS.prototype._onDurationChange = function _onDurationChange() {
	    var duration = this.getDuration();
	    if (this._lastDuration === duration) {
	      return;
	    }
	    this._lastDuration = duration;
	    _HTML5VideoPlayback.prototype._onDurationChange.call(this);
	  };

	  HLS.prototype._onProgress = function _onProgress() {
	    if (!this.el.buffered.length) {
	      return;
	    }
	    var buffered = [];
	    var bufferedPos = 0;
	    for (var i = 0; i < this.el.buffered.length; i++) {
	      buffered = [].concat(_toConsumableArray(buffered), [{
	        // for a stream with sliding window dvr something that is buffered my slide off the start of the timeline
	        start: Math.max(0, this.el.buffered.start(i) - this._playableRegionStartTime),
	        end: Math.max(0, this.el.buffered.end(i) - this._playableRegionStartTime)
	      }]);
	      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end) {
	        bufferedPos = i;
	      }
	    }
	    var progress = {
	      start: buffered[bufferedPos].start,
	      current: buffered[bufferedPos].end,
	      total: this.getDuration()
	    };
	    this.trigger(_events2.default.PB_PROGRESS, progress, buffered);
	  };

	  HLS.prototype.play = function play() {
	    if (!this._hls) {
	      this._setupHls();
	    }
	    _HTML5VideoPlayback.prototype.play.call(this);
	    this.el.play();
	  };

	  HLS.prototype.pause = function pause() {
	    if (!this._hls) {
	      return;
	    }
	    _HTML5VideoPlayback.prototype.pause.call(this);
	    if (this.dvrEnabled) {
	      this._updateDvr(true);
	    }
	  };

	  HLS.prototype.stop = function stop() {
	    if (this._hls) {
	      _HTML5VideoPlayback.prototype.stop.call(this);
	      this._hls.destroy();
	      delete this._hls;
	    }
	  };

	  HLS.prototype.destroy = function destroy() {
	    this._stopTimeUpdateTimer();
	    _HTML5VideoPlayback.prototype.destroy.call(this);
	  };

	  HLS.prototype._updatePlaybackType = function _updatePlaybackType(evt, data) {
	    this._playbackType = data.details.live ? _playback2.default.LIVE : data.details.startSN > 0 ? _playback2.default.LIVE_END : _playback2.default.VOD;
	    this._fillLevels();
	    this._onLevelUpdated(evt, data);
	  };

	  HLS.prototype._getResolution = function _getResolution(height) {
	    if (height >= 1080) {
	      return 1080;
	    } else if (height >= 720) {
	      return 720;
	    } else if (height >= 480) {
	      return 480;
	    } else if (height >= 360) {
	      return 360;
	    } else if (height >= 240) {
	      return 240;
	    } else if (height >= 120) {
	      return 120;
	    }

	    return 'Unknown';
	  };

	  HLS.prototype._fillLevels = function _fillLevels() {
	    var _this4 = this;

	    this._levels = this._hls.levels.map(function (level, index) {
	      return {
	        id: index, level: level, label: _this4._getResolution(level.height) != 'Unknown' ? _this4._getResolution(level.height) + 'p' : 'Unknown'
	      };
	    });

	    if (!this.options.isVip && this.options.vipLabels && this.options.vipLabels.length > 0) {
	      var currentId = this._levels.length;
	      for (var i = 0; i < this.options.vipLabels.length; i++) {
	        var vipLevel = { id: currentId + i, label: this.options.vipLabels[i] };
	        this._levels.push(vipLevel);
	      }
	    }
	    this.trigger(_events2.default.PB_LEVELS_AVAILABLE, this._levels);
	  };

	  HLS.prototype._onLevelUpdated = function _onLevelUpdated(evt, data) {
	    this._segmentTargetDuration = data.details.targetduration;
	    this._playlistType = data.details.type || null;

	    var startTimeChanged = false;
	    var durationChanged = false;
	    var fragments = data.details.fragments;
	    var previousPlayableRegionStartTime = this._playableRegionStartTime;
	    var previousPlayableRegionDuration = this._playableRegionDuration;

	    if (fragments.length === 0) {
	      return;
	    }

	    if (this._playableRegionStartTime !== fragments[0].start) {
	      startTimeChanged = true;
	      this._playableRegionStartTime = fragments[0].start;
	    }

	    if (startTimeChanged) {
	      if (!this._localStartTimeCorrelation) {
	        // set the correlation to map to middle of the extrapolation window
	        this._localStartTimeCorrelation = {
	          local: this._now(),
	          remote: (fragments[0].start + this._extrapolatedWindowDuration / 2) * 1000
	        };
	      } else {
	        // check if the correlation still works
	        var corr = this._localStartTimeCorrelation;
	        var timePassed = this._now() - corr.local;
	        // this should point to a time within the extrapolation window
	        var startTime = (corr.remote + timePassed) / 1000;
	        if (startTime < fragments[0].start) {
	          // our start time is now earlier than the first chunk
	          // (maybe the chunk was removed early)
	          // reset correlation so that it sits at the beginning of the first available chunk
	          this._localStartTimeCorrelation = {
	            local: this._now(),
	            remote: fragments[0].start * 1000
	          };
	        } else if (startTime > previousPlayableRegionStartTime + this._extrapolatedWindowDuration) {
	          // start time was past the end of the old extrapolation window (so would have been capped)
	          // see if now that time would be inside the window, and if it would be set the correlation
	          // so that it resumes from the time it was at at the end of the old window
	          // update the correlation so that the time starts counting again from the value it's on now
	          this._localStartTimeCorrelation = {
	            local: this._now(),
	            remote: Math.max(fragments[0].start, previousPlayableRegionStartTime + this._extrapolatedWindowDuration) * 1000
	          };
	        }
	      }
	    }

	    var newDuration = data.details.totalduration;
	    // if it's a live stream then shorten the duration to remove access
	    // to the area after hlsjs's live sync point
	    // seeks to areas after this point sometimes have issues
	    if (this._playbackType === _playback2.default.LIVE) {
	      var fragmentTargetDuration = data.details.targetduration;
	      var hlsjsConfig = this.options.playback || {};
	      var liveSyncDurationCount = hlsjsConfig.liveSyncDurationCount || _hls2.default.DefaultConfig.liveSyncDurationCount;
	      var hiddenAreaDuration = fragmentTargetDuration * liveSyncDurationCount;
	      if (hiddenAreaDuration <= newDuration) {
	        newDuration -= hiddenAreaDuration;
	        this._durationExcludesAfterLiveSyncPoint = true;
	      } else {
	        this._durationExcludesAfterLiveSyncPoint = false;
	      }
	    }

	    if (newDuration !== this._playableRegionDuration) {
	      durationChanged = true;
	      this._playableRegionDuration = newDuration;
	    }

	    // Note the end time is not the playableRegionDuration
	    // The end time will always increase even if content is removed from the beginning
	    var endTime = fragments[0].start + newDuration;
	    var previousEndTime = previousPlayableRegionStartTime + previousPlayableRegionDuration;
	    var endTimeChanged = endTime !== previousEndTime;
	    if (endTimeChanged) {
	      if (!this._localEndTimeCorrelation) {
	        // set the correlation to map to the end
	        this._localEndTimeCorrelation = {
	          local: this._now(),
	          remote: endTime * 1000
	        };
	      } else {
	        // check if the correlation still works
	        var _corr = this._localEndTimeCorrelation;
	        var _timePassed = this._now() - _corr.local;
	        // this should point to a time within the extrapolation window from the end
	        var extrapolatedEndTime = (_corr.remote + _timePassed) / 1000;
	        if (extrapolatedEndTime > endTime) {
	          this._localEndTimeCorrelation = {
	            local: this._now(),
	            remote: endTime * 1000
	          };
	        } else if (extrapolatedEndTime < endTime - this._extrapolatedWindowDuration) {
	          // our extrapolated end time is now earlier than the extrapolation window from the actual end time
	          // (maybe a chunk became available early)
	          // reset correlation so that it sits at the beginning of the extrapolation window from the end time
	          this._localEndTimeCorrelation = {
	            local: this._now(),
	            remote: (endTime - this._extrapolatedWindowDuration) * 1000
	          };
	        } else if (extrapolatedEndTime > previousEndTime) {
	          // end time was past the old end time (so would have been capped)
	          // set the correlation so that it resumes from the time it was at at the end of the old window
	          this._localEndTimeCorrelation = {
	            local: this._now(),
	            remote: previousEndTime * 1000
	          };
	        }
	      }
	    }

	    // now that the values have been updated call any methods that use on them so they get the updated values
	    // immediately
	    durationChanged && this._onDurationChange();
	    startTimeChanged && this._onProgress();
	  };

	  HLS.prototype._onFragmentLoaded = function _onFragmentLoaded(evt, data) {
	    this.trigger(_events2.default.PB_FRAGMENT_LOADED, data);
	  };

	  HLS.prototype._onLevelSwitch = function _onLevelSwitch(evt, data) {
	    if (!this.levels.length) {
	      this._fillLevels();
	    }

	    this.trigger(_events2.default.PB_LEVEL_SWITCH_END);
	    this.trigger(_events2.default.PB_LEVEL_SWITCH, data);

	    var currentLevel = this._hls.levels[data.level];
	    if (currentLevel) {
	      this.highDefinition = currentLevel.height >= 720 || currentLevel.bitrate / 1000 >= 2000;
	      this.trigger(_events2.default.PB_HIGHDEFINITIONUPDATE, this.highDefinition);

	      this.trigger(_events2.default.PB_BITRATE, {
	        height: currentLevel.height,
	        width: currentLevel.width,
	        bandwidth: currentLevel.bitrate,
	        bitrate: currentLevel.bitrate,
	        level: data.level
	      });
	    }
	  };

	  HLS.prototype.getPlaybackType = function getPlaybackType() {
	    return this._playbackType;
	  };

	  HLS.prototype.isSeekEnabled = function isSeekEnabled() {
	    return this._playbackType === _playback2.default.VOD || this.dvrEnabled;
	  };

	  _createClass(HLS, [{
	    key: 'dvrEnabled',
	    get: function get() {
	      // enabled when:
	      // - the duration does not include content after hlsjs's live sync point
	      // - the playable region duration is longer than the configured duration to enable dvr after
	      // - the playback type is LIVE.
	      return this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === _playback2.default.LIVE;
	    }
	  }]);

	  return HLS;
	}(_html5_video2.default);

	exports.default = HLS;


	HLS.canPlay = function (resource, mimeType) {
	  var resourceParts = resource.split('?')[0].match(/.*\.(.*)$/) || [];
	  var isHls = resourceParts.length > 1 && resourceParts[1].toLowerCase() === 'm3u8' || mimeType === 'application/x-mpegURL' || mimeType === 'application/vnd.apple.mpegurl';

	  return !!(_hls2.default.isSupported() && isHls);
	};
	module.exports = exports['default'];

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	},{}],2:[function(_dereq_,module,exports){
	/* jshint ignore:start */
	(function(root) { 
	/* jshint ignore:end */
	  var URLToolkit = {
	    // build an absolute URL from a relative one using the provided baseURL
	    // if relativeURL is an absolute URL it will be returned as is.
	    buildAbsoluteURL: function(baseURL, relativeURL) {
	      // remove any remaining space and CRLF
	      relativeURL = relativeURL.trim();
	      if (/^[a-z]+:/i.test(relativeURL)) {
	        // complete url, not relative
	        return relativeURL;
	      }

	      var relativeURLQuery = null;
	      var relativeURLHash = null;

	      var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);
	      if (relativeURLHashSplit) {
	        relativeURLHash = relativeURLHashSplit[2];
	        relativeURL = relativeURLHashSplit[1];
	      }
	      var relativeURLQuerySplit = /^([^\?]*)(.*)$/.exec(relativeURL);
	      if (relativeURLQuerySplit) {
	        relativeURLQuery = relativeURLQuerySplit[2];
	        relativeURL = relativeURLQuerySplit[1];
	      }

	      var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);
	      if (baseURLHashSplit) {
	        baseURL = baseURLHashSplit[1];
	      }
	      var baseURLQuerySplit = /^([^\?]*)(.*)$/.exec(baseURL);
	      if (baseURLQuerySplit) {
	        baseURL = baseURLQuerySplit[1];
	      }

	      var baseURLDomainSplit = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(baseURL);
	      if (!baseURLDomainSplit) {
	        throw new Error('Error trying to parse base URL.');
	      }
	      
	      // e.g. 'http:', 'https:', ''
	      var baseURLProtocol = baseURLDomainSplit[2] || '';
	      // e.g. 'http://example.com', '//example.com', ''
	      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
	      // e.g. '/a/b/c/playlist.m3u8'
	      var baseURLPath = baseURLDomainSplit[4];

	      var builtURL = null;
	      if (/^\/\//.test(relativeURL)) {
	        // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)
	        builtURL = baseURLProtocol+'//'+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));
	      }
	      else if (/^\//.test(relativeURL)) {
	        // relative url starts with '/' so start from root of domain
	        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));
	      }
	      else {
	        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);
	      }

	      // put the query and hash parts back
	      if (relativeURLQuery) {
	        builtURL += relativeURLQuery;
	      }
	      if (relativeURLHash) {
	        builtURL += relativeURLHash;
	      }
	      return builtURL;
	    },

	    // build an absolute path using the provided basePath
	    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
	    // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
	    buildAbsolutePath: function(basePath, relativePath) {
	      var sRelPath = relativePath;
	      var nUpLn, sDir = '', sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
	      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
	        nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
	        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');
	      }
	      return sDir + sPath.substr(nStart);
	    }
	  };

	/* jshint ignore:start */
	  if(typeof exports === 'object' && typeof module === 'object')
	    module.exports = URLToolkit;
	  else if(typeof define === 'function' && define.amd)
	    define([], function() { return URLToolkit; });
	  else if(typeof exports === 'object')
	    exports["URLToolkit"] = URLToolkit;
	  else
	    root["URLToolkit"] = URLToolkit;
	})(this);
	/* jshint ignore:end */

	},{}],3:[function(_dereq_,module,exports){
	var bundleFn = arguments[3];
	var sources = arguments[4];
	var cache = arguments[5];

	var stringify = JSON.stringify;

	module.exports = function (fn, options) {
	    var wkey;
	    var cacheKeys = Object.keys(cache);

	    for (var i = 0, l = cacheKeys.length; i < l; i++) {
	        var key = cacheKeys[i];
	        var exp = cache[key].exports;
	        // Using babel as a transpiler to use esmodule, the export will always
	        // be an object with the default export as a property of it. To ensure
	        // the existing api and babel esmodule exports are both supported we
	        // check for both
	        if (exp === fn || exp && exp.default === fn) {
	            wkey = key;
	            break;
	        }
	    }

	    if (!wkey) {
	        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
	        var wcache = {};
	        for (var i = 0, l = cacheKeys.length; i < l; i++) {
	            var key = cacheKeys[i];
	            wcache[key] = key;
	        }
	        sources[wkey] = [
	            Function(['require','module','exports'], '(' + fn + ')(self)'),
	            wcache
	        ];
	    }
	    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

	    var scache = {}; scache[wkey] = wkey;
	    sources[skey] = [
	        Function(['require'], (
	            // try to call default if defined to also support babel esmodule
	            // exports
	            'var f = require(' + stringify(wkey) + ');' +
	            '(f.default ? f.default : f)(self);'
	        )),
	        scache
	    ];

	    var workerSources = {};
	    resolveSources(skey);

	    function resolveSources(key) {
	        workerSources[key] = true;

	        for (var depPath in sources[key][1]) {
	            var depKey = sources[key][1][depPath];
	            if (!workerSources[depKey]) {
	                resolveSources(depKey);
	            }
	        }
	    }

	    var src = '(' + bundleFn + ')({'
	        + Object.keys(workerSources).map(function (key) {
	            return stringify(key) + ':['
	                + sources[key][0]
	                + ',' + stringify(sources[key][1]) + ']'
	            ;
	        }).join(',')
	        + '},{},[' + stringify(skey) + '])'
	    ;

	    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

	    var blob = new Blob([src], { type: 'text/javascript' });
	    if (options && options.bare) { return blob; }
	    var workerUrl = URL.createObjectURL(blob);
	    var worker = new Worker(workerUrl);
	    worker.objectURL = workerUrl;
	    return worker;
	};

	},{}],4:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _bufferHelper = _dereq_(30);

	var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	var _ewmaBandwidthEstimator = _dereq_(9);

	var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	var AbrController = function (_EventHandler) {
	  _inherits(AbrController, _EventHandler);

	  function AbrController(hls) {
	    _classCallCheck(this, AbrController);

	    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

	    _this.lastLoadedFragLevel = 0;
	    _this._autoLevelCapping = -1;
	    _this._nextAutoLevel = -1;
	    _this.hls = hls;
	    _this.onCheck = _this.abandonRulesCheck.bind(_this);
	    return _this;
	  }

	  _createClass(AbrController, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.clearTimer();
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onFragLoading',
	    value: function onFragLoading(data) {
	      var frag = data.frag;
	      if (frag.type === 'main') {
	        if (!this.timer) {
	          this.timer = setInterval(this.onCheck, 100);
	        }
	        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
	        // so we need to wait for stream manifest / playlist type to instantiate it.
	        if (!this.bwEstimator) {
	          var hls = this.hls,
	              level = data.frag.level,
	              isLive = hls.levels[level].details.live,
	              config = hls.config,
	              ewmaFast = void 0,
	              ewmaSlow = void 0;

	          if (isLive) {
	            ewmaFast = config.abrEwmaFastLive;
	            ewmaSlow = config.abrEwmaSlowLive;
	          } else {
	            ewmaFast = config.abrEwmaFastVoD;
	            ewmaSlow = config.abrEwmaSlowVoD;
	          }
	          this.bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
	        }
	        this.fragCurrent = frag;
	      }
	    }
	  }, {
	    key: 'abandonRulesCheck',
	    value: function abandonRulesCheck() {
	      /*
	        monitor fragment retrieval time...
	        we compute expected time of arrival of the complete fragment.
	        we compare it to expected time of buffer starvation
	      */
	      var hls = this.hls,
	          v = hls.media,
	          frag = this.fragCurrent,
	          loader = frag.loader,
	          minAutoLevel = this.minAutoLevel;

	      // if loader has been destroyed or loading has been aborted, stop timer and return
	      if (!loader || loader.stats && loader.stats.aborted) {
	        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
	        this.clearTimer();
	        return;
	      }
	      var stats = loader.stats;
	      /* only monitor frag retrieval time if
	      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
	      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
	        var requestDelay = performance.now() - stats.trequest,
	            playbackRate = Math.abs(v.playbackRate);
	        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
	        if (requestDelay > 500 * frag.duration / playbackRate) {
	          var levels = hls.levels,
	              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
	              // byte/s; at least 1 byte/s to avoid division by zero
	          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
	          expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levels[frag.level].bitrate / 8)),
	              pos = v.currentTime,
	              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
	              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
	          // consider emergency switch down only if we have less than 2 frag buffered AND
	          // time to finish loading current fragment is bigger than buffer starvation delay
	          // ie if we risk buffer starvation if bw does not increase quickly
	          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
	            var fragLevelNextLoadedDelay = void 0,
	                nextLoadLevel = void 0;
	            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
	            // we start from current level - 1 and we step down , until we find a matching level
	            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
	              // compute time to load next fragment at lower level
	              // 0.8 : consider only 80% of current bw to be conservative
	              // 8 = bits per byte (bps/Bps)
	              fragLevelNextLoadedDelay = frag.duration * levels[nextLoadLevel].bitrate / (8 * 0.8 * loadRate);
	              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
	                // we found a lower level that be rebuffering free with current estimated bw !
	                break;
	              }
	            }
	            // only emergency switch down if it takes less time to load new fragment at lowest level instead
	            // of finishing loading current one ...
	            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
	              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
	              // force next load level in auto mode
	              hls.nextLoadLevel = nextLoadLevel;
	              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
	              this.bwEstimator.sample(requestDelay, stats.loaded);
	              //abort fragment loading
	              loader.abort();
	              // stop abandon rules timer
	              this.clearTimer();
	              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'onFragLoaded',
	    value: function onFragLoaded(data) {
	      var frag = data.frag;
	      if (frag.type === 'main') {
	        // stop monitoring bw once frag loaded
	        this.clearTimer();
	        // store level id after successful fragment load
	        this.lastLoadedFragLevel = frag.level;
	        // reset forced auto level value so that next level will be selected
	        this._nextAutoLevel = -1;
	        // if fragment has been loaded to perform a bitrate test,
	        if (data.frag.bitrateTest) {
	          var stats = data.stats;
	          stats.tparsed = stats.tbuffered = stats.tload;
	          this.onFragBuffered(data);
	        }
	      }
	    }
	  }, {
	    key: 'onFragBuffered',
	    value: function onFragBuffered(data) {
	      var stats = data.stats,
	          frag = data.frag;
	      // only update stats on first frag buffering
	      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
	      // and leading to wrong bw estimation
	      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
	      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
	        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
	        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
	        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
	        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
	        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
	        this.bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
	        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
	        if (frag.bitrateTest) {
	          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
	        } else {
	          this.bitrateTestDelay = 0;
	        }
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(data) {
	      // stop timer in case of frag loading error
	      switch (data.details) {
	        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
	        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
	          this.clearTimer();
	          break;
	        default:
	          break;
	      }
	    }
	  }, {
	    key: 'clearTimer',
	    value: function clearTimer() {
	      if (this.timer) {
	        clearInterval(this.timer);
	        this.timer = null;
	      }
	    }

	    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

	  }, {
	    key: 'findBestLevel',
	    value: function findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
	      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
	        var levelInfo = levels[i],
	            levelDetails = levelInfo.details,
	            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
	            live = levelDetails ? levelDetails.live : false,
	            adjustedbw = void 0;
	        // follow algorithm captured from stagefright :
	        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
	        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
	        // consider only 80% of the available bandwidth, but if we are switching up,
	        // be even more conservative (70%) to avoid overestimating and immediately
	        // switching back.
	        if (i <= currentLevel) {
	          adjustedbw = bwFactor * currentBw;
	        } else {
	          adjustedbw = bwUpFactor * currentBw;
	        }
	        var bitrate = levels[i].bitrate,
	            fetchDuration = bitrate * avgDuration / adjustedbw;

	        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
	        // if adjusted bw is greater than level bitrate AND
	        if (adjustedbw > bitrate && (
	        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
	        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
	        !fetchDuration || live || fetchDuration < maxFetchDuration)) {
	          // as we are looping from highest to lowest, this will return the best achievable quality level

	          return i;
	        }
	      }
	      // not enough time budget even with quality level 0 ... rebuffering might happen
	      return -1;
	    }
	  }, {
	    key: 'autoLevelCapping',
	    get: function get() {
	      return this._autoLevelCapping;
	    }

	    /** set the capping/max level value that could be used by automatic level selection algorithm **/
	    ,
	    set: function set(newLevel) {
	      this._autoLevelCapping = newLevel;
	    }
	  }, {
	    key: 'nextAutoLevel',
	    get: function get() {
	      var nextAutoLevel = this._nextAutoLevel,
	          bwEstimator = this.bwEstimator,
	          hls = this.hls,
	          levels = hls.levels,
	          minAutoBitrate = hls.config.minAutoBitrate;
	      // in case next auto level has been forced, and bw not available or not reliable
	      if (nextAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
	        // cap next auto level by max auto level
	        return Math.min(nextAutoLevel, this.maxAutoLevel);
	      }
	      // compute next level using ABR logic
	      var nextABRAutoLevel = this.nextABRAutoLevel;
	      if (nextAutoLevel !== -1) {
	        // nextAutoLevel is defined, use it to cap ABR computed quality level
	        nextABRAutoLevel = Math.min(nextAutoLevel, nextABRAutoLevel);
	      }
	      if (minAutoBitrate !== undefined) {
	        while (levels[nextABRAutoLevel].bitrate < minAutoBitrate) {
	          nextABRAutoLevel++;
	        }
	      }
	      return nextABRAutoLevel;
	    },
	    set: function set(nextLevel) {
	      this._nextAutoLevel = nextLevel;
	    }
	  }, {
	    key: 'minAutoLevel',
	    get: function get() {
	      var hls = this.hls,
	          levels = hls.levels,
	          minAutoBitrate = hls.config.minAutoBitrate,
	          len = levels ? levels.length : 0;
	      for (var i = 0; i < len; i++) {
	        if (levels[i].bitrate > minAutoBitrate) {
	          return i;
	        }
	      }
	      return 0;
	    }
	  }, {
	    key: 'maxAutoLevel',
	    get: function get() {
	      var levels = this.hls.levels,
	          autoLevelCapping = this._autoLevelCapping,
	          maxAutoLevel;
	      if (autoLevelCapping === -1 && levels && levels.length) {
	        maxAutoLevel = levels.length - 1;
	      } else {
	        maxAutoLevel = autoLevelCapping;
	      }
	      return maxAutoLevel;
	    }
	  }, {
	    key: 'nextABRAutoLevel',
	    get: function get() {
	      var hls = this.hls,
	          maxAutoLevel = this.maxAutoLevel,
	          levels = hls.levels,
	          config = hls.config,
	          minAutoLevel = this.minAutoLevel;
	      var v = hls.media,
	          currentLevel = this.lastLoadedFragLevel,
	          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
	          pos = v ? v.currentTime : 0,

	      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
	      // if we're playing back at the normal rate.
	      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
	          avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

	      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
	      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

	      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
	      var bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
	      if (bestLevel >= 0) {
	        return bestLevel;
	      } else {
	        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
	        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
	        // if no matching level found, logic will return 0
	        var maxStarvationDelay = config.maxStarvationDelay,
	            bwFactor = config.abrBandWidthFactor,
	            bwUpFactor = config.abrBandWidthUpFactor;
	        if (bufferStarvationDelay === 0) {
	          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
	          var bitrateTestDelay = this.bitrateTestDelay;
	          if (bitrateTestDelay) {
	            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
	            // max video loading delay used in  automatic start level selection :
	            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
	            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
	            maxStarvationDelay = config.maxLoadingDelay - bitrateTestDelay;
	            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
	            // don't use conservative factor on bitrate test
	            bwFactor = bwUpFactor = 1;
	          }
	        }
	        bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
	        return Math.max(bestLevel, 0);
	      }
	    }
	  }]);

	  return AbrController;
	}(_eventHandler2.default);

	exports.default = AbrController;

	},{"26":26,"27":27,"28":28,"30":30,"45":45,"9":9}],5:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _binarySearch = _dereq_(41);

	var _binarySearch2 = _interopRequireDefault(_binarySearch);

	var _bufferHelper = _dereq_(30);

	var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

	var _demuxer = _dereq_(22);

	var _demuxer2 = _interopRequireDefault(_demuxer);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _levelHelper = _dereq_(31);

	var _levelHelper2 = _interopRequireDefault(_levelHelper);

	var _timeRanges = _dereq_(46);

	var _timeRanges2 = _interopRequireDefault(_timeRanges);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var State = {
	  STOPPED: 'STOPPED',
	  STARTING: 'STARTING',
	  IDLE: 'IDLE',
	  PAUSED: 'PAUSED',
	  KEY_LOADING: 'KEY_LOADING',
	  FRAG_LOADING: 'FRAG_LOADING',
	  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
	  WAITING_TRACK: 'WAITING_TRACK',
	  PARSING: 'PARSING',
	  PARSED: 'PARSED',
	  ENDED: 'ENDED',
	  ERROR: 'ERROR'
	};

	var AudioStreamController = function (_EventHandler) {
	  _inherits(AudioStreamController, _EventHandler);

	  function AudioStreamController(hls) {
	    _classCallCheck(this, AudioStreamController);

	    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

	    _this.config = hls.config;
	    _this.audioCodecSwap = false;
	    _this.ticks = 0;
	    _this.ontick = _this.tick.bind(_this);
	    return _this;
	  }

	  _createClass(AudioStreamController, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.stopLoad();
	      if (this.timer) {
	        clearInterval(this.timer);
	        this.timer = null;
	      }
	      _eventHandler2.default.prototype.destroy.call(this);
	      this.state = State.STOPPED;
	    }
	  }, {
	    key: 'startLoad',
	    value: function startLoad(startPosition) {
	      if (this.tracks) {
	        var lastCurrentTime = this.lastCurrentTime;
	        this.stopLoad();
	        if (!this.timer) {
	          this.timer = setInterval(this.ontick, 100);
	        }
	        this.fragLoadError = 0;
	        if (lastCurrentTime > 0 && startPosition === -1) {
	          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
	          this.state = State.IDLE;
	        } else {
	          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
	          this.state = State.STARTING;
	        }
	        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
	        this.tick();
	      } else {
	        this.startPosition = startPosition;
	        this.state = State.STOPPED;
	      }
	    }
	  }, {
	    key: 'stopLoad',
	    value: function stopLoad() {
	      var frag = this.fragCurrent;
	      if (frag) {
	        if (frag.loader) {
	          frag.loader.abort();
	        }
	        this.fragCurrent = null;
	      }
	      this.fragPrevious = null;
	      if (this.demuxer) {
	        this.demuxer.destroy();
	        this.demuxer = null;
	      }
	      this.state = State.STOPPED;
	    }
	  }, {
	    key: 'tick',
	    value: function tick() {
	      this.ticks++;
	      if (this.ticks === 1) {
	        this.doTick();
	        if (this.ticks > 1) {
	          setTimeout(this.tick, 1);
	        }
	        this.ticks = 0;
	      }
	    }
	  }, {
	    key: 'doTick',
	    value: function doTick() {
	      var pos,
	          track,
	          trackDetails,
	          hls = this.hls,
	          config = hls.config;
	      //logger.log('audioStream:' + this.state);
	      switch (this.state) {
	        case State.ERROR:
	        //don't do anything in error state to avoid breaking further ...
	        case State.PAUSED:
	          //don't do anything in paused state either ...
	          break;
	        case State.STARTING:
	          this.state = State.WAITING_TRACK;
	          this.loadedmetadata = false;
	          break;
	        case State.IDLE:
	          // if video not attached AND
	          // start fragment already requested OR start frag prefetch disable
	          // exit loop
	          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
	          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
	            break;
	          }
	          // determine next candidate fragment to be loaded, based on current position and
	          //  end of buffer position
	          // if we have not yet loaded any fragment, start loading from start position
	          if (this.loadedmetadata) {
	            pos = this.media.currentTime;
	          } else {
	            pos = this.nextLoadPosition;
	          }
	          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
	          var bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
	              bufferLen = bufferInfo.len,
	              bufferEnd = bufferInfo.end,
	              fragPrevious = this.fragPrevious,
	              maxBufLen = config.maxMaxBufferLength;

	          // if buffer length is less than maxBufLen try to load a new fragment
	          if (bufferLen < maxBufLen && this.trackId < this.tracks.length) {
	            trackDetails = this.tracks[this.trackId].details;
	            // if track info not retrieved yet, switch state and wait for track retrieval
	            if (typeof trackDetails === 'undefined') {
	              this.state = State.WAITING_TRACK;
	              break;
	            }

	            // we just got done loading the final fragment, check if we need to finalize media stream
	            if (!trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
	              // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
	              // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
	              // between different renditions. using half frag duration should help cope with these cases.
	              if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
	                // Finalize the media stream
	                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
	                this.state = State.ENDED;
	                break;
	              }
	            }

	            // find fragment index, contiguous with end of buffer position
	            var fragments = trackDetails.fragments,
	                fragLen = fragments.length,
	                start = fragments[0].start,
	                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
	                frag = void 0;

	            // if bufferEnd before start of playlist, load first fragment
	            if (bufferEnd < start) {
	              frag = fragments[0];
	            } else {
	              (function () {
	                var foundFrag = void 0;
	                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
	                if (bufferEnd < end) {
	                  if (bufferEnd > end - maxFragLookUpTolerance) {
	                    maxFragLookUpTolerance = 0;
	                  }
	                  foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
	                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
	                    // this is to cope with situations like
	                    // bufferEnd = 9.991
	                    // frag[Ø] : [0,10]
	                    // frag[1] : [10,20]
	                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
	                    //              frag start               frag start+duration
	                    //                  |-----------------------------|
	                    //              <--->                         <--->
	                    //  ...--------><-----------------------------><---------....
	                    // previous frag         matching fragment         next frag
	                    //  return -1             return 0                 return 1
	                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
	                    if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
	                      return 1;
	                    } else if (candidate.start - maxFragLookUpTolerance > bufferEnd) {
	                      return -1;
	                    }
	                    return 0;
	                  });
	                } else {
	                  // reach end of playlist
	                  foundFrag = fragments[fragLen - 1];
	                }
	                if (foundFrag) {
	                  frag = foundFrag;
	                  start = foundFrag.start;
	                  //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
	                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
	                    if (frag.sn < trackDetails.endSN) {
	                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
	                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
	                    } else {
	                      frag = null;
	                    }
	                  }
	                }
	              })();
	            }
	            if (frag) {
	              //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
	              if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
	                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId);
	                this.state = State.KEY_LOADING;
	                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
	              } else {
	                _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
	                // ensure that we are not reloading the same fragments in loop ...
	                if (this.fragLoadIdx !== undefined) {
	                  this.fragLoadIdx++;
	                } else {
	                  this.fragLoadIdx = 0;
	                }
	                if (frag.loadCounter) {
	                  frag.loadCounter++;
	                  var maxThreshold = config.fragLoadingLoopThreshold;
	                  // if this frag has already been loaded 3 times, and if it has been reloaded recently
	                  if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
	                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
	                    return;
	                  }
	                } else {
	                  frag.loadCounter = 1;
	                }
	                frag.loadIdx = this.fragLoadIdx;
	                this.fragCurrent = frag;
	                this.startFragRequested = true;
	                this.nextLoadPosition = frag.start + frag.duration;
	                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
	                this.state = State.FRAG_LOADING;
	              }
	            }
	          }
	          break;
	        case State.WAITING_TRACK:
	          track = this.tracks[this.trackId];
	          // check if playlist is already loaded
	          if (track && track.details) {
	            this.state = State.IDLE;
	          }
	          break;
	        case State.FRAG_LOADING_WAITING_RETRY:
	          var now = performance.now();
	          var retryDate = this.retryDate;
	          media = this.media;
	          var isSeeking = media && media.seeking;
	          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
	          if (!retryDate || now >= retryDate || isSeeking) {
	            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
	            this.state = State.IDLE;
	          }
	          break;
	        case State.STOPPED:
	        case State.FRAG_LOADING:
	        case State.PARSING:
	        case State.PARSED:
	        case State.ENDED:
	          break;
	        default:
	          break;
	      }
	    }
	  }, {
	    key: 'onMediaAttached',
	    value: function onMediaAttached(data) {
	      var media = this.media = this.mediaBuffer = data.media;
	      this.onvseeking = this.onMediaSeeking.bind(this);
	      this.onvended = this.onMediaEnded.bind(this);
	      media.addEventListener('seeking', this.onvseeking);
	      media.addEventListener('ended', this.onvended);
	      var config = this.config;
	      if (this.tracks && config.autoStartLoad) {
	        this.startLoad(config.startPosition);
	      }
	    }
	  }, {
	    key: 'onMediaDetaching',
	    value: function onMediaDetaching() {
	      var media = this.media;
	      if (media && media.ended) {
	        _logger.logger.log('MSE detaching and video ended, reset startPosition');
	        this.startPosition = this.lastCurrentTime = 0;
	      }

	      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
	      var tracks = this.tracks;
	      if (tracks) {
	        // reset fragment load counter
	        tracks.forEach(function (track) {
	          if (track.details) {
	            track.details.fragments.forEach(function (fragment) {
	              fragment.loadCounter = undefined;
	            });
	          }
	        });
	      }
	      // remove video listeners
	      if (media) {
	        media.removeEventListener('seeking', this.onvseeking);
	        media.removeEventListener('ended', this.onvended);
	        this.onvseeking = this.onvseeked = this.onvended = null;
	      }
	      this.media = this.mediaBuffer = null;
	      this.loadedmetadata = false;
	      this.stopLoad();
	    }
	  }, {
	    key: 'onMediaSeeking',
	    value: function onMediaSeeking() {
	      if (this.state === State.ENDED) {
	        // switch to IDLE state to check for potential new fragment
	        this.state = State.IDLE;
	      }
	      if (this.media) {
	        this.lastCurrentTime = this.media.currentTime;
	      }
	      // avoid reporting fragment loop loading error in case user is seeking several times on same position
	      if (this.fragLoadIdx !== undefined) {
	        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
	      }
	      // tick to speed up processing
	      this.tick();
	    }
	  }, {
	    key: 'onMediaEnded',
	    value: function onMediaEnded() {
	      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
	      this.startPosition = this.lastCurrentTime = 0;
	    }
	  }, {
	    key: 'onAudioTracksUpdated',
	    value: function onAudioTracksUpdated(data) {
	      _logger.logger.log('audio tracks updated');
	      this.tracks = data.audioTracks;
	    }
	  }, {
	    key: 'onAudioTrackSwitch',
	    value: function onAudioTrackSwitch(data) {
	      // if any URL found on new audio track, it is an alternate audio track
	      var altAudio = !!data.url;
	      this.trackId = data.id;
	      this.state = State.IDLE;

	      this.fragCurrent = null;
	      this.state = State.PAUSED;
	      // destroy useless demuxer when switching audio to main
	      if (!altAudio) {
	        if (this.demuxer) {
	          this.demuxer.destroy();
	          this.demuxer = null;
	        }
	      } else {
	        // switching to audio track, start timer if not already started
	        if (!this.timer) {
	          this.timer = setInterval(this.ontick, 100);
	        }
	      }
	      // flush audio source buffer
	      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
	      this.tick();
	    }
	  }, {
	    key: 'onAudioTrackLoaded',
	    value: function onAudioTrackLoaded(data) {
	      var details = data.details,
	          trackId = data.id,
	          track = this.tracks[trackId],
	          duration = details.totalduration;

	      _logger.logger.log('track ' + trackId + ' loaded [' + details.startSN + ',' + details.endSN + '],duration:' + duration);
	      details.PTSKnown = false;
	      track.details = details;

	      // compute start position
	      if (!this.startFragRequested) {
	        // compute start position if set to -1. use it straight away if value is defined
	        if (this.startPosition === -1) {
	          // first, check if start time offset has been set in playlist, if yes, use this value
	          var startTimeOffset = details.startTimeOffset;
	          if (!isNaN(startTimeOffset)) {
	            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
	            this.startPosition = startTimeOffset;
	          } else {
	            this.startPosition = 0;
	          }
	        }
	        this.nextLoadPosition = this.startPosition;
	      }
	      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
	      if (this.state === State.WAITING_TRACK) {
	        this.state = State.IDLE;
	      }
	      //trigger handler right now
	      this.tick();
	    }
	  }, {
	    key: 'onKeyLoaded',
	    value: function onKeyLoaded() {
	      if (this.state === State.KEY_LOADING) {
	        this.state = State.IDLE;
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onFragLoaded',
	    value: function onFragLoaded(data) {
	      var fragCurrent = this.fragCurrent;
	      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'audio' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
	        this.state = State.PARSING;
	        // transmux the MPEG-TS data to ISO-BMFF segments
	        this.stats = data.stats;
	        var track = this.tracks[this.trackId],
	            details = track.details,
	            duration = details.totalduration,
	            start = fragCurrent.start,
	            trackId = fragCurrent.level,
	            sn = fragCurrent.sn,
	            audioCodec = this.config.defaultAudioCodec || track.audioCodec;
	        this.pendingAppending = 0;
	        if (!this.demuxer) {
	          this.demuxer = new _demuxer2.default(this.hls, 'audio');
	        }
	        _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
	        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
	        var accurateTimeOffset = details.PTSKnown || !details.live;
	        this.demuxer.push(data.payload, audioCodec, null, start, fragCurrent.cc, trackId, sn, duration, fragCurrent.decryptdata, accurateTimeOffset);
	      }
	      this.fragLoadError = 0;
	    }
	  }, {
	    key: 'onFragParsingInitSegment',
	    value: function onFragParsingInitSegment(data) {
	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
	        var tracks = data.tracks,
	            track = void 0;

	        // include levelCodec in audio and video tracks
	        track = tracks.audio;
	        if (track) {
	          track.levelCodec = 'mp4a.40.2';
	          track.id = data.id;
	          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
	          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
	          var initSegment = track.initSegment;
	          if (initSegment) {
	            this.pendingAppending++;
	            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' });
	          }
	          //trigger handler right now
	          this.tick();
	        }
	      }
	    }
	  }, {
	    key: 'onFragParsingData',
	    value: function onFragParsingData(data) {
	      var _this2 = this;

	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
	        var track = this.tracks[this.trackId],
	            frag = this.fragCurrent;

	        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
	        _levelHelper2.default.updateFragPTSDTS(track.details, frag.sn, data.startPTS, data.endPTS);

	        [data.data1, data.data2].forEach(function (buffer) {
	          if (buffer) {
	            _this2.pendingAppending++;
	            _this2.hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'audio', content: 'data' });
	          }
	        });
	        //trigger handler right now
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onFragParsed',
	    value: function onFragParsed(data) {
	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
	        this.stats.tparsed = performance.now();
	        this.state = State.PARSED;
	        this._checkAppendedParsed();
	      }
	    }
	  }, {
	    key: 'onBufferCreated',
	    value: function onBufferCreated(data) {
	      var audioTrack = data.tracks.audio;
	      if (audioTrack) {
	        this.mediaBuffer = audioTrack.buffer;
	        this.loadedmetadata = true;
	      }
	    }
	  }, {
	    key: 'onBufferAppended',
	    value: function onBufferAppended(data) {
	      if (data.parent === 'audio') {
	        switch (this.state) {
	          case State.PARSING:
	          case State.PARSED:
	            this.pendingAppending--;
	            this._checkAppendedParsed();
	            break;
	          default:
	            break;
	        }
	      }
	    }
	  }, {
	    key: '_checkAppendedParsed',
	    value: function _checkAppendedParsed() {
	      //trigger handler right now
	      if (this.state === State.PARSED && this.pendingAppending === 0) {
	        var frag = this.fragCurrent,
	            stats = this.stats;
	        if (frag) {
	          this.fragPrevious = frag;
	          stats.tbuffered = performance.now();
	          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
	          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
	          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
	          this.state = State.IDLE;
	        }
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(data) {
	      var frag = data.frag;
	      // don't handle frag error not related to audio fragment
	      if (frag && frag.type !== 'audio') {
	        return;
	      }
	      switch (data.details) {
	        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
	        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
	          if (!data.fatal) {
	            var loadError = this.fragLoadError;
	            if (loadError) {
	              loadError++;
	            } else {
	              loadError = 1;
	            }
	            var config = this.config;
	            if (loadError <= config.fragLoadingMaxRetry) {
	              this.fragLoadError = loadError;
	              // reset load counter to avoid frag loop loading error
	              frag.loadCounter = 0;
	              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
	              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
	              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
	              this.retryDate = performance.now() + delay;
	              // retry loading state
	              this.state = State.FRAG_LOADING_WAITING_RETRY;
	            } else {
	              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
	              // redispatch same error but with fatal set to true
	              data.fatal = true;
	              this.hls.trigger(_events2.default.ERROR, data);
	              this.state = State.ERROR;
	            }
	          }
	          break;
	        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
	        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
	        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
	        case _errors.ErrorDetails.KEY_LOAD_ERROR:
	        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
	          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
	          if (this.state !== State.ERROR) {
	            // if fatal error, stop processing, otherwise move to IDLE to retry loading
	            this.state = data.fatal ? State.ERROR : State.IDLE;
	            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
	          }
	          break;
	        default:
	          break;
	      }
	    }
	  }, {
	    key: 'onBufferFlushed',
	    value: function onBufferFlushed() {
	      // increase fragment load Index to avoid frag loop loading error after buffer flush
	      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
	      // move to IDLE once flush complete. this should trigger new fragment loading
	      this.state = State.IDLE;
	      // reset reference to frag
	      this.fragPrevious = null;
	      this.tick();
	    }
	  }]);

	  return AudioStreamController;
	}(_eventHandler2.default);

	exports.default = AudioStreamController;

	},{"22":22,"26":26,"27":27,"28":28,"30":30,"31":31,"41":41,"45":45,"46":46}],6:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var AudioTrackController = function (_EventHandler) {
	  _inherits(AudioTrackController, _EventHandler);

	  function AudioTrackController(hls) {
	    _classCallCheck(this, AudioTrackController);

	    return _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));
	  }

	  _createClass(AudioTrackController, [{
	    key: 'destroy',
	    value: function destroy() {
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onManifestLoading',
	    value: function onManifestLoading() {
	      // reset audio tracks on manifest loading
	      this.tracks = [];
	      this.trackId = -1;
	    }
	  }, {
	    key: 'onManifestLoaded',
	    value: function onManifestLoaded(data) {
	      var _this2 = this;

	      var tracks = data.audioTracks || [];
	      var defaultFound = false;
	      this.tracks = tracks;
	      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
	      // loop through available audio tracks and autoselect default if needed
	      var id = 0;
	      tracks.forEach(function (track) {
	        if (track.default) {
	          _this2.audioTrack = id;
	          defaultFound = true;
	          return;
	        }
	        id++;
	      });
	      if (defaultFound === false && tracks.length) {
	        _logger.logger.log('no default audio track defined, use first audio track as default');
	        this.audioTrack = 0;
	      }
	    }
	  }, {
	    key: 'onAudioTrackLoaded',
	    value: function onAudioTrackLoaded(data) {
	      if (data.id < this.tracks.length) {
	        _logger.logger.log('audioTrack ' + data.id + ' loaded');
	        this.tracks[data.id].details = data.details;
	        // check if current playlist is a live playlist
	        if (data.details.live && !this.timer) {
	          // if live playlist we will have to reload it periodically
	          // set reload period to playlist target duration
	          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
	        }
	        if (!data.details.live && this.timer) {
	          // playlist is not live and timer is armed : stopping it
	          clearInterval(this.timer);
	          this.timer = null;
	        }
	      }
	    }

	    /** get alternate audio tracks list from playlist **/

	  }, {
	    key: 'setAudioTrackInternal',
	    value: function setAudioTrackInternal(newId) {
	      // check if level idx is valid
	      if (newId >= 0 && newId < this.tracks.length) {
	        // stopping live reloading timer if any
	        if (this.timer) {
	          clearInterval(this.timer);
	          this.timer = null;
	        }
	        this.trackId = newId;
	        _logger.logger.log('switching to audioTrack ' + newId);
	        var audioTrack = this.tracks[newId],
	            type = audioTrack.type,
	            url = audioTrack.url;
	        this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, { id: newId, type: type, url: url });
	        // check if we need to load playlist for this audio Track
	        var details = audioTrack.details;
	        if (url && (details === undefined || details.live === true)) {
	          // track not retrieved yet, or live playlist we need to (re)load it
	          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
	          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
	        }
	      }
	    }
	  }, {
	    key: 'audioTracks',
	    get: function get() {
	      return this.tracks;
	    }

	    /** get index of the selected audio track (index in audio track lists) **/

	  }, {
	    key: 'audioTrack',
	    get: function get() {
	      return this.trackId;
	    }

	    /** select an audio track, based on its index in audio track lists**/
	    ,
	    set: function set(audioTrackId) {
	      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
	        this.setAudioTrackInternal(audioTrackId);
	      }
	    }
	  }]);

	  return AudioTrackController;
	}(_eventHandler2.default);

	exports.default = AudioTrackController;

	},{"27":27,"28":28,"45":45}],7:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _logger = _dereq_(45);

	var _errors = _dereq_(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var BufferController = function (_EventHandler) {
	  _inherits(BufferController, _EventHandler);

	  function BufferController(hls) {
	    _classCallCheck(this, BufferController);

	    // the value that we have set mediasource.duration to
	    // (the actual duration may be tweaked slighly by the browser)
	    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

	    _this._msDuration = null;
	    // the value that we want to set mediaSource.duration to
	    _this._levelDuration = null;

	    // Source Buffer listeners
	    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
	    _this.onsbe = _this.onSBUpdateError.bind(_this);
	    _this.pendingTracks = {};
	    _this.tracks = {};
	    return _this;
	  }

	  _createClass(BufferController, [{
	    key: 'destroy',
	    value: function destroy() {
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onLevelPtsUpdated',
	    value: function onLevelPtsUpdated(data) {
	      var type = data.type;
	      var audioTrack = this.tracks.audio;

	      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
	      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
	      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
	      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
	      // event if SB is in updating state.
	      // More info here: https://github.com/dailymotion/hls.js/issues/332#issuecomment-257986486

	      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
	        // Chrome audio mp3 track
	        var audioBuffer = this.sourceBuffer.audio;
	        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

	        // adjust timestamp offset if time delta is greater than 100ms
	        if (delta > 0.1) {
	          var updating = audioBuffer.updating;

	          try {
	            audioBuffer.abort();
	          } catch (err) {
	            updating = true;
	            _logger.logger.warn('can not abort audio buffer: ' + err);
	          }

	          if (!updating) {
	            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
	            audioBuffer.timestampOffset = data.start;
	          } else {
	            this.audioTimestampOffset = data.start;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'onManifestParsed',
	    value: function onManifestParsed(data) {
	      var audioExpected = data.audio,
	          videoExpected = data.video,
	          sourceBufferNb = 0;
	      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
	      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
	      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
	      // it will contain the expected nb of source buffers, no need to compute it
	      if (data.altAudio && (audioExpected || videoExpected)) {
	        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
	        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
	      }
	      this.sourceBufferNb = sourceBufferNb;
	    }
	  }, {
	    key: 'onMediaAttaching',
	    value: function onMediaAttaching(data) {
	      var media = this.media = data.media;
	      if (media) {
	        // setup the media source
	        var ms = this.mediaSource = new MediaSource();
	        //Media Source listeners
	        this.onmso = this.onMediaSourceOpen.bind(this);
	        this.onmse = this.onMediaSourceEnded.bind(this);
	        this.onmsc = this.onMediaSourceClose.bind(this);
	        ms.addEventListener('sourceopen', this.onmso);
	        ms.addEventListener('sourceended', this.onmse);
	        ms.addEventListener('sourceclose', this.onmsc);
	        // link video and media Source
	        media.src = URL.createObjectURL(ms);
	      }
	    }
	  }, {
	    key: 'onMediaDetaching',
	    value: function onMediaDetaching() {
	      _logger.logger.log('media source detaching');
	      var ms = this.mediaSource;
	      if (ms) {
	        if (ms.readyState === 'open') {
	          try {
	            // endOfStream could trigger exception if any sourcebuffer is in updating state
	            // we don't really care about checking sourcebuffer state here,
	            // as we are anyway detaching the MediaSource
	            // let's just avoid this exception to propagate
	            ms.endOfStream();
	          } catch (err) {
	            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
	          }
	        }
	        ms.removeEventListener('sourceopen', this.onmso);
	        ms.removeEventListener('sourceended', this.onmse);
	        ms.removeEventListener('sourceclose', this.onmsc);

	        // Detach properly the MediaSource from the HTMLMediaElement as
	        // suggested in https://github.com/w3c/media-source/issues/53.
	        if (this.media) {
	          URL.revokeObjectURL(this.media.src);
	          this.media.removeAttribute('src');
	          this.media.load();
	        }

	        this.mediaSource = null;
	        this.media = null;
	        this.pendingTracks = {};
	        this.tracks = {};
	        this.sourceBuffer = {};
	        this.flushRange = [];
	        this.segments = [];
	        this.appended = 0;
	      }
	      this.onmso = this.onmse = this.onmsc = null;
	      this.hls.trigger(_events2.default.MEDIA_DETACHED);
	    }
	  }, {
	    key: 'onMediaSourceOpen',
	    value: function onMediaSourceOpen() {
	      _logger.logger.log('media source opened');
	      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
	      var mediaSource = this.mediaSource;
	      if (mediaSource) {
	        // once received, don't listen anymore to sourceopen event
	        mediaSource.removeEventListener('sourceopen', this.onmso);
	      }
	      this.checkPendingTracks();
	    }
	  }, {
	    key: 'checkPendingTracks',
	    value: function checkPendingTracks() {
	      // if any buffer codecs pending, check if we have enough to create sourceBuffers
	      var pendingTracks = this.pendingTracks,
	          pendingTracksNb = Object.keys(pendingTracks).length;
	      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
	      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
	        // ok, let's create them now !
	        this.createSourceBuffers(pendingTracks);
	        this.pendingTracks = {};
	        // append any pending segments now !
	        this.doAppending();
	      }
	    }
	  }, {
	    key: 'onMediaSourceClose',
	    value: function onMediaSourceClose() {
	      _logger.logger.log('media source closed');
	    }
	  }, {
	    key: 'onMediaSourceEnded',
	    value: function onMediaSourceEnded() {
	      _logger.logger.log('media source ended');
	    }
	  }, {
	    key: 'onSBUpdateEnd',
	    value: function onSBUpdateEnd() {
	      // update timestampOffset
	      if (this.audioTimestampOffset) {
	        var audioBuffer = this.sourceBuffer.audio;
	        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
	        audioBuffer.timestampOffset = this.audioTimestampOffset;
	        delete this.audioTimestampOffset;
	      }

	      if (this._needsFlush) {
	        this.doFlush();
	      }

	      if (this._needsEos) {
	        this.checkEos();
	      }
	      this.appending = false;
	      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: this.parent });

	      // don't append in flushing mode
	      if (!this._needsFlush) {
	        this.doAppending();
	      }

	      this.updateMediaElementDuration();
	    }
	  }, {
	    key: 'onSBUpdateError',
	    value: function onSBUpdateError(event) {
	      _logger.logger.error('sourceBuffer error:' + event);
	      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
	      // this error might not always be fatal (it is fatal if decode error is set, in that case
	      // it will be followed by a mediaElement error ...)
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
	      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
	    }
	  }, {
	    key: 'onBufferReset',
	    value: function onBufferReset() {
	      var sourceBuffer = this.sourceBuffer;
	      for (var type in sourceBuffer) {
	        var sb = sourceBuffer[type];
	        try {
	          this.mediaSource.removeSourceBuffer(sb);
	          sb.removeEventListener('updateend', this.onsbue);
	          sb.removeEventListener('error', this.onsbe);
	        } catch (err) {}
	      }
	      this.sourceBuffer = {};
	      this.flushRange = [];
	      this.segments = [];
	      this.appended = 0;
	    }
	  }, {
	    key: 'onBufferCodecs',
	    value: function onBufferCodecs(tracks) {
	      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
	      // if sourcebuffers already created, do nothing ...
	      if (Object.keys(this.sourceBuffer).length === 0) {
	        for (var trackName in tracks) {
	          this.pendingTracks[trackName] = tracks[trackName];
	        }
	        var mediaSource = this.mediaSource;
	        if (mediaSource && mediaSource.readyState === 'open') {
	          // try to create sourcebuffers if mediasource opened
	          this.checkPendingTracks();
	        }
	      }
	    }
	  }, {
	    key: 'createSourceBuffers',
	    value: function createSourceBuffers(tracks) {
	      var sourceBuffer = this.sourceBuffer,
	          mediaSource = this.mediaSource;

	      for (var trackName in tracks) {
	        if (!sourceBuffer[trackName]) {
	          var track = tracks[trackName];
	          // use levelCodec as first priority
	          var codec = track.levelCodec || track.codec;
	          var mimeType = track.container + ';codecs=' + codec;
	          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
	          try {
	            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
	            sb.addEventListener('updateend', this.onsbue);
	            sb.addEventListener('error', this.onsbe);
	            this.tracks[trackName] = { codec: codec, container: track.container };
	            track.buffer = sb;
	          } catch (err) {
	            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
	            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
	          }
	        }
	      }
	      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
	    }
	  }, {
	    key: 'onBufferAppending',
	    value: function onBufferAppending(data) {
	      if (!this._needsFlush) {
	        if (!this.segments) {
	          this.segments = [data];
	        } else {
	          this.segments.push(data);
	        }
	        this.doAppending();
	      }
	    }
	  }, {
	    key: 'onBufferAppendFail',
	    value: function onBufferAppendFail(data) {
	      _logger.logger.error('sourceBuffer error:' + data.event);
	      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
	      // this error might not always be fatal (it is fatal if decode error is set, in that case
	      // it will be followed by a mediaElement error ...)
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false, frag: this.fragCurrent });
	    }

	    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

	  }, {
	    key: 'onBufferEos',
	    value: function onBufferEos(data) {
	      var sb = this.sourceBuffer;
	      var dataType = data.type;
	      for (var type in sb) {
	        if (!dataType || type === dataType) {
	          if (!sb[type].ended) {
	            sb[type].ended = true;
	            _logger.logger.log(type + ' sourceBuffer now EOS');
	          }
	        }
	      }
	      this.checkEos();
	    }

	    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

	  }, {
	    key: 'checkEos',
	    value: function checkEos() {
	      var sb = this.sourceBuffer,
	          mediaSource = this.mediaSource;
	      if (!mediaSource || mediaSource.readyState !== 'open') {
	        this._needsEos = false;
	        return;
	      }
	      for (var type in sb) {
	        var sbobj = sb[type];
	        if (!sbobj.ended) {
	          return;
	        }
	        if (sbobj.updating) {
	          this._needsEos = true;
	          return;
	        }
	      }
	      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
	      //Notify the media element that it now has all of the media data
	      try {
	        mediaSource.endOfStream();
	      } catch (e) {
	        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
	      }
	      this._needsEos = false;
	    }
	  }, {
	    key: 'onBufferFlushing',
	    value: function onBufferFlushing(data) {
	      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
	      // attempt flush immediatly
	      this.flushBufferCounter = 0;
	      this.doFlush();
	    }
	  }, {
	    key: 'onLevelUpdated',
	    value: function onLevelUpdated(event) {
	      var details = event.details;
	      if (details.fragments.length === 0) {
	        return;
	      }
	      this._levelDuration = details.totalduration + details.fragments[0].start;
	      this.updateMediaElementDuration();
	    }

	    // https://github.com/dailymotion/hls.js/issues/355

	  }, {
	    key: 'updateMediaElementDuration',
	    value: function updateMediaElementDuration() {
	      var media = this.media,
	          mediaSource = this.mediaSource,
	          sourceBuffer = this.sourceBuffer,
	          levelDuration = this._levelDuration;
	      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
	        return;
	      }
	      for (var type in sourceBuffer) {
	        if (sourceBuffer[type].updating) {
	          // can't set duration whilst a buffer is updating
	          return;
	        }
	      }
	      if (this._msDuration === null) {
	        // initialise to the value that the media source is reporting
	        this._msDuration = mediaSource.duration;
	      }
	      // levelDuration was the last value we set.
	      // not using mediaSource.duration as the browser may tweak this value
	      // only update mediasource duration if its value increase, this is to avoid
	      // flushing already buffered portion when switching between quality level
	      if (levelDuration > this._msDuration && levelDuration > media.duration) {
	        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
	        this._msDuration = mediaSource.duration = levelDuration;
	      }
	    }
	  }, {
	    key: 'doFlush',
	    value: function doFlush() {
	      // loop through all buffer ranges to flush
	      while (this.flushRange.length) {
	        var range = this.flushRange[0];
	        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
	        if (this.flushBuffer(range.start, range.end, range.type)) {
	          // range flushed, remove from flush array
	          this.flushRange.shift();
	          this.flushBufferCounter = 0;
	        } else {
	          this._needsFlush = true;
	          // avoid looping, wait for SB update end to retrigger a flush
	          return;
	        }
	      }
	      if (this.flushRange.length === 0) {
	        // everything flushed
	        this._needsFlush = false;

	        // let's recompute this.appended, which is used to avoid flush looping
	        var appended = 0;
	        var sourceBuffer = this.sourceBuffer;
	        try {
	          for (var type in sourceBuffer) {
	            appended += sourceBuffer[type].buffered.length;
	          }
	        } catch (error) {
	          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
	          // this is harmess at this stage, catch this to avoid reporting an internal exception
	          _logger.logger.error('error while accessing sourceBuffer.buffered');
	        }
	        this.appended = appended;
	        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
	      }
	    }
	  }, {
	    key: 'doAppending',
	    value: function doAppending() {
	      var hls = this.hls,
	          sourceBuffer = this.sourceBuffer,
	          segments = this.segments;
	      if (Object.keys(sourceBuffer).length) {
	        if (this.media.error) {
	          this.segments = [];
	          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
	          return;
	        }
	        if (this.appending) {
	          //logger.log(`sb appending in progress`);
	          return;
	        }
	        if (segments && segments.length) {
	          var segment = segments.shift();
	          try {
	            var type = segment.type;
	            if (sourceBuffer[type]) {
	              // reset sourceBuffer ended flag before appending segment
	              sourceBuffer[type].ended = false;
	              //logger.log(`appending ${segment.content} ${segment.type} SB, size:${segment.data.length}, ${segment.parent}`);
	              this.parent = segment.parent;
	              sourceBuffer[type].appendBuffer(segment.data);
	              this.appendError = 0;
	              this.appended++;
	              this.appending = true;
	            } else {
	              // in case we don't have any source buffer matching with this segment type,
	              // it means that Mediasource fails to create sourcebuffer
	              // discard this segment, and trigger update end
	              this.onSBUpdateEnd();
	            }
	          } catch (err) {
	            // in case any error occured while appending, put back segment in segments table
	            _logger.logger.error('error while trying to append buffer:' + err.message);
	            segments.unshift(segment);
	            var event = { type: _errors.ErrorTypes.MEDIA_ERROR };
	            if (err.code !== 22) {
	              if (this.appendError) {
	                this.appendError++;
	              } else {
	                this.appendError = 1;
	              }
	              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
	              event.frag = this.fragCurrent;
	              /* with UHD content, we could get loop of quota exceeded error until
	                browser is able to evict some data from sourcebuffer. retrying help recovering this
	              */
	              if (this.appendError > hls.config.appendErrorMaxRetry) {
	                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
	                segments = [];
	                event.fatal = true;
	                hls.trigger(_events2.default.ERROR, event);
	                return;
	              } else {
	                event.fatal = false;
	                hls.trigger(_events2.default.ERROR, event);
	              }
	            } else {
	              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
	              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
	              this.segments = [];
	              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
	              hls.trigger(_events2.default.ERROR, event);
	              return;
	            }
	          }
	        }
	      }
	    }

	    /*
	      flush specified buffered range,
	      return true once range has been flushed.
	      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
	    */

	  }, {
	    key: 'flushBuffer',
	    value: function flushBuffer(startOffset, endOffset, typeIn) {
	      var sb,
	          i,
	          bufStart,
	          bufEnd,
	          flushStart,
	          flushEnd,
	          sourceBuffer = this.sourceBuffer;
	      if (Object.keys(sourceBuffer).length) {
	        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime + '/' + startOffset + '/' + endOffset);
	        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
	        if (this.flushBufferCounter < this.appended) {
	          for (var type in sourceBuffer) {
	            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
	            // if no, let's flush all sourcebuffers
	            if (typeIn && type !== typeIn) {
	              continue;
	            }
	            sb = sourceBuffer[type];
	            // we are going to flush buffer, mark source buffer as 'not ended'
	            sb.ended = false;
	            if (!sb.updating) {
	              try {
	                for (i = 0; i < sb.buffered.length; i++) {
	                  bufStart = sb.buffered.start(i);
	                  bufEnd = sb.buffered.end(i);
	                  // workaround firefox not able to properly flush multiple buffered range.
	                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
	                    flushStart = startOffset;
	                    flushEnd = endOffset;
	                  } else {
	                    flushStart = Math.max(bufStart, startOffset);
	                    flushEnd = Math.min(bufEnd, endOffset);
	                  }
	                  /* sometimes sourcebuffer.remove() does not flush
	                     the exact expected time range.
	                     to avoid rounding issues/infinite loop,
	                     only flush buffer range of length greater than 500ms.
	                  */
	                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
	                    this.flushBufferCounter++;
	                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
	                    sb.remove(flushStart, flushEnd);
	                    return false;
	                  }
	                }
	              } catch (e) {
	                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
	              }
	            } else {
	              //logger.log('abort ' + type + ' append in progress');
	              // this will abort any appending in progress
	              //sb.abort();
	              _logger.logger.warn('cannot flush, sb updating in progress');
	              return false;
	            }
	          }
	        } else {
	          _logger.logger.warn('abort flushing too many retries');
	        }
	        _logger.logger.log('buffer flushed');
	      }
	      // everything flushed !
	      return true;
	    }
	  }]);

	  return BufferController;
	}(_eventHandler2.default);

	exports.default = BufferController;

	},{"26":26,"27":27,"28":28,"45":45}],8:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var CapLevelController = function (_EventHandler) {
	  _inherits(CapLevelController, _EventHandler);

	  function CapLevelController(hls) {
	    _classCallCheck(this, CapLevelController);

	    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
	  }

	  _createClass(CapLevelController, [{
	    key: 'destroy',
	    value: function destroy() {
	      if (this.hls.config.capLevelToPlayerSize) {
	        this.media = this.restrictedLevels = null;
	        this.autoLevelCapping = Number.POSITIVE_INFINITY;
	        if (this.timer) {
	          this.timer = clearInterval(this.timer);
	        }
	      }
	    }
	  }, {
	    key: 'onFpsDropLevelCapping',
	    value: function onFpsDropLevelCapping(data) {
	      if (!this.restrictedLevels) {
	        this.restrictedLevels = [];
	      }
	      if (!this.isLevelRestricted(data.droppedLevel)) {
	        this.restrictedLevels.push(data.droppedLevel);
	      }
	    }
	  }, {
	    key: 'onMediaAttaching',
	    value: function onMediaAttaching(data) {
	      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
	    }
	  }, {
	    key: 'onManifestParsed',
	    value: function onManifestParsed(data) {
	      if (this.hls.config.capLevelToPlayerSize) {
	        this.autoLevelCapping = Number.POSITIVE_INFINITY;
	        this.levels = data.levels;
	        this.hls.firstLevel = this.getMaxLevel(data.firstLevel);
	        clearInterval(this.timer);
	        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
	        this.detectPlayerSize();
	      }
	    }
	  }, {
	    key: 'detectPlayerSize',
	    value: function detectPlayerSize() {
	      if (this.media) {
	        var levelsLength = this.levels ? this.levels.length : 0;
	        if (levelsLength) {
	          this.hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
	          if (this.hls.autoLevelCapping > this.autoLevelCapping) {
	            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
	            // usually happen when the user go to the fullscreen mode.
	            this.hls.streamController.nextLevelSwitch();
	          }
	          this.autoLevelCapping = this.hls.autoLevelCapping;
	        }
	      }
	    }

	    /*
	    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
	    */

	  }, {
	    key: 'getMaxLevel',
	    value: function getMaxLevel(capLevelIndex) {
	      var result = 0,
	          i = void 0,
	          level = void 0,
	          mWidth = this.mediaWidth,
	          mHeight = this.mediaHeight,
	          lWidth = 0,
	          lHeight = 0;

	      for (i = 0; i <= capLevelIndex; i++) {
	        level = this.levels[i];
	        if (this.isLevelRestricted(i)) {
	          break;
	        }
	        result = i;
	        lWidth = level.width;
	        lHeight = level.height;
	        if (mWidth <= lWidth || mHeight <= lHeight) {
	          break;
	        }
	      }
	      return result;
	    }
	  }, {
	    key: 'isLevelRestricted',
	    value: function isLevelRestricted(level) {
	      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
	    }
	  }, {
	    key: 'contentScaleFactor',
	    get: function get() {
	      var pixelRatio = 1;
	      try {
	        pixelRatio = window.devicePixelRatio;
	      } catch (e) {}
	      return pixelRatio;
	    }
	  }, {
	    key: 'mediaWidth',
	    get: function get() {
	      var width = void 0;
	      if (this.media) {
	        width = this.media.width || this.media.clientWidth || this.media.offsetWidth;
	        width *= this.contentScaleFactor;
	      }
	      return width;
	    }
	  }, {
	    key: 'mediaHeight',
	    get: function get() {
	      var height = void 0;
	      if (this.media) {
	        height = this.media.height || this.media.clientHeight || this.media.offsetHeight;
	        height *= this.contentScaleFactor;
	      }
	      return height;
	    }
	  }]);

	  return CapLevelController;
	}(_eventHandler2.default);

	exports.default = CapLevelController;

	},{"27":27,"28":28}],9:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _ewma = _dereq_(44);

	var _ewma2 = _interopRequireDefault(_ewma);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EwmaBandWidthEstimator = function () {
	  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
	    _classCallCheck(this, EwmaBandWidthEstimator);

	    this.hls = hls;
	    this.defaultEstimate_ = defaultEstimate;
	    this.minWeight_ = 0.001;
	    this.minDelayMs_ = 50;
	    this.slow_ = new _ewma2.default(slow);
	    this.fast_ = new _ewma2.default(fast);
	  }

	  _createClass(EwmaBandWidthEstimator, [{
	    key: 'sample',
	    value: function sample(durationMs, numBytes) {
	      durationMs = Math.max(durationMs, this.minDelayMs_);
	      var bandwidth = 8000 * numBytes / durationMs,

	      //console.log('instant bw:'+ Math.round(bandwidth));
	      // we weight sample using loading duration....
	      weight = durationMs / 1000;
	      this.fast_.sample(weight, bandwidth);
	      this.slow_.sample(weight, bandwidth);
	    }
	  }, {
	    key: 'canEstimate',
	    value: function canEstimate() {
	      var fast = this.fast_;
	      return fast && fast.getTotalWeight() >= this.minWeight_;
	    }
	  }, {
	    key: 'getEstimate',
	    value: function getEstimate() {
	      if (this.canEstimate()) {
	        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
	        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
	        // Take the minimum of these two estimates.  This should have the effect of
	        // adapting down quickly, but up more slowly.
	        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
	      } else {
	        return this.defaultEstimate_;
	      }
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {}
	  }]);

	  return EwmaBandWidthEstimator;
	}();

	exports.default = EwmaBandWidthEstimator;

	},{"44":44}],10:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var FPSController = function (_EventHandler) {
	  _inherits(FPSController, _EventHandler);

	  function FPSController(hls) {
	    _classCallCheck(this, FPSController);

	    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
	  }

	  _createClass(FPSController, [{
	    key: 'destroy',
	    value: function destroy() {
	      if (this.timer) {
	        clearInterval(this.timer);
	      }
	      this.isVideoPlaybackQualityAvailable = false;
	    }
	  }, {
	    key: 'onMediaAttaching',
	    value: function onMediaAttaching(data) {
	      if (this.hls.config.capLevelOnFPSDrop) {
	        this.video = data.media instanceof HTMLVideoElement ? data.media : null;
	        if (typeof this.video.getVideoPlaybackQuality === 'function') {
	          this.isVideoPlaybackQualityAvailable = true;
	        }
	        clearInterval(this.timer);
	        this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod);
	      }
	    }
	  }, {
	    key: 'checkFPS',
	    value: function checkFPS(video, decodedFrames, droppedFrames) {
	      var currentTime = performance.now();
	      if (decodedFrames) {
	        if (this.lastTime) {
	          var currentPeriod = currentTime - this.lastTime,
	              currentDropped = droppedFrames - this.lastDroppedFrames,
	              currentDecoded = decodedFrames - this.lastDecodedFrames,
	              droppedFPS = 1000 * currentDropped / currentPeriod;
	          this.hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
	          if (droppedFPS > 0) {
	            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
	            if (currentDropped > this.hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
	              var currentLevel = this.hls.currentLevel;
	              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
	              if (currentLevel > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= currentLevel)) {
	                currentLevel = currentLevel - 1;
	                this.hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: this.hls.currentLevel });
	                this.hls.autoLevelCapping = currentLevel;
	                this.hls.streamController.nextLevelSwitch();
	              }
	            }
	          }
	        }
	        this.lastTime = currentTime;
	        this.lastDroppedFrames = droppedFrames;
	        this.lastDecodedFrames = decodedFrames;
	      }
	    }
	  }, {
	    key: 'checkFPSInterval',
	    value: function checkFPSInterval() {
	      if (this.video) {
	        if (this.isVideoPlaybackQualityAvailable) {
	          var videoPlaybackQuality = this.video.getVideoPlaybackQuality();
	          this.checkFPS(this.video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
	        } else {
	          this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);
	        }
	      }
	    }
	  }]);

	  return FPSController;
	}(_eventHandler2.default);

	exports.default = FPSController;

	},{"27":27,"28":28,"45":45}],11:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _logger = _dereq_(45);

	var _errors = _dereq_(26);

	var _bufferHelper = _dereq_(30);

	var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var LevelController = function (_EventHandler) {
	  _inherits(LevelController, _EventHandler);

	  function LevelController(hls) {
	    _classCallCheck(this, LevelController);

	    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

	    _this.ontick = _this.tick.bind(_this);
	    _this._manualLevel = _this._autoLevelCapping = -1;
	    return _this;
	  }

	  _createClass(LevelController, [{
	    key: 'destroy',
	    value: function destroy() {
	      if (this.timer) {
	        clearTimeout(this.timer);
	        this.timer = null;
	      }
	      this._manualLevel = -1;
	    }
	  }, {
	    key: 'startLoad',
	    value: function startLoad() {
	      this.canload = true;
	      // speed up live playlist refresh if timer exists
	      if (this.timer) {
	        this.tick();
	      }
	    }
	  }, {
	    key: 'stopLoad',
	    value: function stopLoad() {
	      this.canload = false;
	    }
	  }, {
	    key: 'onManifestLoaded',
	    value: function onManifestLoaded(data) {
	      var levels0 = [],
	          levels = [],
	          bitrateStart,
	          bitrateSet = {},
	          videoCodecFound = false,
	          audioCodecFound = false,
	          hls = this.hls,
	          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
	          checkSupported = function checkSupported(type, codec) {
	        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
	      };

	      // regroup redundant level together
	      data.levels.forEach(function (level) {
	        if (level.videoCodec) {
	          videoCodecFound = true;
	        }
	        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
	        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
	          level.audioCodec = undefined;
	        }
	        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
	          audioCodecFound = true;
	        }
	        var redundantLevelId = bitrateSet[level.bitrate];
	        if (redundantLevelId === undefined) {
	          bitrateSet[level.bitrate] = levels0.length;
	          level.url = [level.url];
	          level.urlId = 0;
	          levels0.push(level);
	        } else {
	          levels0[redundantLevelId].url.push(level.url);
	        }
	      });

	      // remove audio-only level if we also have levels with audio+video codecs signalled
	      if (videoCodecFound && audioCodecFound) {
	        levels0.forEach(function (level) {
	          if (level.videoCodec) {
	            levels.push(level);
	          }
	        });
	      } else {
	        levels = levels0;
	      }
	      // only keep level with supported audio/video codecs
	      levels = levels.filter(function (level) {
	        var audioCodec = level.audioCodec,
	            videoCodec = level.videoCodec;
	        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
	      });

	      if (levels.length) {
	        // start bitrate is the first bitrate of the manifest
	        bitrateStart = levels[0].bitrate;
	        // sort level on bitrate
	        levels.sort(function (a, b) {
	          return a.bitrate - b.bitrate;
	        });
	        this._levels = levels;
	        // find index of first level in sorted levels
	        for (var i = 0; i < levels.length; i++) {
	          if (levels[i].bitrate === bitrateStart) {
	            this._firstLevel = i;
	            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
	            break;
	          }
	        }
	        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
	      } else {
	        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
	      }
	      return;
	    }
	  }, {
	    key: 'setLevelInternal',
	    value: function setLevelInternal(newLevel) {
	      var levels = this._levels;
	      // check if level idx is valid
	      if (newLevel >= 0 && newLevel < levels.length) {
	        // stopping live reloading timer if any
	        if (this.timer) {
	          clearTimeout(this.timer);
	          this.timer = null;
	        }
	        if (this._level !== newLevel) {
	          _logger.logger.log('switching to level ' + newLevel);
	          this._level = newLevel;
	          this.hls.trigger(_events2.default.LEVEL_SWITCH, { level: newLevel });
	        }
	        var level = levels[newLevel],
	            levelDetails = level.details;
	        // check if we need to load playlist for this level
	        if (!levelDetails || levelDetails.live === true) {
	          // level not retrieved yet, or live playlist we need to (re)load it
	          var urlId = level.urlId;
	          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
	        }
	      } else {
	        // invalid level id given, trigger error
	        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(data) {
	      if (data.fatal) {
	        return;
	      }

	      var details = data.details,
	          hls = this.hls,
	          levelId = void 0,
	          level = void 0,
	          levelError = false,
	          abrController = hls.abrController,
	          minAutoLevel = abrController.minAutoLevel;
	      // try to recover not fatal errors
	      switch (details) {
	        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
	        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
	        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
	        case _errors.ErrorDetails.KEY_LOAD_ERROR:
	        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
	          levelId = data.frag.level;
	          break;
	        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
	        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
	          levelId = data.context.level;
	          levelError = true;
	          break;
	        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
	          levelId = data.level;
	          break;
	        default:
	          break;
	      }
	      /* try to switch to a redundant stream if any available.
	       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
	       * otherwise, we cannot recover this network error ...
	       */
	      if (levelId !== undefined) {
	        level = this._levels[levelId];
	        if (level.urlId < level.url.length - 1) {
	          level.urlId++;
	          level.details = undefined;
	          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
	        } else {
	          // we could try to recover if in auto mode and current level not lowest level (0)
	          var recoverable = this._manualLevel === -1 && levelId;
	          if (recoverable) {
	            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
	            abrController.nextAutoLevel = Math.max(minAutoLevel, levelId - 1);
	          } else if (level && level.details && level.details.live) {
	            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
	            if (levelError) {
	              // reset this._level so that another call to set level() will retrigger a frag load
	              this._level = undefined;
	            }
	            // other errors are handled by stream controller
	          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
	            var media = hls.media,

	            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
	            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
	            if (mediaBuffered) {
	              var retryDelay = hls.config.levelLoadingRetryDelay;
	              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
	              this.timer = setTimeout(this.ontick, retryDelay);
	            } else {
	              _logger.logger.error('cannot recover ' + details + ' error');
	              this._level = undefined;
	              // stopping live reloading timer if any
	              if (this.timer) {
	                clearTimeout(this.timer);
	                this.timer = null;
	              }
	              // redispatch same error but with fatal set to true
	              data.fatal = true;
	              hls.trigger(_events2.default.ERROR, data);
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'onLevelLoaded',
	    value: function onLevelLoaded(data) {
	      // only process level loaded events matching with expected level
	      if (data.level === this._level) {
	        var newDetails = data.details;
	        // if current playlist is a live playlist, arm a timer to reload it
	        if (newDetails.live) {
	          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
	              curLevel = this._levels[data.level],
	              curDetails = curLevel.details;
	          if (curDetails && newDetails.endSN === curDetails.endSN) {
	            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
	            // changed then it MUST wait for a period of one-half the target
	            // duration before retrying.
	            reloadInterval /= 2;
	            _logger.logger.log('same live playlist, reload twice faster');
	          }
	          // decrement reloadInterval with level loading delay
	          reloadInterval -= performance.now() - data.stats.trequest;
	          // in any case, don't reload more than every second
	          reloadInterval = Math.max(1000, Math.round(reloadInterval));
	          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
	          this.timer = setTimeout(this.ontick, reloadInterval);
	        } else {
	          this.timer = null;
	        }
	      }
	    }
	  }, {
	    key: 'tick',
	    value: function tick() {
	      var levelId = this._level;
	      if (levelId !== undefined && this.canload) {
	        var level = this._levels[levelId],
	            urlId = level.urlId;
	        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
	      }
	    }
	  }, {
	    key: 'levels',
	    get: function get() {
	      return this._levels;
	    }
	  }, {
	    key: 'level',
	    get: function get() {
	      return this._level;
	    },
	    set: function set(newLevel) {
	      var levels = this._levels;
	      if (levels && levels.length > newLevel) {
	        if (this._level !== newLevel || levels[newLevel].details === undefined) {
	          this.setLevelInternal(newLevel);
	        }
	      }
	    }
	  }, {
	    key: 'manualLevel',
	    get: function get() {
	      return this._manualLevel;
	    },
	    set: function set(newLevel) {
	      this._manualLevel = newLevel;
	      if (this._startLevel === undefined) {
	        this._startLevel = newLevel;
	      }
	      if (newLevel !== -1) {
	        this.level = newLevel;
	      }
	    }
	  }, {
	    key: 'firstLevel',
	    get: function get() {
	      return this._firstLevel;
	    },
	    set: function set(newLevel) {
	      this._firstLevel = newLevel;
	    }
	  }, {
	    key: 'startLevel',
	    get: function get() {
	      // hls.startLevel takes precedence over config.startLevel
	      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
	      if (this._startLevel === undefined) {
	        var configStartLevel = this.hls.config.startLevel;
	        if (configStartLevel !== undefined) {
	          return configStartLevel;
	        } else {
	          return this._firstLevel;
	        }
	      } else {
	        return this._startLevel;
	      }
	    },
	    set: function set(newLevel) {
	      // if not in autostart level, ensure startLevel is greater than minAutoLevel
	      if (newLevel !== -1) {
	        newLevel = Math.max(newLevel, this.hls.abrController.minAutoLevel);
	      }
	      this._startLevel = newLevel;
	    }
	  }, {
	    key: 'nextLoadLevel',
	    get: function get() {
	      if (this._manualLevel !== -1) {
	        return this._manualLevel;
	      } else {
	        return this.hls.abrController.nextAutoLevel;
	      }
	    },
	    set: function set(nextLevel) {
	      this.level = nextLevel;
	      if (this._manualLevel === -1) {
	        this.hls.abrController.nextAutoLevel = nextLevel;
	      }
	    }
	  }]);

	  return LevelController;
	}(_eventHandler2.default);

	exports.default = LevelController;

	},{"26":26,"27":27,"28":28,"30":30,"45":45}],12:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _binarySearch = _dereq_(41);

	var _binarySearch2 = _interopRequireDefault(_binarySearch);

	var _bufferHelper = _dereq_(30);

	var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

	var _demuxer = _dereq_(22);

	var _demuxer2 = _interopRequireDefault(_demuxer);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _levelHelper = _dereq_(31);

	var _levelHelper2 = _interopRequireDefault(_levelHelper);

	var _timeRanges = _dereq_(46);

	var _timeRanges2 = _interopRequireDefault(_timeRanges);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var State = {
	  STOPPED: 'STOPPED',
	  IDLE: 'IDLE',
	  KEY_LOADING: 'KEY_LOADING',
	  FRAG_LOADING: 'FRAG_LOADING',
	  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
	  WAITING_LEVEL: 'WAITING_LEVEL',
	  PARSING: 'PARSING',
	  PARSED: 'PARSED',
	  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
	  ENDED: 'ENDED',
	  ERROR: 'ERROR'
	};

	var StreamController = function (_EventHandler) {
	  _inherits(StreamController, _EventHandler);

	  function StreamController(hls) {
	    _classCallCheck(this, StreamController);

	    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

	    _this.config = hls.config;
	    _this.audioCodecSwap = false;
	    _this.ticks = 0;
	    _this.ontick = _this.tick.bind(_this);
	    return _this;
	  }

	  _createClass(StreamController, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.stopLoad();
	      if (this.timer) {
	        clearInterval(this.timer);
	        this.timer = null;
	      }
	      _eventHandler2.default.prototype.destroy.call(this);
	      this.state = State.STOPPED;
	    }
	  }, {
	    key: 'startLoad',
	    value: function startLoad(startPosition) {
	      if (this.levels) {
	        var lastCurrentTime = this.lastCurrentTime,
	            hls = this.hls;
	        this.stopLoad();
	        if (!this.timer) {
	          this.timer = setInterval(this.ontick, 100);
	        }
	        this.level = -1;
	        this.fragLoadError = 0;
	        if (!this.startFragRequested) {
	          // determine load level
	          var startLevel = hls.startLevel;
	          if (startLevel === -1) {
	            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
	            startLevel = 0;
	            this.bitrateTest = true;
	          }
	          // set new level to playlist loader : this will trigger start level load
	          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
	          this.level = hls.nextLoadLevel = startLevel;
	          this.loadedmetadata = false;
	        }
	        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
	        if (lastCurrentTime > 0 && startPosition === -1) {
	          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
	          startPosition = lastCurrentTime;
	        }
	        this.state = State.IDLE;
	        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
	        this.tick();
	      } else {
	        _logger.logger.warn('cannot start loading as manifest not parsed yet');
	        this.state = State.STOPPED;
	      }
	    }
	  }, {
	    key: 'stopLoad',
	    value: function stopLoad() {
	      var frag = this.fragCurrent;
	      if (frag) {
	        if (frag.loader) {
	          frag.loader.abort();
	        }
	        this.fragCurrent = null;
	      }
	      this.fragPrevious = null;
	      if (this.demuxer) {
	        this.demuxer.destroy();
	        this.demuxer = null;
	      }
	      this.state = State.STOPPED;
	    }
	  }, {
	    key: 'tick',
	    value: function tick() {
	      this.ticks++;
	      if (this.ticks === 1) {
	        this.doTick();
	        if (this.ticks > 1) {
	          setTimeout(this.tick, 1);
	        }
	        this.ticks = 0;
	      }
	    }
	  }, {
	    key: 'doTick',
	    value: function doTick() {
	      switch (this.state) {
	        case State.ERROR:
	          //don't do anything in error state to avoid breaking further ...
	          break;
	        case State.BUFFER_FLUSHING:
	          // in buffer flushing state, reset fragLoadError counter
	          this.fragLoadError = 0;
	          break;
	        case State.IDLE:
	          // when this returns false there was an error and we shall return immediatly
	          // from current tick
	          if (!this._doTickIdle()) {
	            return;
	          }
	          break;
	        case State.WAITING_LEVEL:
	          var level = this.levels[this.level];
	          // check if playlist is already loaded
	          if (level && level.details) {
	            this.state = State.IDLE;
	          }
	          break;
	        case State.FRAG_LOADING_WAITING_RETRY:
	          var now = performance.now();
	          var retryDate = this.retryDate;
	          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
	          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
	            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
	            this.state = State.IDLE;
	          }
	          break;
	        case State.ERROR:
	        case State.PAUSED:
	        case State.STOPPED:
	        case State.FRAG_LOADING:
	        case State.PARSING:
	        case State.PARSED:
	        case State.ENDED:
	          break;
	        default:
	          break;
	      }
	      // check buffer
	      this._checkBuffer();
	      // check/update current fragment
	      this._checkFragmentChanged();
	    }

	    // Ironically the "idle" state is the on we do the most logic in it seems ....
	    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
	    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

	  }, {
	    key: '_doTickIdle',
	    value: function _doTickIdle() {
	      var hls = this.hls,
	          config = hls.config,
	          media = this.media;

	      // if video not attached AND
	      // start fragment already requested OR start frag prefetch disable
	      // exit loop
	      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
	      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
	        return true;
	      }

	      // if we have not yet loaded any fragment, start loading from start position
	      var pos = void 0;
	      if (this.loadedmetadata) {
	        pos = media.currentTime;
	      } else {
	        pos = this.nextLoadPosition;
	      }
	      // determine next load level
	      var level = hls.nextLoadLevel,
	          levelInfo = this.levels[level],
	          levelBitrate = levelInfo.bitrate,
	          maxBufLen = void 0;

	      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
	      if (levelBitrate) {
	        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
	      } else {
	        maxBufLen = config.maxBufferLength;
	      }
	      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

	      // determine next candidate fragment to be loaded, based on current position and end of buffer position
	      // ensure up to `config.maxMaxBufferLength` of buffer upfront

	      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
	          bufferLen = bufferInfo.len;
	      // Stay idle if we are still with buffer margins
	      if (bufferLen >= maxBufLen) {
	        return true;
	      }

	      // if buffer length is less than maxBufLen try to load a new fragment ...
	      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

	      // set next load level : this will trigger a playlist load if needed
	      this.level = hls.nextLoadLevel = level;

	      var levelDetails = levelInfo.details;
	      // if level info not retrieved yet, switch state and wait for level retrieval
	      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
	      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
	      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
	        this.state = State.WAITING_LEVEL;
	        return true;
	      }

	      // we just got done loading the final fragment, check if we need to finalize media stream
	      var fragPrevious = this.fragPrevious;
	      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
	        // if (we are not seeking AND current position is buffered) OR (if we are seeking but everything (almost) til the end is buffered), let's signal eos
	        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
	        // between different renditions. using half frag duration should help cope with these cases.
	        if (!media.seeking && bufferInfo.len || media.duration - bufferInfo.end <= fragPrevious.duration / 2) {
	          // Finalize the media stream
	          var data = {};
	          if (this.altAudio) {
	            data.type = 'video';
	          }
	          this.hls.trigger(_events2.default.BUFFER_EOS, data);
	          this.state = State.ENDED;
	          return true;
	        }
	      }

	      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
	      return this._fetchPayloadOrEos({ pos: pos, bufferInfo: bufferInfo, levelDetails: levelDetails });
	    }
	  }, {
	    key: '_fetchPayloadOrEos',
	    value: function _fetchPayloadOrEos(_ref) {
	      var pos = _ref.pos,
	          bufferInfo = _ref.bufferInfo,
	          levelDetails = _ref.levelDetails;

	      var fragPrevious = this.fragPrevious,
	          level = this.level,
	          fragments = levelDetails.fragments,
	          fragLen = fragments.length;

	      // empty playlist
	      if (fragLen === 0) {
	        return false;
	      }

	      // find fragment index, contiguous with end of buffer position
	      var start = fragments[0].start,
	          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
	          bufferEnd = bufferInfo.end,
	          frag = void 0;

	      // in case of live playlist we need to ensure that requested position is not located before playlist start
	      if (levelDetails.live) {
	        var initialLiveManifestSize = this.config.initialLiveManifestSize;
	        if (fragLen < initialLiveManifestSize) {
	          _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
	          return false;
	        }

	        frag = this._ensureFragmentAtLivePoint({ levelDetails: levelDetails, bufferEnd: bufferEnd, start: start, end: end, fragPrevious: fragPrevious, fragments: fragments, fragLen: fragLen });
	        // if it explicitely returns null don't load any fragment and exit function now
	        if (frag === null) {
	          return false;
	        }
	      } else {
	        // VoD playlist: if bufferEnd before start of playlist, load first fragment
	        if (bufferEnd < start) {
	          frag = fragments[0];
	        }
	      }
	      if (!frag) {
	        frag = this._findFragment({ start: start, fragPrevious: fragPrevious, fragLen: fragLen, fragments: fragments, bufferEnd: bufferEnd, end: end, levelDetails: levelDetails });
	      }
	      if (frag) {
	        return this._loadFragmentOrKey({ frag: frag, level: level, levelDetails: levelDetails, pos: pos, bufferEnd: bufferEnd });
	      }
	      return true;
	    }
	  }, {
	    key: '_ensureFragmentAtLivePoint',
	    value: function _ensureFragmentAtLivePoint(_ref2) {
	      var levelDetails = _ref2.levelDetails,
	          bufferEnd = _ref2.bufferEnd,
	          start = _ref2.start,
	          end = _ref2.end,
	          fragPrevious = _ref2.fragPrevious,
	          fragments = _ref2.fragments,
	          fragLen = _ref2.fragLen;

	      var config = this.hls.config,
	          media = this.media;

	      var frag = void 0;

	      // check if requested position is within seekable boundaries :
	      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
	      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

	      if (bufferEnd < Math.max(start, end - maxLatency)) {
	        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
	        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
	        bufferEnd = liveSyncPosition;
	        if (media && media.readyState && media.duration > liveSyncPosition) {
	          media.currentTime = liveSyncPosition;
	        }
	      }

	      // if end of buffer greater than live edge, don't load any fragment
	      // this could happen if live playlist intermittently slides in the past.
	      // level 1 loaded [182580161,182580167]
	      // level 1 loaded [182580162,182580169]
	      // Loading 182580168 of [182580162 ,182580169],level 1 ..
	      // Loading 182580169 of [182580162 ,182580169],level 1 ..
	      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
	      // level 1 loaded [182580164,182580171]
	      //
	      // don't return null in case media not loaded yet (readystate === 0)
	      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
	        return null;
	      }

	      if (this.startFragRequested && !levelDetails.PTSKnown) {
	        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
	           try to load frag matching with next SN.
	           even if SN are not synchronized between playlists, loading this frag will help us
	           compute playlist sliding and find the right one after in case it was not the right consecutive one */
	        if (fragPrevious) {
	          var targetSN = fragPrevious.sn + 1;
	          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
	            frag = fragments[targetSN - levelDetails.startSN];
	            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
	          }
	        }
	        if (!frag) {
	          /* we have no idea about which fragment should be loaded.
	             so let's load mid fragment. it will help computing playlist sliding and find the right one
	          */
	          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
	          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
	        }
	      }
	      return frag;
	    }
	  }, {
	    key: '_findFragment',
	    value: function _findFragment(_ref3) {
	      var start = _ref3.start,
	          fragPrevious = _ref3.fragPrevious,
	          fragLen = _ref3.fragLen,
	          fragments = _ref3.fragments,
	          bufferEnd = _ref3.bufferEnd,
	          end = _ref3.end,
	          levelDetails = _ref3.levelDetails;

	      var config = this.hls.config;

	      var frag = void 0,
	          foundFrag = void 0,
	          maxFragLookUpTolerance = config.maxFragLookUpTolerance;

	      if (bufferEnd < end) {
	        if (bufferEnd > end - maxFragLookUpTolerance) {
	          maxFragLookUpTolerance = 0;
	        }
	        foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
	          // offset should be within fragment boundary - config.maxFragLookUpTolerance
	          // this is to cope with situations like
	          // bufferEnd = 9.991
	          // frag[Ø] : [0,10]
	          // frag[1] : [10,20]
	          // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
	          //              frag start               frag start+duration
	          //                  |-----------------------------|
	          //              <--->                         <--->
	          //  ...--------><-----------------------------><---------....
	          // previous frag         matching fragment         next frag
	          //  return -1             return 0                 return 1
	          //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
	          if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
	            return 1;
	          } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
	          else if (candidate.start - maxFragLookUpTolerance > bufferEnd && candidate.start) {
	              return -1;
	            }
	          return 0;
	        });
	      } else {
	        // reach end of playlist
	        foundFrag = fragments[fragLen - 1];
	      }
	      if (foundFrag) {
	        frag = foundFrag;
	        start = foundFrag.start;
	        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
	        if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
	          if (frag.sn < levelDetails.endSN) {
	            var deltaPTS = fragPrevious.deltaPTS,
	                curSNIdx = frag.sn - levelDetails.startSN;
	            // if there is a significant delta between audio and video, larger than max allowed hole,
	            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
	            // let's try to load previous fragment again to get last keyframe
	            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
	            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
	              frag = fragments[curSNIdx - 1];
	              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
	              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
	              fragPrevious.loadCounter--;
	            } else {
	              frag = fragments[curSNIdx + 1];
	              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
	            }
	          } else {
	            frag = null;
	          }
	        }
	      }
	      return frag;
	    }
	  }, {
	    key: '_loadFragmentOrKey',
	    value: function _loadFragmentOrKey(_ref4) {
	      var frag = _ref4.frag,
	          level = _ref4.level,
	          levelDetails = _ref4.levelDetails,
	          pos = _ref4.pos,
	          bufferEnd = _ref4.bufferEnd;

	      var hls = this.hls,
	          config = hls.config;

	      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
	      if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
	        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
	        this.state = State.KEY_LOADING;
	        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
	      } else {
	        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
	        // ensure that we are not reloading the same fragments in loop ...
	        if (this.fragLoadIdx !== undefined) {
	          this.fragLoadIdx++;
	        } else {
	          this.fragLoadIdx = 0;
	        }
	        if (frag.loadCounter) {
	          frag.loadCounter++;
	          var maxThreshold = config.fragLoadingLoopThreshold;
	          // if this frag has already been loaded 3 times, and if it has been reloaded recently
	          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
	            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
	            return false;
	          }
	        } else {
	          frag.loadCounter = 1;
	        }
	        frag.loadIdx = this.fragLoadIdx;
	        this.fragCurrent = frag;
	        this.startFragRequested = true;
	        this.nextLoadPosition = frag.start + frag.duration;
	        frag.autoLevel = hls.autoLevelEnabled;
	        frag.bitrateTest = this.bitrateTest;
	        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
	        // lazy demuxer init, as this could take some time ... do it during frag loading
	        if (!this.demuxer) {
	          this.demuxer = new _demuxer2.default(hls, 'main');
	        }
	        this.state = State.FRAG_LOADING;
	        return true;
	      }
	    }
	  }, {
	    key: 'getBufferRange',
	    value: function getBufferRange(position) {
	      var i,
	          range,
	          bufferRange = this.bufferRange;
	      if (bufferRange) {
	        for (i = bufferRange.length - 1; i >= 0; i--) {
	          range = bufferRange[i];
	          if (position >= range.start && position <= range.end) {
	            return range;
	          }
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'followingBufferRange',
	    value: function followingBufferRange(range) {
	      if (range) {
	        // try to get range of next fragment (500ms after this range)
	        return this.getBufferRange(range.end + 0.5);
	      }
	      return null;
	    }
	  }, {
	    key: '_checkFragmentChanged',
	    value: function _checkFragmentChanged() {
	      var rangeCurrent,
	          currentTime,
	          video = this.media;
	      if (video && video.readyState && video.seeking === false) {
	        currentTime = video.currentTime;
	        /* if video element is in seeked state, currentTime can only increase.
	          (assuming that playback rate is positive ...)
	          As sometimes currentTime jumps back to zero after a
	          media decode error, check this, to avoid seeking back to
	          wrong position after a media decode error
	        */
	        if (currentTime > video.playbackRate * this.lastCurrentTime) {
	          this.lastCurrentTime = currentTime;
	        }
	        if (_bufferHelper2.default.isBuffered(video, currentTime)) {
	          rangeCurrent = this.getBufferRange(currentTime);
	        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
	          /* ensure that FRAG_CHANGED event is triggered at startup,
	            when first video frame is displayed and playback is paused.
	            add a tolerance of 100ms, in case current position is not buffered,
	            check if current pos+100ms is buffered and use that buffer range
	            for FRAG_CHANGED event reporting */
	          rangeCurrent = this.getBufferRange(currentTime + 0.1);
	        }
	        if (rangeCurrent) {
	          var fragPlaying = rangeCurrent.frag;
	          if (fragPlaying !== this.fragPlaying) {
	            this.fragPlaying = fragPlaying;
	            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
	          }
	        }
	      }
	    }

	    /*
	      on immediate level switch :
	       - pause playback if playing
	       - cancel any pending load request
	       - and trigger a buffer flush
	    */

	  }, {
	    key: 'immediateLevelSwitch',
	    value: function immediateLevelSwitch() {
	      _logger.logger.log('immediateLevelSwitch');
	      if (!this.immediateSwitch) {
	        this.immediateSwitch = true;
	        var media = this.media,
	            previouslyPaused = void 0;
	        if (media) {
	          previouslyPaused = media.paused;
	          media.pause();
	        } else {
	          // don't restart playback after instant level switch in case media not attached
	          previouslyPaused = true;
	        }
	        this.previouslyPaused = previouslyPaused;
	      }
	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && fragCurrent.loader) {
	        fragCurrent.loader.abort();
	      }
	      this.fragCurrent = null;
	      // increase fragment load Index to avoid frag loop loading error after buffer flush
	      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
	      this.state = State.BUFFER_FLUSHING;
	      // flush everything
	      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
	    }

	    /*
	       on immediate level switch end, after new fragment has been buffered :
	        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
	        - resume the playback if needed
	    */

	  }, {
	    key: 'immediateLevelSwitchEnd',
	    value: function immediateLevelSwitchEnd() {
	      var media = this.media;
	      if (media && media.buffered.length) {
	        this.immediateSwitch = false;
	        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
	          // only nudge if currentTime is buffered
	          media.currentTime -= 0.0001;
	        }
	        if (!this.previouslyPaused) {
	          media.play();
	        }
	      }
	    }
	  }, {
	    key: 'nextLevelSwitch',
	    value: function nextLevelSwitch() {
	      /* try to switch ASAP without breaking video playback :
	         in order to ensure smooth but quick level switching,
	        we need to find the next flushable buffer range
	        we should take into account new segment fetch time
	      */
	      var media = this.media;
	      // ensure that media is defined and that metadata are available (to retrieve currentTime)
	      if (media && media.readyState) {
	        var fetchdelay = void 0,
	            currentRange = void 0,
	            nextRange = void 0;
	        // increase fragment load Index to avoid frag loop loading error after buffer flush
	        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
	        currentRange = this.getBufferRange(media.currentTime);
	        if (currentRange && currentRange.start > 1) {
	          // flush buffer preceding current fragment (flush until current fragment start offset)
	          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
	          this.state = State.BUFFER_FLUSHING;
	          this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: currentRange.start - 1 });
	        }
	        if (!media.paused) {
	          // add a safety delay of 1s
	          var nextLevelId = this.hls.nextLoadLevel,
	              nextLevel = this.levels[nextLevelId],
	              fragLastKbps = this.fragLastKbps;
	          if (fragLastKbps && this.fragCurrent) {
	            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
	          } else {
	            fetchdelay = 0;
	          }
	        } else {
	          fetchdelay = 0;
	        }
	        //logger.log('fetchdelay:'+fetchdelay);
	        // find buffer range that will be reached once new fragment will be fetched
	        nextRange = this.getBufferRange(media.currentTime + fetchdelay);
	        if (nextRange) {
	          // we can flush buffer range following this one without stalling playback
	          nextRange = this.followingBufferRange(nextRange);
	          if (nextRange) {
	            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
	            var fragCurrent = this.fragCurrent;
	            if (fragCurrent && fragCurrent.loader) {
	              fragCurrent.loader.abort();
	            }
	            this.fragCurrent = null;
	            // flush position is the start position of this new buffer
	            this.state = State.BUFFER_FLUSHING;
	            this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: nextRange.start, endOffset: Number.POSITIVE_INFINITY });
	          }
	        }
	      }
	    }
	  }, {
	    key: 'onMediaAttached',
	    value: function onMediaAttached(data) {
	      var media = this.media = this.mediaBuffer = data.media;
	      this.onvseeking = this.onMediaSeeking.bind(this);
	      this.onvseeked = this.onMediaSeeked.bind(this);
	      this.onvended = this.onMediaEnded.bind(this);
	      media.addEventListener('seeking', this.onvseeking);
	      media.addEventListener('seeked', this.onvseeked);
	      media.addEventListener('ended', this.onvended);
	      var config = this.config;
	      if (this.levels && config.autoStartLoad) {
	        this.hls.startLoad(config.startPosition);
	      }
	    }
	  }, {
	    key: 'onMediaDetaching',
	    value: function onMediaDetaching() {
	      var media = this.media;
	      if (media && media.ended) {
	        _logger.logger.log('MSE detaching and video ended, reset startPosition');
	        this.startPosition = this.lastCurrentTime = 0;
	      }

	      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
	      var levels = this.levels;
	      if (levels) {
	        // reset fragment load counter
	        levels.forEach(function (level) {
	          if (level.details) {
	            level.details.fragments.forEach(function (fragment) {
	              fragment.loadCounter = undefined;
	            });
	          }
	        });
	      }
	      // remove video listeners
	      if (media) {
	        media.removeEventListener('seeking', this.onvseeking);
	        media.removeEventListener('seeked', this.onvseeked);
	        media.removeEventListener('ended', this.onvended);
	        this.onvseeking = this.onvseeked = this.onvended = null;
	      }
	      this.media = this.mediaBuffer = null;
	      this.loadedmetadata = false;
	      this.stopLoad();
	    }
	  }, {
	    key: 'onMediaSeeking',
	    value: function onMediaSeeking() {
	      var media = this.media,
	          currentTime = media ? media.currentTime : undefined,
	          config = this.config;
	      _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
	      if (this.state === State.FRAG_LOADING) {
	        var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, this.config.maxBufferHole),
	            fragCurrent = this.fragCurrent;
	        // check if we are seeking to a unbuffered area AND if frag loading is in progress
	        if (bufferInfo.len === 0 && fragCurrent) {
	          var tolerance = config.maxFragLookUpTolerance,
	              fragStartOffset = fragCurrent.start - tolerance,
	              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
	          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
	          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
	            if (fragCurrent.loader) {
	              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
	              fragCurrent.loader.abort();
	            }
	            this.fragCurrent = null;
	            this.fragPrevious = null;
	            // switch to IDLE state to load new fragment
	            this.state = State.IDLE;
	          } else {
	            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
	          }
	        }
	      } else if (this.state === State.ENDED) {
	        // switch to IDLE state to check for potential new fragment
	        this.state = State.IDLE;
	      }
	      if (media) {
	        this.lastCurrentTime = currentTime;
	      }
	      // avoid reporting fragment loop loading error in case user is seeking several times on same position
	      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
	        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
	      }
	      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
	      if (!this.loadedmetadata) {
	        this.nextLoadPosition = this.startPosition = currentTime;
	      }
	      // tick to speed up processing
	      this.tick();
	    }
	  }, {
	    key: 'onMediaSeeked',
	    value: function onMediaSeeked() {
	      _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));
	      // tick to speed up FRAGMENT_PLAYING triggering
	      this.tick();
	    }
	  }, {
	    key: 'onMediaEnded',
	    value: function onMediaEnded() {
	      _logger.logger.log('media ended');
	      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
	      this.startPosition = this.lastCurrentTime = 0;
	    }
	  }, {
	    key: 'onManifestLoading',
	    value: function onManifestLoading() {
	      // reset buffer on manifest loading
	      _logger.logger.log('trigger BUFFER_RESET');
	      this.hls.trigger(_events2.default.BUFFER_RESET);
	      this.bufferRange = [];
	      this.stalled = false;
	      this.startPosition = this.lastCurrentTime = 0;
	    }
	  }, {
	    key: 'onManifestParsed',
	    value: function onManifestParsed(data) {
	      var aac = false,
	          heaac = false,
	          codec;
	      data.levels.forEach(function (level) {
	        // detect if we have different kind of audio codecs used amongst playlists
	        codec = level.audioCodec;
	        if (codec) {
	          if (codec.indexOf('mp4a.40.2') !== -1) {
	            aac = true;
	          }
	          if (codec.indexOf('mp4a.40.5') !== -1) {
	            heaac = true;
	          }
	        }
	      });
	      this.audioCodecSwitch = aac && heaac;
	      if (this.audioCodecSwitch) {
	        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
	      }
	      this.levels = data.levels;
	      this.startLevelLoaded = false;
	      this.startFragRequested = false;
	      var config = this.config;
	      if (config.autoStartLoad) {
	        this.hls.startLoad(config.startPosition);
	      }
	    }
	  }, {
	    key: 'onLevelLoaded',
	    value: function onLevelLoaded(data) {
	      var newDetails = data.details,
	          newLevelId = data.level,
	          curLevel = this.levels[newLevelId],
	          duration = newDetails.totalduration,
	          sliding = 0;

	      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
	      this.levelLastLoaded = newLevelId;

	      if (newDetails.live) {
	        var curDetails = curLevel.details;
	        if (curDetails && newDetails.fragments.length > 0) {
	          // we already have details for that level, merge them
	          _levelHelper2.default.mergeDetails(curDetails, newDetails);
	          sliding = newDetails.fragments[0].start;
	          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
	          if (newDetails.PTSKnown) {
	            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
	          } else {
	            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
	          }
	        } else {
	          newDetails.PTSKnown = false;
	          _logger.logger.log('live playlist - first load, unknown sliding');
	        }
	      } else {
	        newDetails.PTSKnown = false;
	      }
	      // override level info
	      curLevel.details = newDetails;
	      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

	      if (this.startFragRequested === false) {
	        // compute start position if set to -1. use it straight away if value is defined
	        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
	          // first, check if start time offset has been set in playlist, if yes, use this value
	          var startTimeOffset = newDetails.startTimeOffset;
	          if (!isNaN(startTimeOffset)) {
	            if (startTimeOffset < 0) {
	              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
	              startTimeOffset = sliding + duration + startTimeOffset;
	            }
	            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
	            this.startPosition = startTimeOffset;
	          } else {
	            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
	            if (newDetails.live) {
	              this.startPosition = this.computeLivePosition(sliding, newDetails);
	              _logger.logger.log('configure startPosition to ' + this.startPosition);
	            } else {
	              this.startPosition = 0;
	            }
	          }
	          this.lastCurrentTime = this.startPosition;
	        }
	        this.nextLoadPosition = this.startPosition;
	      }
	      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
	      if (this.state === State.WAITING_LEVEL) {
	        this.state = State.IDLE;
	      }
	      //trigger handler right now
	      this.tick();
	    }
	  }, {
	    key: 'onKeyLoaded',
	    value: function onKeyLoaded() {
	      if (this.state === State.KEY_LOADING) {
	        this.state = State.IDLE;
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onFragLoaded',
	    value: function onFragLoaded(data) {
	      var fragCurrent = this.fragCurrent,
	          fragLoaded = data.frag;
	      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
	        var stats = data.stats,
	            currentLevel = this.levels[fragCurrent.level],
	            details = currentLevel.details;
	        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
	        // reset frag bitrate test in any case after frag loaded event
	        this.bitrateTest = false;
	        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
	        // then this means that we should be able to load a fragment at a higher quality level
	        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
	          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
	          this.state = State.IDLE;
	          this.startFragRequested = false;
	          stats.tparsed = stats.tbuffered = performance.now();
	          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
	          this.tick();
	        } else {
	          this.state = State.PARSING;
	          // transmux the MPEG-TS data to ISO-BMFF segments
	          this.stats = stats;
	          var duration = details.totalduration,
	              start = !isNaN(fragCurrent.startDTS) ? fragCurrent.startDTS : fragCurrent.start,
	              level = fragCurrent.level,
	              sn = fragCurrent.sn,
	              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
	          if (this.audioCodecSwap) {
	            _logger.logger.log('swapping playlist audio codec');
	            if (audioCodec === undefined) {
	              audioCodec = this.lastAudioCodec;
	            }
	            if (audioCodec) {
	              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
	                audioCodec = 'mp4a.40.2';
	              } else {
	                audioCodec = 'mp4a.40.5';
	              }
	            }
	          }
	          this.pendingAppending = 0;
	          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
	          var demuxer = this.demuxer;
	          if (!demuxer) {
	            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
	          }
	          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
	          var accurateTimeOffset = details.PTSKnown || !details.live;
	          demuxer.push(data.payload, audioCodec, currentLevel.videoCodec, start, fragCurrent.cc, level, sn, duration, fragCurrent.decryptdata, accurateTimeOffset);
	        }
	      }
	      this.fragLoadError = 0;
	    }
	  }, {
	    key: 'onFragParsingInitSegment',
	    value: function onFragParsingInitSegment(data) {
	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
	        var tracks = data.tracks,
	            trackName,
	            track;

	        // if audio track is expected to come from audio stream controller, discard any coming from main
	        if (tracks.audio && this.altAudio) {
	          delete tracks.audio;
	        }
	        // include levelCodec in audio and video tracks
	        track = tracks.audio;
	        if (track) {
	          var audioCodec = this.levels[this.level].audioCodec,
	              ua = navigator.userAgent.toLowerCase();
	          if (audioCodec && this.audioCodecSwap) {
	            _logger.logger.log('swapping playlist audio codec');
	            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
	              audioCodec = 'mp4a.40.2';
	            } else {
	              audioCodec = 'mp4a.40.5';
	            }
	          }
	          // in case AAC and HE-AAC audio codecs are signalled in manifest
	          // force HE-AAC , as it seems that most browsers prefers that way,
	          // except for mono streams OR on FF
	          // these conditions might need to be reviewed ...
	          if (this.audioCodecSwitch) {
	            // don't force HE-AAC if mono stream
	            if (track.metadata.channelCount !== 1 &&
	            // don't force HE-AAC if firefox
	            ua.indexOf('firefox') === -1) {
	              audioCodec = 'mp4a.40.5';
	            }
	          }
	          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
	          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
	            // Exclude mpeg audio
	            audioCodec = 'mp4a.40.2';
	            _logger.logger.log('Android: force audio codec to ' + audioCodec);
	          }
	          track.levelCodec = audioCodec;
	          track.id = data.id;
	        }
	        track = tracks.video;
	        if (track) {
	          track.levelCodec = this.levels[this.level].videoCodec;
	          track.id = data.id;
	        }

	        // if remuxer specify that a unique track needs to generated,
	        // let's merge all tracks together
	        if (data.unique) {
	          var mergedTrack = {
	            codec: '',
	            levelCodec: ''
	          };
	          for (trackName in data.tracks) {
	            track = tracks[trackName];
	            mergedTrack.container = track.container;
	            if (mergedTrack.codec) {
	              mergedTrack.codec += ',';
	              mergedTrack.levelCodec += ',';
	            }
	            if (track.codec) {
	              mergedTrack.codec += track.codec;
	            }
	            if (track.levelCodec) {
	              mergedTrack.levelCodec += track.levelCodec;
	            }
	          }
	          tracks = { audiovideo: mergedTrack };
	        }
	        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
	        // loop through tracks that are going to be provided to bufferController
	        for (trackName in tracks) {
	          track = tracks[trackName];
	          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
	          var initSegment = track.initSegment;
	          if (initSegment) {
	            this.pendingAppending++;
	            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
	          }
	        }
	        //trigger handler right now
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onFragParsingData',
	    value: function onFragParsingData(data) {
	      var _this2 = this;

	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
	      this.state === State.PARSING) {
	        var level = this.levels[this.level],
	            frag = this.fragCurrent;

	        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

	        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
	            hls = this.hls;
	        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

	        // has remuxer dropped video frames located before first keyframe ?
	        if (data.type === 'video') {
	          frag.dropped = data.dropped;
	        }

	        [data.data1, data.data2].forEach(function (buffer) {
	          if (buffer) {
	            _this2.pendingAppending++;
	            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
	          }
	        });

	        this.bufferRange.push({ type: data.type, start: data.startPTS, end: data.endPTS, frag: frag });

	        //trigger handler right now
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onFragParsed',
	    value: function onFragParsed(data) {
	      var fragCurrent = this.fragCurrent;
	      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
	        this.stats.tparsed = performance.now();
	        this.state = State.PARSED;
	        this._checkAppendedParsed();
	      }
	    }
	  }, {
	    key: 'onAudioTrackSwitch',
	    value: function onAudioTrackSwitch(data) {
	      // if any URL found on new audio track, it is an alternate audio track
	      var altAudio = !!data.url;
	      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
	      if (!altAudio) {
	        if (this.mediaBuffer !== this.media) {
	          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
	          this.mediaBuffer = this.media;
	          var fragCurrent = this.fragCurrent;
	          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
	          if (fragCurrent.loader) {
	            _logger.logger.log('switching to main audio track, cancel main fragment load');
	            fragCurrent.loader.abort();
	          }
	          this.fragCurrent = null;
	          this.fragPrevious = null;
	          // destroy demuxer to force init segment generation (following audio switch)
	          if (this.demuxer) {
	            this.demuxer.destroy();
	            this.demuxer = null;
	          }
	          // switch to IDLE state to load new fragment
	          this.state = State.IDLE;
	        }
	      } else {
	        // if we switch on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
	        if (this.videoBuffer && this.mediaBuffer !== this.videoBuffer) {
	          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
	          this.mediaBuffer = this.videoBuffer;
	        }
	      }
	      this.altAudio = altAudio;
	    }
	  }, {
	    key: 'onBufferCreated',
	    value: function onBufferCreated(data) {
	      var tracks = data.tracks,
	          mediaTrack = void 0,
	          name = void 0,
	          alternate = false;
	      for (var type in tracks) {
	        var track = tracks[type];
	        if (track.id === 'main') {
	          name = type;
	          mediaTrack = track;
	          // keep video source buffer reference
	          if (type === 'video') {
	            this.videoBuffer = tracks[type].buffer;
	          }
	        } else {
	          alternate = true;
	        }
	      }
	      if (alternate && mediaTrack) {
	        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
	        this.mediaBuffer = mediaTrack.buffer;
	      } else {
	        this.mediaBuffer = this.media;
	      }
	    }
	  }, {
	    key: 'onBufferAppended',
	    value: function onBufferAppended(data) {
	      if (data.parent === 'main') {
	        switch (this.state) {
	          case State.PARSING:
	          case State.PARSED:
	            this.pendingAppending--;
	            this._checkAppendedParsed();
	            break;
	          default:
	            break;
	        }
	      }
	    }
	  }, {
	    key: '_checkAppendedParsed',
	    value: function _checkAppendedParsed() {
	      //trigger handler right now
	      if (this.state === State.PARSED && this.pendingAppending === 0) {
	        var frag = this.fragCurrent,
	            stats = this.stats;
	        if (frag) {
	          this.fragPrevious = frag;
	          stats.tbuffered = performance.now();
	          // we should get rid of this.fragLastKbps
	          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
	          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
	          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
	          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
	          this.state = State.IDLE;
	        }
	        this.tick();
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(data) {
	      var frag = data.frag || this.fragCurrent;
	      // don't handle frag error not related to main fragment
	      if (frag && frag.type !== 'main') {
	        return;
	      }
	      var media = this.media,

	      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
	      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
	      switch (data.details) {
	        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
	        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
	        case _errors.ErrorDetails.KEY_LOAD_ERROR:
	        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
	          if (!data.fatal) {
	            var loadError = this.fragLoadError;
	            if (loadError) {
	              loadError++;
	            } else {
	              loadError = 1;
	            }
	            var config = this.config;
	            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
	            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
	              this.fragLoadError = loadError;
	              // reset load counter to avoid frag loop loading error
	              frag.loadCounter = 0;
	              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
	              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
	              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
	              this.retryDate = performance.now() + delay;
	              // retry loading state
	              this.state = State.FRAG_LOADING_WAITING_RETRY;
	            } else {
	              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
	              // redispatch same error but with fatal set to true
	              data.fatal = true;
	              this.hls.trigger(_events2.default.ERROR, data);
	              this.state = State.ERROR;
	            }
	          }
	          break;
	        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
	          if (!data.fatal) {
	            // if buffer is not empty
	            if (mediaBuffered) {
	              // try to reduce max buffer length : rationale is that we could get
	              // frag loop loading error because of buffer eviction
	              this._reduceMaxBufferLength(frag.duration);
	              this.state = State.IDLE;
	            } else {
	              // buffer empty. report as fatal if in manual mode or if lowest level.
	              // level controller takes care of emergency switch down logic
	              if (!frag.autoLevel || frag.level === 0) {
	                // redispatch same error but with fatal set to true
	                data.fatal = true;
	                this.hls.trigger(_events2.default.ERROR, data);
	                this.state = State.ERROR;
	              }
	            }
	          }
	          break;
	        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
	        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
	          if (this.state !== State.ERROR) {
	            if (data.fatal) {
	              // if fatal error, stop processing
	              this.state = State.ERROR;
	              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
	            } else {
	              // in cas of non fatal error while waiting level load to be completed, switch back to IDLE
	              if (this.state === State.WAITING_LEVEL) {
	                this.state = State.IDLE;
	              }
	            }
	          }
	          break;
	        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
	          // if in appending state
	          if (this.state === State.PARSING || this.state === State.PARSED) {
	            // reduce max buf len if current position is buffered
	            if (mediaBuffered) {
	              this._reduceMaxBufferLength(frag.duration);
	              this.state = State.IDLE;
	            } else {
	              // current position is not buffered, but browser is still complaining about buffer full error
	              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708
	              // in that case flush the whole buffer to recover
	              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
	              this.fragCurrent = null;
	              this.state = State.PAUSED;
	              // flush everything
	              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
	            }
	          }
	          break;
	        default:
	          break;
	      }
	    }
	  }, {
	    key: '_reduceMaxBufferLength',
	    value: function _reduceMaxBufferLength(minLength) {
	      var config = this.config;
	      if (config.maxMaxBufferLength >= minLength) {
	        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
	        config.maxMaxBufferLength /= 2;
	        _logger.logger.warn('reduce max buffer length to ' + config.maxMaxBufferLength + 's and switch to IDLE state');
	        // increase fragment load Index to avoid frag loop loading error after buffer flush
	        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
	      }
	    }
	  }, {
	    key: '_checkBuffer',
	    value: function _checkBuffer() {
	      var media = this.media;
	      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
	      if (media && media.readyState) {
	        var currentTime = media.currentTime,
	            buffered = media.buffered;
	        // adjust currentTime to start position on loaded metadata
	        if (!this.loadedmetadata && buffered.length && !media.seeking) {
	          this.loadedmetadata = true;
	          // only adjust currentTime if different from startPosition or if startPosition not buffered
	          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
	          var startPosition = this.startPosition,
	              startPositionBuffered = _bufferHelper2.default.isBuffered(media, startPosition);
	          // if currentTime not matching with expected startPosition or startPosition not buffered
	          if (currentTime !== startPosition || !startPositionBuffered) {
	            _logger.logger.log('target start position:' + startPosition);
	            // if startPosition not buffered, let's seek to buffered.start(0)
	            if (!startPositionBuffered) {
	              startPosition = buffered.start(0);
	              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
	            }
	            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
	            media.currentTime = startPosition;
	          }
	        } else if (this.immediateSwitch) {
	          this.immediateLevelSwitchEnd();
	        } else {
	          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
	              expectedPlaying = !(media.paused || // not playing when media is paused
	          media.ended || // not playing when media is ended
	          media.buffered.length === 0),
	              // not playing if nothing buffered
	          jumpThreshold = 0.5,
	              // tolerance needed as some browsers stalls playback before reaching buffered range end
	          playheadMoving = currentTime > media.playbackRate * this.lastCurrentTime,
	              config = this.config;

	          if (this.stalled && playheadMoving) {
	            this.stalled = false;
	            _logger.logger.log('playback not stuck anymore @' + currentTime);
	          }
	          // check buffer upfront
	          // if less than jumpThreshold second is buffered, let's check in more details
	          if (expectedPlaying && bufferInfo.len <= jumpThreshold) {
	            if (playheadMoving) {
	              // playhead moving
	              jumpThreshold = 0;
	              this.seekHoleNudgeDuration = 0;
	            } else {
	              // playhead not moving AND media expected to play
	              if (!this.stalled) {
	                this.seekHoleNudgeDuration = 0;
	                _logger.logger.log('playback seems stuck @' + currentTime);
	                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false });
	                this.stalled = true;
	              } else {
	                this.seekHoleNudgeDuration += config.seekHoleNudgeDuration;
	              }
	            }
	            // if we are below threshold, try to jump to start of next buffer range if close
	            if (bufferInfo.len <= jumpThreshold) {
	              // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
	              var nextBufferStart = bufferInfo.nextStart,
	                  delta = nextBufferStart - currentTime;
	              if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
	                // next buffer is close ! adjust currentTime to nextBufferStart
	                // this will ensure effective video decoding
	                _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + this.seekHoleNudgeDuration);
	                var hole = nextBufferStart + this.seekHoleNudgeDuration - media.currentTime;
	                media.currentTime = nextBufferStart + this.seekHoleNudgeDuration;
	                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: hole });
	              }
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'onFragLoadEmergencyAborted',
	    value: function onFragLoadEmergencyAborted() {
	      this.state = State.IDLE;
	      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
	      // in that case, reset startFragRequested flag
	      if (!this.loadedmetadata) {
	        this.startFragRequested = false;
	      }
	      this.tick();
	    }
	  }, {
	    key: 'onBufferFlushed',
	    value: function onBufferFlushed() {
	      /* after successful buffer flushing, rebuild buffer Range array
	        loop through existing buffer range and check if
	        corresponding range is still buffered. only push to new array already buffered range
	        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
	      */
	      var media = this.mediaBuffer ? this.mediaBuffer : this.media,
	          bufferRange = this.bufferRange,
	          newRange = [],
	          range = void 0,
	          i = void 0;
	      for (i = 0; i < bufferRange.length; i++) {
	        range = bufferRange[i];
	        if (_bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2)) {
	          newRange.push(range);
	        }
	      }
	      this.bufferRange = newRange;

	      // increase fragment load Index to avoid frag loop loading error after buffer flush
	      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
	      // move to IDLE once flush complete. this should trigger new fragment loading
	      this.state = State.IDLE;
	      // reset reference to frag
	      this.fragPrevious = null;
	    }
	  }, {
	    key: 'swapAudioCodec',
	    value: function swapAudioCodec() {
	      this.audioCodecSwap = !this.audioCodecSwap;
	    }
	  }, {
	    key: 'computeLivePosition',
	    value: function computeLivePosition(sliding, levelDetails) {
	      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
	      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
	    }
	  }, {
	    key: 'state',
	    set: function set(nextState) {
	      if (this.state !== nextState) {
	        var previousState = this.state;
	        this._state = nextState;
	        _logger.logger.log('engine state transition from ' + previousState + ' to ' + nextState);
	        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
	      }
	    },
	    get: function get() {
	      return this._state;
	    }
	  }, {
	    key: 'currentLevel',
	    get: function get() {
	      var media = this.media;
	      if (media) {
	        var range = this.getBufferRange(media.currentTime);
	        if (range) {
	          return range.frag.level;
	        }
	      }
	      return -1;
	    }
	  }, {
	    key: 'nextBufferRange',
	    get: function get() {
	      var media = this.media;
	      if (media) {
	        // first get end range of current fragment
	        return this.followingBufferRange(this.getBufferRange(media.currentTime));
	      } else {
	        return null;
	      }
	    }
	  }, {
	    key: 'nextLevel',
	    get: function get() {
	      var range = this.nextBufferRange;
	      if (range) {
	        return range.frag.level;
	      } else {
	        return -1;
	      }
	    }
	  }, {
	    key: 'liveSyncPosition',
	    get: function get() {
	      return this._liveSyncPosition;
	    },
	    set: function set(value) {
	      this._liveSyncPosition = value;
	    }
	  }]);

	  return StreamController;
	}(_eventHandler2.default);

	exports.default = StreamController;

	},{"22":22,"26":26,"27":27,"28":28,"30":30,"31":31,"41":41,"45":45,"46":46}],13:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _cea608Parser = _dereq_(42);

	var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var TimelineController = function (_EventHandler) {
	  _inherits(TimelineController, _EventHandler);

	  function TimelineController(hls) {
	    _classCallCheck(this, TimelineController);

	    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCH));

	    _this.hls = hls;
	    _this.config = hls.config;
	    _this.enabled = true;
	    _this.Cues = hls.config.cueHandler;

	    if (_this.config.enableCEA708Captions) {
	      var self = _this;
	      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
	        var e = null;
	        try {
	          e = new window.Event('addtrack');
	        } catch (err) {
	          //for IE11
	          e = document.createEvent('Event');
	          e.initEvent('addtrack', false, false);
	        }
	        e.track = track;
	        media.dispatchEvent(e);
	      };

	      var channel1 = {
	        'newCue': function newCue(startTime, endTime, screen) {
	          if (!self.textTrack1) {
	            //Enable reuse of existing text track.
	            var existingTrack1 = self.getExistingTrack('1');
	            if (!existingTrack1) {
	              self.textTrack1 = self.createTextTrack('captions', 'English', 'en');
	              self.textTrack1.textTrack1 = true;
	            } else {
	              self.textTrack1 = existingTrack1;
	              self.clearCurrentCues(self.textTrack1);

	              sendAddTrackEvent(self.textTrack1, self.media);
	            }
	          }

	          self.Cues.newCue(self.textTrack1, startTime, endTime, screen);
	        }
	      };

	      var channel2 = {
	        'newCue': function newCue(startTime, endTime, screen) {
	          if (!self.textTrack2) {
	            //Enable reuse of existing text track.
	            var existingTrack2 = self.getExistingTrack('2');
	            if (!existingTrack2) {
	              self.textTrack2 = self.createTextTrack('captions', 'Spanish', 'es');
	              self.textTrack2.textTrack2 = true;
	            } else {
	              self.textTrack2 = existingTrack2;
	              self.clearCurrentCues(self.textTrack2);

	              sendAddTrackEvent(self.textTrack2, self.media);
	            }
	          }

	          self.Cues.newCue(self.textTrack2, startTime, endTime, screen);
	        }
	      };

	      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
	    }
	    return _this;
	  }

	  _createClass(TimelineController, [{
	    key: 'clearCurrentCues',
	    value: function clearCurrentCues(track) {
	      if (track && track.cues) {
	        while (track.cues.length > 0) {
	          track.removeCue(track.cues[0]);
	        }
	      }
	    }
	  }, {
	    key: 'getExistingTrack',
	    value: function getExistingTrack(channelNumber) {
	      var media = this.media;
	      if (media) {
	        for (var i = 0; i < media.textTracks.length; i++) {
	          var textTrack = media.textTracks[i];
	          var propName = 'textTrack' + channelNumber;
	          if (textTrack[propName] === true) {
	            return textTrack;
	          }
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'createTextTrack',
	    value: function createTextTrack(kind, label, lang) {
	      if (this.media) {
	        return this.media.addTextTrack(kind, label, lang);
	      }
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onMediaAttaching',
	    value: function onMediaAttaching(data) {
	      this.media = data.media;
	    }
	  }, {
	    key: 'onMediaDetaching',
	    value: function onMediaDetaching() {
	      this.clearCurrentCues(this.textTrack1);
	      this.clearCurrentCues(this.textTrack2);
	    }
	  }, {
	    key: 'onManifestLoading',
	    value: function onManifestLoading() {
	      this.lastPts = Number.NEGATIVE_INFINITY;
	    }
	  }, {
	    key: 'onLevelSwitch',
	    value: function onLevelSwitch() {
	      if (this.hls.currentLevel.closedCaptions === 'NONE') {
	        this.enabled = false;
	      } else {
	        this.enabled = true;
	      }
	    }
	  }, {
	    key: 'onFragLoaded',
	    value: function onFragLoaded(data) {
	      if (data.frag.type === 'main') {
	        var pts = data.frag.start; //Number.POSITIVE_INFINITY;
	        // if this is a frag for a previously loaded timerange, remove all captions
	        // TODO: consider just removing captions for the timerange
	        if (pts <= this.lastPts) {
	          this.clearCurrentCues(this.textTrack1);
	          this.clearCurrentCues(this.textTrack2);
	        }
	        this.lastPts = pts;
	      }
	    }
	  }, {
	    key: 'onFragParsingUserdata',
	    value: function onFragParsingUserdata(data) {
	      // push all of the CEA-708 messages into the interpreter
	      // immediately. It will create the proper timestamps based on our PTS value
	      if (this.enabled && this.config.enableCEA708Captions) {
	        for (var i = 0; i < data.samples.length; i++) {
	          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
	          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
	        }
	      }
	    }
	  }, {
	    key: 'extractCea608Data',
	    value: function extractCea608Data(byteArray) {
	      var count = byteArray[0] & 31;
	      var position = 2;
	      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
	      var actualCCBytes = [];

	      for (var j = 0; j < count; j++) {
	        tmpByte = byteArray[position++];
	        ccbyte1 = 0x7F & byteArray[position++];
	        ccbyte2 = 0x7F & byteArray[position++];
	        ccValid = (4 & tmpByte) === 0 ? false : true;
	        ccType = 3 & tmpByte;

	        if (ccbyte1 === 0 && ccbyte2 === 0) {
	          continue;
	        }

	        if (ccValid) {
	          if (ccType === 0) // || ccType === 1
	            {
	              actualCCBytes.push(ccbyte1);
	              actualCCBytes.push(ccbyte2);
	            }
	        }
	      }
	      return actualCCBytes;
	    }
	  }]);

	  return TimelineController;
	}(_eventHandler2.default);

	exports.default = TimelineController;

	},{"27":27,"28":28,"42":42}],14:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AESCrypto = function () {
	  function AESCrypto(subtle, iv) {
	    _classCallCheck(this, AESCrypto);

	    this.subtle = subtle;
	    this.aesIV = iv;
	  }

	  _createClass(AESCrypto, [{
	    key: 'decrypt',
	    value: function decrypt(data, key) {
	      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
	    }
	  }]);

	  return AESCrypto;
	}();

	exports.default = AESCrypto;

	},{}],15:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AESDecryptor = function () {
	  function AESDecryptor() {
	    _classCallCheck(this, AESDecryptor);

	    // Static after running initTable
	    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    this.subMix = [];
	    this.subMix[0] = new Uint32Array(256);
	    this.subMix[1] = new Uint32Array(256);
	    this.subMix[2] = new Uint32Array(256);
	    this.subMix[3] = new Uint32Array(256);

	    this.invSubMix = [];
	    this.invSubMix[0] = new Uint32Array(256);
	    this.invSubMix[1] = new Uint32Array(256);
	    this.invSubMix[2] = new Uint32Array(256);
	    this.invSubMix[3] = new Uint32Array(256);

	    this.sBox = new Uint32Array(256);
	    this.invSBox = new Uint32Array(256);

	    // Changes during runtime
	    this.key = new Uint32Array(0);

	    this.initTable();
	  }

	  // Using view.getUint32() also swaps the byte order.


	  _createClass(AESDecryptor, [{
	    key: 'uint8ArrayToUint32Array_',
	    value: function uint8ArrayToUint32Array_(arrayBuffer) {
	      var view = new DataView(arrayBuffer);
	      var newArray = new Uint32Array(4);
	      for (var i = 0; i < newArray.length; i++) {
	        newArray[i] = view.getUint32(i * 4);
	      }
	      return newArray;
	    }
	  }, {
	    key: 'initTable',
	    value: function initTable() {
	      var sBox = this.sBox;
	      var invSBox = this.invSBox;
	      var subMix0 = this.subMix[0];
	      var subMix1 = this.subMix[1];
	      var subMix2 = this.subMix[2];
	      var subMix3 = this.subMix[3];
	      var invSubMix0 = this.invSubMix[0];
	      var invSubMix1 = this.invSubMix[1];
	      var invSubMix2 = this.invSubMix[2];
	      var invSubMix3 = this.invSubMix[3];

	      var d = new Uint32Array(256);
	      var x = 0;
	      var xi = 0;
	      var i = 0;
	      for (i = 0; i < 256; i++) {
	        if (i < 128) {
	          d[i] = i << 1;
	        } else {
	          d[i] = i << 1 ^ 0x11b;
	        }
	      }

	      for (i = 0; i < 256; i++) {
	        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
	        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
	        sBox[x] = sx;
	        invSBox[sx] = x;

	        // Compute multiplication
	        var x2 = d[x];
	        var x4 = d[x2];
	        var x8 = d[x4];

	        // Compute sub/invSub bytes, mix columns tables
	        var t = d[sx] * 0x101 ^ sx * 0x1010100;
	        subMix0[x] = t << 24 | t >>> 8;
	        subMix1[x] = t << 16 | t >>> 16;
	        subMix2[x] = t << 8 | t >>> 24;
	        subMix3[x] = t;

	        // Compute inv sub bytes, inv mix columns tables
	        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
	        invSubMix0[sx] = t << 24 | t >>> 8;
	        invSubMix1[sx] = t << 16 | t >>> 16;
	        invSubMix2[sx] = t << 8 | t >>> 24;
	        invSubMix3[sx] = t;

	        // Compute next counter
	        if (!x) {
	          x = xi = 1;
	        } else {
	          x = x2 ^ d[d[d[x8 ^ x2]]];
	          xi ^= d[d[xi]];
	        }
	      }
	    }
	  }, {
	    key: 'expandKey',
	    value: function expandKey(keyBuffer) {
	      // convert keyBuffer to Uint32Array
	      var key = this.uint8ArrayToUint32Array_(keyBuffer);
	      var sameKey = true;
	      var offset = 0;

	      while (offset < key.length && sameKey) {
	        sameKey = key[offset] === this.key[offset];
	        offset++;
	      }

	      if (sameKey) {
	        return;
	      }

	      this.key = key;
	      var keySize = this.keySize = key.length;

	      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
	        throw new Error('Invalid aes key size=' + keySize);
	      }

	      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
	      var ksRow = void 0;
	      var invKsRow = void 0;

	      var keySchedule = this.keySchedule = new Uint32Array(this.ksRows);
	      var invKeySchedule = this.invKeySchedule = new Uint32Array(this.ksRows);
	      var sbox = this.sBox;
	      var rcon = this.rcon;

	      var invSubMix0 = this.invSubMix[0];
	      var invSubMix1 = this.invSubMix[1];
	      var invSubMix2 = this.invSubMix[2];
	      var invSubMix3 = this.invSubMix[3];

	      var prev = void 0;
	      var t = void 0;

	      for (ksRow = 0; ksRow < ksRows; ksRow++) {
	        if (ksRow < keySize) {
	          prev = keySchedule[ksRow] = key[ksRow];
	          continue;
	        }
	        t = prev;

	        if (ksRow % keySize === 0) {
	          // Rot word
	          t = t << 8 | t >>> 24;

	          // Sub word
	          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

	          // Mix Rcon
	          t ^= rcon[ksRow / keySize | 0] << 24;
	        } else if (keySize > 6 && ksRow % keySize === 4) {
	          // Sub word
	          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
	        }

	        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
	      }

	      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	        ksRow = ksRows - invKsRow;
	        if (invKsRow & 3) {
	          t = keySchedule[ksRow];
	        } else {
	          t = keySchedule[ksRow - 4];
	        }

	        if (invKsRow < 4 || ksRow <= 4) {
	          invKeySchedule[invKsRow] = t;
	        } else {
	          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
	        }

	        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
	      }
	    }

	    // Adding this as a method greatly improves performance.

	  }, {
	    key: 'networkToHostOrderSwap',
	    value: function networkToHostOrderSwap(word) {
	      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
	    }
	  }, {
	    key: 'decrypt',
	    value: function decrypt(inputArrayBuffer, offset, aesIV) {
	      var nRounds = this.keySize + 6;
	      var invKeySchedule = this.invKeySchedule;
	      var invSBOX = this.invSBox;

	      var invSubMix0 = this.invSubMix[0];
	      var invSubMix1 = this.invSubMix[1];
	      var invSubMix2 = this.invSubMix[2];
	      var invSubMix3 = this.invSubMix[3];

	      var initVector = this.uint8ArrayToUint32Array_(aesIV);
	      var initVector0 = initVector[0];
	      var initVector1 = initVector[1];
	      var initVector2 = initVector[2];
	      var initVector3 = initVector[3];

	      var inputInt32 = new Int32Array(inputArrayBuffer);
	      var outputInt32 = new Int32Array(inputInt32.length);

	      var t0 = void 0,
	          t1 = void 0,
	          t2 = void 0,
	          t3 = void 0;
	      var s0 = void 0,
	          s1 = void 0,
	          s2 = void 0,
	          s3 = void 0;
	      var inputWords0 = void 0,
	          inputWords1 = void 0,
	          inputWords2 = void 0,
	          inputWords3 = void 0;

	      var ksRow, i;

	      while (offset < inputInt32.length) {
	        inputWords0 = this.networkToHostOrderSwap(inputInt32[offset]);
	        inputWords1 = this.networkToHostOrderSwap(inputInt32[offset + 1]);
	        inputWords2 = this.networkToHostOrderSwap(inputInt32[offset + 2]);
	        inputWords3 = this.networkToHostOrderSwap(inputInt32[offset + 3]);

	        s0 = inputWords0 ^ invKeySchedule[0];
	        s1 = inputWords3 ^ invKeySchedule[1];
	        s2 = inputWords2 ^ invKeySchedule[2];
	        s3 = inputWords1 ^ invKeySchedule[3];

	        ksRow = 4;

	        // Iterate through the rounds of decryption
	        for (i = 1; i < nRounds; i++) {
	          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
	          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
	          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
	          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
	          // Update state
	          s0 = t0;
	          s1 = t1;
	          s2 = t2;
	          s3 = t3;

	          ksRow = ksRow + 4;
	        }

	        // Shift rows, sub bytes, add round key
	        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
	        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
	        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
	        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
	        ksRow = ksRow + 3;

	        // Write
	        outputInt32[offset] = this.networkToHostOrderSwap(t0 ^ initVector0);
	        outputInt32[offset + 1] = this.networkToHostOrderSwap(t3 ^ initVector1);
	        outputInt32[offset + 2] = this.networkToHostOrderSwap(t2 ^ initVector2);
	        outputInt32[offset + 3] = this.networkToHostOrderSwap(t1 ^ initVector3);

	        // reset initVector to last 4 unsigned int
	        initVector0 = inputWords0;
	        initVector1 = inputWords1;
	        initVector2 = inputWords2;
	        initVector3 = inputWords3;

	        offset = offset + 4;
	      }

	      return outputInt32.buffer;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.key = undefined;
	      this.keySize = undefined;
	      this.ksRows = undefined;

	      this.sBox = undefined;
	      this.invSBox = undefined;
	      this.subMix = undefined;
	      this.invSubMix = undefined;
	      this.keySchedule = undefined;
	      this.invKeySchedule = undefined;

	      this.rcon = undefined;
	    }
	  }]);

	  return AESDecryptor;
	}();

	exports.default = AESDecryptor;

	},{}],16:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _aesCrypto = _dereq_(14);

	var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

	var _fastAesKey = _dereq_(17);

	var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

	var _aesDecryptor = _dereq_(15);

	var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Decrypter = function () {
	  function Decrypter(hls) {
	    _classCallCheck(this, Decrypter);

	    this.hls = hls;
	    try {
	      var browserCrypto = window ? window.crypto : crypto;
	      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
	    } catch (e) {}

	    this.disableWebCrypto = !this.supportsWebCrypto();
	  }

	  _createClass(Decrypter, [{
	    key: 'supportsWebCrypto',
	    value: function supportsWebCrypto() {
	      return this.subtle && window.location.protocol === 'https:';
	    }
	  }, {
	    key: 'decrypt',
	    value: function decrypt(data, key, iv, callback) {
	      var _this = this;

	      if (this.disableWebCrypto && this.hls.config.enableSoftwareAES) {
	        _logger.logger.log('decrypting by JavaScript Implementation');
	        if (!this.decryptor) {
	          this.decryptor = new _aesDecryptor2.default();
	        }
	        this.decryptor.expandKey(key);
	        callback(this.decryptor.decrypt(data, 0, iv));
	      } else {
	        (function () {
	          _logger.logger.log('decrypting by WebCrypto API');
	          var subtle = _this.subtle;
	          if (_this.key !== key) {
	            _this.key = key;
	            _this.fastAesKey = new _fastAesKey2.default(subtle, key);
	          }

	          _this.fastAesKey.expandKey().then(function (aesKey) {
	            // decrypt using web crypto
	            var crypto = new _aesCrypto2.default(subtle, iv);
	            crypto.decrypt(data, aesKey).then(function (result) {
	              callback(result);
	            });
	          }).catch(function (err) {
	            _this.onWebCryptoError(err, data, key, iv, callback);
	          });
	        })();
	      }
	    }
	  }, {
	    key: 'onWebCryptoError',
	    value: function onWebCryptoError(err, data, key, iv, callback) {
	      var hls = this.hls;
	      if (hls.config.enableSoftwareAES) {
	        _logger.logger.log('disabling to use WebCrypto API');
	        this.disableWebCrypto = true;
	        this.decrypt(data, key, iv, callback);
	      } else {
	        _logger.logger.error('decrypting error : ' + err.message);
	        hls.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
	      }
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      var decryptor = this.decryptor;
	      if (decryptor) {
	        decryptor.destroy();
	        this.decryptor = undefined;
	      }
	    }
	  }]);

	  return Decrypter;
	}();

	exports.default = Decrypter;

	},{"14":14,"15":15,"17":17,"26":26,"45":45}],17:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FastAESKey = function () {
	  function FastAESKey(subtle, key) {
	    _classCallCheck(this, FastAESKey);

	    this.subtle = subtle;
	    this.key = key;
	  }

	  _createClass(FastAESKey, [{
	    key: 'expandKey',
	    value: function expandKey() {
	      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
	    }
	  }]);

	  return FastAESKey;
	}();

	exports.default = FastAESKey;

	},{}],18:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _adts = _dereq_(19);

	var _adts2 = _interopRequireDefault(_adts);

	var _logger = _dereq_(45);

	var _id = _dereq_(24);

	var _id2 = _interopRequireDefault(_id);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AACDemuxer = function () {
	  function AACDemuxer(observer, id, remuxerClass, config, typeSupported) {
	    _classCallCheck(this, AACDemuxer);

	    this.observer = observer;
	    this.id = id;
	    this.remuxerClass = remuxerClass;
	    this.config = config;
	    this.remuxer = new this.remuxerClass(observer, id, config, typeSupported);
	    this.insertDiscontinuity();
	  }

	  _createClass(AACDemuxer, [{
	    key: 'insertDiscontinuity',
	    value: function insertDiscontinuity() {
	      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0 };
	    }
	  }, {
	    key: 'push',


	    // feed incoming data to the front of the parsing pipeline
	    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
	      var track,
	          id3 = new _id2.default(data),
	          pts = 90 * id3.timeStamp,
	          config,
	          frameLength,
	          frameDuration,
	          frameIndex,
	          offset,
	          headerLength,
	          stamp,
	          len,
	          aacSample;

	      var contiguous = false;
	      if (cc !== this.lastCC) {
	        _logger.logger.log(this.id + ' discontinuity detected');
	        this.lastCC = cc;
	        this.insertDiscontinuity();
	        this.remuxer.switchLevel();
	        this.remuxer.insertDiscontinuity();
	      } else if (level !== this.lastLevel) {
	        _logger.logger.log('audio track switch detected');
	        this.lastLevel = level;
	        this.remuxer.switchLevel();
	        this.insertDiscontinuity();
	      } else if (sn === this.lastSN + 1) {
	        contiguous = true;
	      }
	      track = this._aacTrack;
	      this.lastSN = sn;
	      this.lastLevel = level;

	      // look for ADTS header (0xFFFx)
	      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
	        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
	          break;
	        }
	      }

	      if (!track.audiosamplerate) {
	        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
	        track.config = config.config;
	        track.audiosamplerate = config.samplerate;
	        track.channelCount = config.channelCount;
	        track.codec = config.codec;
	        track.duration = duration;
	        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
	      }
	      frameIndex = 0;
	      frameDuration = 1024 * 90000 / track.audiosamplerate;
	      while (offset + 5 < len) {
	        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
	        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
	        // retrieve frame size
	        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
	        frameLength -= headerLength;
	        //stamp = pes.pts;

	        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
	          stamp = pts + frameIndex * frameDuration;
	          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
	          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
	          track.samples.push(aacSample);
	          track.len += frameLength;
	          offset += frameLength + headerLength;
	          frameIndex++;
	          // look for ADTS header (0xFFFx)
	          for (; offset < len - 1; offset++) {
	            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
	              break;
	            }
	          }
	        } else {
	          break;
	        }
	      }
	      this.remuxer.remux(level, sn, this._aacTrack, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {}
	  }], [{
	    key: 'probe',
	    value: function probe(data) {
	      // check if data contains ID3 timestamp and ADTS sync worc
	      var id3 = new _id2.default(data),
	          offset,
	          len;
	      if (id3.hasTimeStamp) {
	        // look for ADTS header (0xFFFx)
	        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
	          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
	            //logger.log('ADTS sync word found !');
	            return true;
	          }
	        }
	      }
	      return false;
	    }
	  }]);

	  return AACDemuxer;
	}();

	exports.default = AACDemuxer;

	},{"19":19,"24":24,"45":45}],19:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _logger = _dereq_(45);

	var _errors = _dereq_(26);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ADTS = function () {
	  function ADTS() {
	    _classCallCheck(this, ADTS);
	  }

	  _createClass(ADTS, null, [{
	    key: 'getAudioConfig',
	    value: function getAudioConfig(observer, data, offset, audioCodec) {
	      var adtsObjectType,
	          // :int
	      adtsSampleingIndex,
	          // :int
	      adtsExtensionSampleingIndex,
	          // :int
	      adtsChanelConfig,
	          // :int
	      config,
	          userAgent = navigator.userAgent.toLowerCase(),
	          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
	      // byte 2
	      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
	      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
	      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
	        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
	        return;
	      }
	      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
	      // byte 3
	      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
	      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
	      // firefox/Opera: freq less than 24kHz = AAC SBR (HE-AAC)
	      if (/firefox|OPR/i.test(userAgent)) {
	        if (adtsSampleingIndex >= 6) {
	          adtsObjectType = 5;
	          config = new Array(4);
	          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
	          // there is a factor 2 between frame sample rate and output sample rate
	          // multiply frequency by 2 (see table below, equivalent to substract 3)
	          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
	        } else {
	          adtsObjectType = 2;
	          config = new Array(2);
	          adtsExtensionSampleingIndex = adtsSampleingIndex;
	        }
	        // Android : always use AAC
	      } else if (userAgent.indexOf('android') !== -1) {
	        adtsObjectType = 2;
	        config = new Array(2);
	        adtsExtensionSampleingIndex = adtsSampleingIndex;
	      } else {
	        /*  for other browsers (Chrome/Vivaldi ...)
	            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
	        */
	        adtsObjectType = 5;
	        config = new Array(4);
	        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
	        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
	          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
	          // there is a factor 2 between frame sample rate and output sample rate
	          // multiply frequency by 2 (see table below, equivalent to substract 3)
	          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
	        } else {
	          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
	          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
	          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
	            adtsObjectType = 2;
	            config = new Array(2);
	          }
	          adtsExtensionSampleingIndex = adtsSampleingIndex;
	        }
	      }
	      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
	          ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
	        Audio Profile / Audio Object Type
	        0: Null
	        1: AAC Main
	        2: AAC LC (Low Complexity)
	        3: AAC SSR (Scalable Sample Rate)
	        4: AAC LTP (Long Term Prediction)
	        5: SBR (Spectral Band Replication)
	        6: AAC Scalable
	       sampling freq
	        0: 96000 Hz
	        1: 88200 Hz
	        2: 64000 Hz
	        3: 48000 Hz
	        4: 44100 Hz
	        5: 32000 Hz
	        6: 24000 Hz
	        7: 22050 Hz
	        8: 16000 Hz
	        9: 12000 Hz
	        10: 11025 Hz
	        11: 8000 Hz
	        12: 7350 Hz
	        13: Reserved
	        14: Reserved
	        15: frequency is written explictly
	        Channel Configurations
	        These are the channel configurations:
	        0: Defined in AOT Specifc Config
	        1: 1 channel: front-center
	        2: 2 channels: front-left, front-right
	      */
	      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
	      config[0] = adtsObjectType << 3;
	      // samplingFrequencyIndex
	      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
	      config[1] |= (adtsSampleingIndex & 0x01) << 7;
	      // channelConfiguration
	      config[1] |= adtsChanelConfig << 3;
	      if (adtsObjectType === 5) {
	        // adtsExtensionSampleingIndex
	        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
	        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
	        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
	        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
	        config[2] |= 2 << 2;
	        config[3] = 0;
	      }
	      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType };
	    }
	  }]);

	  return ADTS;
	}();

	exports.default = ADTS;

	},{"26":26,"45":45}],20:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _errors = _dereq_(26);

	var _aacdemuxer = _dereq_(18);

	var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

	var _tsdemuxer = _dereq_(25);

	var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

	var _mp4Remuxer = _dereq_(38);

	var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

	var _passthroughRemuxer = _dereq_(39);

	var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DemuxerInline = function () {
	  function DemuxerInline(hls, id, typeSupported) {
	    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	    _classCallCheck(this, DemuxerInline);

	    this.hls = hls;
	    this.id = id;
	    this.config = this.hls.config || config;
	    this.typeSupported = typeSupported;
	  }

	  _createClass(DemuxerInline, [{
	    key: 'destroy',
	    value: function destroy() {
	      var demuxer = this.demuxer;
	      if (demuxer) {
	        demuxer.destroy();
	      }
	    }
	  }, {
	    key: 'push',
	    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
	      var demuxer = this.demuxer;
	      if (!demuxer) {
	        var hls = this.hls,
	            id = this.id,
	            config = this.config,
	            typeSupported = this.typeSupported;
	        // probe for content type
	        if (_tsdemuxer2.default.probe(data)) {
	          if (this.typeSupported.mp2t === true) {
	            demuxer = new _tsdemuxer2.default(hls, id, _passthroughRemuxer2.default, config, typeSupported);
	          } else {
	            demuxer = new _tsdemuxer2.default(hls, id, _mp4Remuxer2.default, config, typeSupported);
	          }
	        } else if (_aacdemuxer2.default.probe(data)) {
	          demuxer = new _aacdemuxer2.default(hls, id, _mp4Remuxer2.default, config, typeSupported);
	        } else {
	          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
	          return;
	        }
	        this.demuxer = demuxer;
	      }
	      demuxer.push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
	    }
	  }]);

	  return DemuxerInline;
	}();

	exports.default = DemuxerInline;

	},{"18":18,"25":25,"26":26,"28":28,"38":38,"39":39}],21:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _demuxerInline = _dereq_(20);

	var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _logger = _dereq_(45);

	var _events3 = _dereq_(1);

	var _events4 = _interopRequireDefault(_events3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* demuxer web worker.
	 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
	 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
	 */

	var DemuxerWorker = function DemuxerWorker(self) {
	  // observer setup
	  var observer = new _events4.default();
	  observer.trigger = function trigger(event) {
	    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      data[_key - 1] = arguments[_key];
	    }

	    observer.emit.apply(observer, [event, event].concat(data));
	  };

	  observer.off = function off(event) {
	    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	      data[_key2 - 1] = arguments[_key2];
	    }

	    observer.removeListener.apply(observer, [event].concat(data));
	  };

	  var forwardMessage = function forwardMessage(ev, data) {
	    self.postMessage({ event: ev, data: data });
	  };

	  self.addEventListener('message', function (ev) {
	    var data = ev.data;
	    //console.log('demuxer cmd:' + data.cmd);
	    switch (data.cmd) {
	      case 'init':
	        var config = JSON.parse(data.config);
	        self.demuxer = new _demuxerInline2.default(observer, data.id, data.typeSupported, config);
	        try {
	          (0, _logger.enableLogs)(config.debug === true);
	        } catch (err) {
	          console.warn('demuxerWorker: unable to enable logs');
	        }
	        // signal end of worker init
	        forwardMessage('init', null);
	        break;
	      case 'demux':
	        self.demuxer.push(new Uint8Array(data.data), data.audioCodec, data.videoCodec, data.timeOffset, data.cc, data.level, data.sn, data.duration, data.accurateTimeOffset);
	        break;
	      default:
	        break;
	    }
	  });

	  // forward events to main thread
	  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
	  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
	  observer.on(_events2.default.ERROR, forwardMessage);
	  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
	  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);

	  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
	  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
	    var data1 = data.data1.buffer,
	        data2 = data.data2.buffer;
	    // remove data1 and data2 reference from data to avoid copying them ...
	    delete data.data1;
	    delete data.data2;
	    self.postMessage({ event: ev, data: data, data1: data1, data2: data2 }, [data1, data2]);
	  });
	};

	exports.default = DemuxerWorker;

	},{"1":1,"20":20,"28":28,"45":45}],22:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _demuxerInline = _dereq_(20);

	var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

	var _demuxerWorker = _dereq_(21);

	var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

	var _logger = _dereq_(45);

	var _decrypter = _dereq_(16);

	var _decrypter2 = _interopRequireDefault(_decrypter);

	var _errors = _dereq_(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Demuxer = function () {
	  function Demuxer(hls, id) {
	    _classCallCheck(this, Demuxer);

	    this.hls = hls;
	    this.id = id;
	    var typeSupported = {
	      mp4: MediaSource.isTypeSupported('video/mp4'),
	      mp2t: hls.config.enableMP2TPassThrough && MediaSource.isTypeSupported('video/mp2t'),
	      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
	      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
	    };
	    if (hls.config.enableWorker && typeof Worker !== 'undefined') {
	      _logger.logger.log('demuxing in webworker');
	      var w = void 0;
	      try {
	        var work = _dereq_(3);
	        w = this.w = work(_demuxerWorker2.default);
	        this.onwmsg = this.onWorkerMessage.bind(this);
	        w.addEventListener('message', this.onwmsg);
	        w.onerror = function (event) {
	          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
	        };
	        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(hls.config) });
	      } catch (err) {
	        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
	        if (w) {
	          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
	          URL.revokeObjectURL(w.objectURL);
	        }
	        this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
	      }
	    } else {
	      this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
	    }
	    this.demuxInitialized = true;
	  }

	  _createClass(Demuxer, [{
	    key: 'destroy',
	    value: function destroy() {
	      var w = this.w;
	      if (w) {
	        w.removeEventListener('message', this.onwmsg);
	        w.terminate();
	        this.w = null;
	      } else {
	        var demuxer = this.demuxer;
	        if (demuxer) {
	          demuxer.destroy();
	          this.demuxer = null;
	        }
	      }
	      var decrypter = this.decrypter;
	      if (decrypter) {
	        decrypter.destroy();
	        this.decrypter = null;
	      }
	    }
	  }, {
	    key: 'pushDecrypted',
	    value: function pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
	      var w = this.w;
	      if (w) {
	        // post fragment payload as transferable objects (no copy)
	        w.postMessage({ cmd: 'demux', data: data, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, cc: cc, level: level, sn: sn, duration: duration, accurateTimeOffset: accurateTimeOffset }, [data]);
	      } else {
	        var demuxer = this.demuxer;
	        if (demuxer) {
	          demuxer.push(new Uint8Array(data), audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
	        }
	      }
	    }
	  }, {
	    key: 'push',
	    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, decryptdata, accurateTimeOffset) {
	      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
	        if (this.decrypter == null) {
	          this.decrypter = new _decrypter2.default(this.hls);
	        }
	        var localthis = this;
	        var startTime = performance.now();
	        this.decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
	          localthis.hls.trigger(_events2.default.FRAG_DECRYPTED, { level: level, sn: sn, stats: { tstart: startTime, tdecrypt: performance.now() } });
	          localthis.pushDecrypted(decryptedData, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
	        });
	      } else {
	        this.pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
	      }
	    }
	  }, {
	    key: 'onWorkerMessage',
	    value: function onWorkerMessage(ev) {
	      var data = ev.data,
	          hls = this.hls;
	      //console.log('onWorkerMessage:' + data.event);
	      switch (data.event) {
	        case 'init':
	          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
	          URL.revokeObjectURL(this.w.objectURL);
	          break;
	        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
	        case _events2.default.FRAG_PARSING_DATA:
	          data.data.data1 = new Uint8Array(data.data1);
	          data.data.data2 = new Uint8Array(data.data2);
	        /* falls through */
	        default:
	          hls.trigger(data.event, data.data);
	          break;
	      }
	    }
	  }]);

	  return Demuxer;
	}();

	exports.default = Demuxer;

	},{"16":16,"20":20,"21":21,"26":26,"28":28,"3":3,"45":45}],23:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	var _logger = _dereq_(45);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ExpGolomb = function () {
	  function ExpGolomb(data) {
	    _classCallCheck(this, ExpGolomb);

	    this.data = data;
	    // the number of bytes left to examine in this.data
	    this.bytesAvailable = data.byteLength;
	    // the current word being examined
	    this.word = 0; // :uint
	    // the number of bits left to examine in the current word
	    this.bitsAvailable = 0; // :uint
	  }

	  // ():void


	  _createClass(ExpGolomb, [{
	    key: 'loadWord',
	    value: function loadWord() {
	      var data = this.data,
	          bytesAvailable = this.bytesAvailable,
	          position = data.byteLength - bytesAvailable,
	          workingBytes = new Uint8Array(4),
	          availableBytes = Math.min(4, bytesAvailable);
	      if (availableBytes === 0) {
	        throw new Error('no bytes available');
	      }
	      workingBytes.set(data.subarray(position, position + availableBytes));
	      this.word = new DataView(workingBytes.buffer).getUint32(0);
	      // track the amount of this.data that has been processed
	      this.bitsAvailable = availableBytes * 8;
	      this.bytesAvailable -= availableBytes;
	    }

	    // (count:int):void

	  }, {
	    key: 'skipBits',
	    value: function skipBits(count) {
	      var skipBytes; // :int
	      if (this.bitsAvailable > count) {
	        this.word <<= count;
	        this.bitsAvailable -= count;
	      } else {
	        count -= this.bitsAvailable;
	        skipBytes = count >> 3;
	        count -= skipBytes >> 3;
	        this.bytesAvailable -= skipBytes;
	        this.loadWord();
	        this.word <<= count;
	        this.bitsAvailable -= count;
	      }
	    }

	    // (size:int):uint

	  }, {
	    key: 'readBits',
	    value: function readBits(size) {
	      var bits = Math.min(this.bitsAvailable, size),
	          // :uint
	      valu = this.word >>> 32 - bits; // :uint
	      if (size > 32) {
	        _logger.logger.error('Cannot read more than 32 bits at a time');
	      }
	      this.bitsAvailable -= bits;
	      if (this.bitsAvailable > 0) {
	        this.word <<= bits;
	      } else if (this.bytesAvailable > 0) {
	        this.loadWord();
	      }
	      bits = size - bits;
	      if (bits > 0 && this.bitsAvailable) {
	        return valu << bits | this.readBits(bits);
	      } else {
	        return valu;
	      }
	    }

	    // ():uint

	  }, {
	    key: 'skipLZ',
	    value: function skipLZ() {
	      var leadingZeroCount; // :uint
	      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
	        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
	          // the first bit of working word is 1
	          this.word <<= leadingZeroCount;
	          this.bitsAvailable -= leadingZeroCount;
	          return leadingZeroCount;
	        }
	      }
	      // we exhausted word and still have not found a 1
	      this.loadWord();
	      return leadingZeroCount + this.skipLZ();
	    }

	    // ():void

	  }, {
	    key: 'skipUEG',
	    value: function skipUEG() {
	      this.skipBits(1 + this.skipLZ());
	    }

	    // ():void

	  }, {
	    key: 'skipEG',
	    value: function skipEG() {
	      this.skipBits(1 + this.skipLZ());
	    }

	    // ():uint

	  }, {
	    key: 'readUEG',
	    value: function readUEG() {
	      var clz = this.skipLZ(); // :uint
	      return this.readBits(clz + 1) - 1;
	    }

	    // ():int

	  }, {
	    key: 'readEG',
	    value: function readEG() {
	      var valu = this.readUEG(); // :int
	      if (0x01 & valu) {
	        // the number is odd if the low order bit is set
	        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
	      } else {
	        return -1 * (valu >>> 1); // divide by two then make it negative
	      }
	    }

	    // Some convenience functions
	    // :Boolean

	  }, {
	    key: 'readBoolean',
	    value: function readBoolean() {
	      return 1 === this.readBits(1);
	    }

	    // ():int

	  }, {
	    key: 'readUByte',
	    value: function readUByte() {
	      return this.readBits(8);
	    }

	    // ():int

	  }, {
	    key: 'readUShort',
	    value: function readUShort() {
	      return this.readBits(16);
	    }
	    // ():int

	  }, {
	    key: 'readUInt',
	    value: function readUInt() {
	      return this.readBits(32);
	    }

	    /**
	     * Advance the ExpGolomb decoder past a scaling list. The scaling
	     * list is optionally transmitted as part of a sequence parameter
	     * set and is not relevant to transmuxing.
	     * @param count {number} the number of entries in this scaling list
	     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
	     */

	  }, {
	    key: 'skipScalingList',
	    value: function skipScalingList(count) {
	      var lastScale = 8,
	          nextScale = 8,
	          j,
	          deltaScale;
	      for (j = 0; j < count; j++) {
	        if (nextScale !== 0) {
	          deltaScale = this.readEG();
	          nextScale = (lastScale + deltaScale + 256) % 256;
	        }
	        lastScale = nextScale === 0 ? lastScale : nextScale;
	      }
	    }

	    /**
	     * Read a sequence parameter set and return some interesting video
	     * properties. A sequence parameter set is the H264 metadata that
	     * describes the properties of upcoming video frames.
	     * @param data {Uint8Array} the bytes of a sequence parameter set
	     * @return {object} an object with configuration parsed from the
	     * sequence parameter set, including the dimensions of the
	     * associated video frames.
	     */

	  }, {
	    key: 'readSPS',
	    value: function readSPS() {
	      var frameCropLeftOffset = 0,
	          frameCropRightOffset = 0,
	          frameCropTopOffset = 0,
	          frameCropBottomOffset = 0,
	          sarScale = 1,
	          profileIdc,
	          profileCompat,
	          levelIdc,
	          numRefFramesInPicOrderCntCycle,
	          picWidthInMbsMinus1,
	          picHeightInMapUnitsMinus1,
	          frameMbsOnlyFlag,
	          scalingListCount,
	          i,
	          readUByte = this.readUByte.bind(this),
	          readBits = this.readBits.bind(this),
	          readUEG = this.readUEG.bind(this),
	          readBoolean = this.readBoolean.bind(this),
	          skipBits = this.skipBits.bind(this),
	          skipEG = this.skipEG.bind(this),
	          skipUEG = this.skipUEG.bind(this),
	          skipScalingList = this.skipScalingList.bind(this);

	      readUByte();
	      profileIdc = readUByte(); // profile_idc
	      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
	      skipBits(3); // reserved_zero_3bits u(3),
	      levelIdc = readUByte(); //level_idc u(8)
	      skipUEG(); // seq_parameter_set_id
	      // some profiles have more optional data we don't need
	      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
	        var chromaFormatIdc = readUEG();
	        if (chromaFormatIdc === 3) {
	          skipBits(1); // separate_colour_plane_flag
	        }
	        skipUEG(); // bit_depth_luma_minus8
	        skipUEG(); // bit_depth_chroma_minus8
	        skipBits(1); // qpprime_y_zero_transform_bypass_flag
	        if (readBoolean()) {
	          // seq_scaling_matrix_present_flag
	          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
	          for (i = 0; i < scalingListCount; i++) {
	            if (readBoolean()) {
	              // seq_scaling_list_present_flag[ i ]
	              if (i < 6) {
	                skipScalingList(16);
	              } else {
	                skipScalingList(64);
	              }
	            }
	          }
	        }
	      }
	      skipUEG(); // log2_max_frame_num_minus4
	      var picOrderCntType = readUEG();
	      if (picOrderCntType === 0) {
	        readUEG(); //log2_max_pic_order_cnt_lsb_minus4
	      } else if (picOrderCntType === 1) {
	        skipBits(1); // delta_pic_order_always_zero_flag
	        skipEG(); // offset_for_non_ref_pic
	        skipEG(); // offset_for_top_to_bottom_field
	        numRefFramesInPicOrderCntCycle = readUEG();
	        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
	          skipEG(); // offset_for_ref_frame[ i ]
	        }
	      }
	      skipUEG(); // max_num_ref_frames
	      skipBits(1); // gaps_in_frame_num_value_allowed_flag
	      picWidthInMbsMinus1 = readUEG();
	      picHeightInMapUnitsMinus1 = readUEG();
	      frameMbsOnlyFlag = readBits(1);
	      if (frameMbsOnlyFlag === 0) {
	        skipBits(1); // mb_adaptive_frame_field_flag
	      }
	      skipBits(1); // direct_8x8_inference_flag
	      if (readBoolean()) {
	        // frame_cropping_flag
	        frameCropLeftOffset = readUEG();
	        frameCropRightOffset = readUEG();
	        frameCropTopOffset = readUEG();
	        frameCropBottomOffset = readUEG();
	      }
	      if (readBoolean()) {
	        // vui_parameters_present_flag
	        if (readBoolean()) {
	          // aspect_ratio_info_present_flag
	          var sarRatio = void 0;
	          var aspectRatioIdc = readUByte();
	          switch (aspectRatioIdc) {
	            case 1:
	              sarRatio = [1, 1];break;
	            case 2:
	              sarRatio = [12, 11];break;
	            case 3:
	              sarRatio = [10, 11];break;
	            case 4:
	              sarRatio = [16, 11];break;
	            case 5:
	              sarRatio = [40, 33];break;
	            case 6:
	              sarRatio = [24, 11];break;
	            case 7:
	              sarRatio = [20, 11];break;
	            case 8:
	              sarRatio = [32, 11];break;
	            case 9:
	              sarRatio = [80, 33];break;
	            case 10:
	              sarRatio = [18, 11];break;
	            case 11:
	              sarRatio = [15, 11];break;
	            case 12:
	              sarRatio = [64, 33];break;
	            case 13:
	              sarRatio = [160, 99];break;
	            case 14:
	              sarRatio = [4, 3];break;
	            case 15:
	              sarRatio = [3, 2];break;
	            case 16:
	              sarRatio = [2, 1];break;
	            case 255:
	              {
	                sarRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
	                break;
	              }
	          }
	          if (sarRatio) {
	            sarScale = sarRatio[0] / sarRatio[1];
	          }
	        }
	      }
	      return {
	        width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),
	        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)
	      };
	    }
	  }, {
	    key: 'readSliceType',
	    value: function readSliceType() {
	      // skip NALu type
	      this.readUByte();
	      // discard first_mb_in_slice
	      this.readUEG();
	      // return slice_type
	      return this.readUEG();
	    }
	  }]);

	  return ExpGolomb;
	}();

	exports.default = ExpGolomb;

	},{"45":45}],24:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _logger = _dereq_(45);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	//import Hex from '../utils/hex';

	var ID3 = function () {
	  function ID3(data) {
	    _classCallCheck(this, ID3);

	    this._hasTimeStamp = false;
	    var offset = 0,
	        byte1,
	        byte2,
	        byte3,
	        byte4,
	        tagSize,
	        endPos,
	        header,
	        len;
	    do {
	      header = this.readUTF(data, offset, 3);
	      offset += 3;
	      // first check for ID3 header
	      if (header === 'ID3') {
	        // skip 24 bits
	        offset += 3;
	        // retrieve tag(s) length
	        byte1 = data[offset++] & 0x7f;
	        byte2 = data[offset++] & 0x7f;
	        byte3 = data[offset++] & 0x7f;
	        byte4 = data[offset++] & 0x7f;
	        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
	        endPos = offset + tagSize;
	        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

	        // read ID3 tags
	        this._parseID3Frames(data, offset, endPos);
	        offset = endPos;
	      } else if (header === '3DI') {
	        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
	        offset += 7;
	        _logger.logger.log('3DI footer found, end: ' + offset);
	      } else {
	        offset -= 3;
	        len = offset;
	        if (len) {
	          //logger.log(`ID3 len: ${len}`);
	          if (!this.hasTimeStamp) {
	            _logger.logger.warn('ID3 tag found, but no timestamp');
	          }
	          this._length = len;
	          this._payload = data.subarray(0, len);
	        }
	        return;
	      }
	    } while (true);
	  }

	  _createClass(ID3, [{
	    key: 'readUTF',
	    value: function readUTF(data, start, len) {

	      var result = '',
	          offset = start,
	          end = start + len;
	      do {
	        result += String.fromCharCode(data[offset++]);
	      } while (offset < end);
	      return result;
	    }
	  }, {
	    key: '_parseID3Frames',
	    value: function _parseID3Frames(data, offset, endPos) {
	      var tagId, tagLen, tagStart, tagFlags, timestamp;
	      while (offset + 8 <= endPos) {
	        tagId = this.readUTF(data, offset, 4);
	        offset += 4;

	        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

	        tagFlags = data[offset++] << 8 + data[offset++];

	        tagStart = offset;
	        //logger.log("ID3 tag id:" + tagId);
	        switch (tagId) {
	          case 'PRIV':
	            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
	            // owner should be "com.apple.streaming.transportStreamTimestamp"
	            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
	              offset += 44;
	              // smelling even better ! we found the right descriptor
	              // skip null character (string end) + 3 first bytes
	              offset += 4;

	              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
	              var pts33Bit = data[offset++] & 0x1;
	              this._hasTimeStamp = true;

	              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

	              if (pts33Bit) {
	                timestamp += 47721858.84; // 2^32 / 90
	              }
	              timestamp = Math.round(timestamp);
	              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
	              this._timeStamp = timestamp;
	            }
	            break;
	          default:
	            break;
	        }
	      }
	    }
	  }, {
	    key: 'hasTimeStamp',
	    get: function get() {
	      return this._hasTimeStamp;
	    }
	  }, {
	    key: 'timeStamp',
	    get: function get() {
	      return this._timeStamp;
	    }
	  }, {
	    key: 'length',
	    get: function get() {
	      return this._length;
	    }
	  }, {
	    key: 'payload',
	    get: function get() {
	      return this._payload;
	    }
	  }]);

	  return ID3;
	}();

	exports.default = ID3;

	},{"45":45}],25:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	// import Hex from '../utils/hex';


	var _adts = _dereq_(19);

	var _adts2 = _interopRequireDefault(_adts);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _expGolomb = _dereq_(23);

	var _expGolomb2 = _interopRequireDefault(_expGolomb);

	var _logger = _dereq_(45);

	var _errors = _dereq_(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TSDemuxer = function () {
	  function TSDemuxer(observer, id, remuxerClass, config, typeSupported) {
	    _classCallCheck(this, TSDemuxer);

	    this.observer = observer;
	    this.id = id;
	    this.remuxerClass = remuxerClass;
	    this.config = config;
	    this.typeSupported = typeSupported;
	    this.lastCC = 0;
	    this.remuxer = new this.remuxerClass(observer, id, config, typeSupported);
	  }

	  _createClass(TSDemuxer, [{
	    key: 'switchLevel',
	    value: function switchLevel() {
	      this.pmtParsed = false;
	      this._pmtId = -1;
	      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
	      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
	      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
	      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
	      // flush any partial content
	      this.aacOverFlow = null;
	      this.aacLastPTS = null;
	      this.avcSample = null;
	      this.remuxer.switchLevel();
	    }
	  }, {
	    key: 'insertDiscontinuity',
	    value: function insertDiscontinuity() {
	      this.switchLevel();
	      this.remuxer.insertDiscontinuity();
	    }

	    // feed incoming data to the front of the parsing pipeline

	  }, {
	    key: 'push',
	    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
	      var start,
	          len = data.length,
	          stt,
	          pid,
	          atf,
	          offset,
	          pes,
	          codecsOnly = this.remuxer.passthrough,
	          unknownPIDs = false;

	      this.audioCodec = audioCodec;
	      this.videoCodec = videoCodec;
	      this._duration = duration;
	      this.contiguous = false;
	      this.accurateTimeOffset = accurateTimeOffset;
	      if (cc !== this.lastCC) {
	        _logger.logger.log('discontinuity detected');
	        this.insertDiscontinuity();
	        this.lastCC = cc;
	      }
	      if (level !== this.lastLevel) {
	        _logger.logger.log('level switch detected');
	        this.switchLevel();
	        this.lastLevel = level;
	      } else if (sn === this.lastSN + 1) {
	        this.contiguous = true;
	      }
	      this.lastSN = sn;

	      var pmtParsed = this.pmtParsed,
	          avcTrack = this._avcTrack,
	          audioTrack = this._audioTrack,
	          id3Track = this._id3Track,
	          avcId = avcTrack.id,
	          audioId = audioTrack.id,
	          id3Id = id3Track.id,
	          pmtId = this._pmtId,
	          avcData = avcTrack.pesData,
	          audioData = audioTrack.pesData,
	          id3Data = id3Track.pesData,
	          parsePAT = this._parsePAT,
	          parsePMT = this._parsePMT,
	          parsePES = this._parsePES,
	          parseAVCPES = this._parseAVCPES.bind(this),
	          parseAACPES = this._parseAACPES.bind(this),
	          parseMPEGPES = this._parseMPEGPES.bind(this),
	          parseID3PES = this._parseID3PES.bind(this);

	      // don't parse last TS packet if incomplete
	      len -= len % 188;
	      // loop through TS packets
	      for (start = 0; start < len; start += 188) {
	        if (data[start] === 0x47) {
	          stt = !!(data[start + 1] & 0x40);
	          // pid is a 13-bit field starting at the last bit of TS[1]
	          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
	          atf = (data[start + 3] & 0x30) >> 4;
	          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
	          if (atf > 1) {
	            offset = start + 5 + data[start + 4];
	            // continue if there is only adaptation field
	            if (offset === start + 188) {
	              continue;
	            }
	          } else {
	            offset = start + 4;
	          }
	          switch (pid) {
	            case avcId:
	              if (stt) {
	                if (avcData && (pes = parsePES(avcData))) {
	                  parseAVCPES(pes, false);
	                  if (codecsOnly) {
	                    // if we have video codec info AND
	                    // if audio PID is undefined OR if we have audio codec info,
	                    // we have all codec info !
	                    if (avcTrack.codec && (audioId === -1 || audioTrack.codec)) {
	                      this.remux(level, sn, data, timeOffset);
	                      return;
	                    }
	                  }
	                }
	                avcData = { data: [], size: 0 };
	              }
	              if (avcData) {
	                avcData.data.push(data.subarray(offset, start + 188));
	                avcData.size += start + 188 - offset;
	              }
	              break;
	            case audioId:
	              if (stt) {
	                if (audioData && (pes = parsePES(audioData))) {
	                  if (audioTrack.isAAC) {
	                    parseAACPES(pes);
	                  } else {
	                    parseMPEGPES(pes);
	                  }
	                  if (codecsOnly) {
	                    // here we now that we have audio codec info
	                    // if video PID is undefined OR if we have video codec info,
	                    // we have all codec infos !
	                    if (audioTrack.codec && (avcId === -1 || avcTrack.codec)) {
	                      this.remux(level, sn, data, timeOffset);
	                      return;
	                    }
	                  }
	                }
	                audioData = { data: [], size: 0 };
	              }
	              if (audioData) {
	                audioData.data.push(data.subarray(offset, start + 188));
	                audioData.size += start + 188 - offset;
	              }
	              break;
	            case id3Id:
	              if (stt) {
	                if (id3Data && (pes = parsePES(id3Data))) {
	                  parseID3PES(pes);
	                }
	                id3Data = { data: [], size: 0 };
	              }
	              if (id3Data) {
	                id3Data.data.push(data.subarray(offset, start + 188));
	                id3Data.size += start + 188 - offset;
	              }
	              break;
	            case 0:
	              if (stt) {
	                offset += data[offset] + 1;
	              }
	              pmtId = this._pmtId = parsePAT(data, offset);
	              break;
	            case pmtId:
	              if (stt) {
	                offset += data[offset] + 1;
	              }
	              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true);

	              // only update track id if track PID found while parsing PMT
	              // this is to avoid resetting the PID to -1 in case
	              // track PID transiently disappears from the stream
	              // this could happen in case of transient missing audio samples for example
	              avcId = parsedPIDs.avc;
	              if (avcId > 0) {
	                avcTrack.id = avcId;
	              }
	              audioId = parsedPIDs.audio;
	              if (audioId > 0) {
	                audioTrack.id = audioId;
	                audioTrack.isAAC = parsedPIDs.isAAC;
	              }
	              id3Id = parsedPIDs.id3;
	              if (id3Id > 0) {
	                id3Track.id = id3Id;
	              }
	              if (unknownPIDs && !pmtParsed) {
	                _logger.logger.log('reparse from beginning');
	                unknownPIDs = false;
	                // we set it to -188, the += 188 in the for loop will reset start to 0
	                start = -188;
	              }
	              pmtParsed = this.pmtParsed = true;
	              break;
	            case 17:
	            case 0x1fff:
	              break;
	            default:
	              unknownPIDs = true;
	              break;
	          }
	        } else {
	          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
	        }
	      }
	      // try to parse last PES packets
	      if (avcData && (pes = parsePES(avcData))) {
	        parseAVCPES(pes, true);
	        avcTrack.pesData = null;
	      } else {
	        // either avcData null or PES truncated, keep it for next frag parsing
	        avcTrack.pesData = avcData;
	      }

	      if (audioData && (pes = parsePES(audioData))) {
	        if (audioTrack.isAAC) {
	          parseAACPES(pes);
	        } else {
	          parseMPEGPES(pes);
	        }
	        audioTrack.pesData = null;
	      } else {
	        if (audioData && audioData.size) {
	          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
	        }
	        // either audioData null or PES truncated, keep it for next frag parsing
	        audioTrack.pesData = audioData;
	      }

	      if (id3Data && (pes = parsePES(id3Data))) {
	        parseID3PES(pes);
	        id3Track.pesData = null;
	      } else {
	        // either id3Data null or PES truncated, keep it for next frag parsing
	        id3Track.pesData = id3Data;
	      }
	      this.remux(level, sn, null, timeOffset);
	    }
	  }, {
	    key: 'remux',
	    value: function remux(level, sn, data, timeOffset) {
	      var avcTrack = this._avcTrack,
	          samples = avcTrack.samples,
	          nbNalu = 0,
	          naluLen = 0;

	      // compute total/avc sample length and nb of NAL units
	      for (var i = 0; i < samples.length; i++) {
	        var sample = samples[i],
	            units = sample.units.units,
	            nbUnits = units.length,
	            sampleLen = 0;
	        for (var j = 0; j < nbUnits; j++) {
	          sampleLen += units[j].data.length;
	        }
	        naluLen += sampleLen;
	        nbNalu += nbUnits;
	        sample.length = sampleLen;
	      }
	      avcTrack.len = naluLen;
	      avcTrack.nbNalu = nbNalu;
	      this.remuxer.remux(level, sn, this._audioTrack, this._avcTrack, this._id3Track, this._txtTrack, timeOffset, this.contiguous, this.accurateTimeOffset, data);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.switchLevel();
	      this._initPTS = this._initDTS = undefined;
	      this._duration = 0;
	    }
	  }, {
	    key: '_parsePAT',
	    value: function _parsePAT(data, offset) {
	      // skip the PSI header and parse the first PMT entry
	      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
	      //logger.log('PMT PID:'  + this._pmtId);
	    }
	  }, {
	    key: '_parsePMT',
	    value: function _parsePMT(data, offset, mpegSupported) {
	      var sectionLength,
	          tableEnd,
	          programInfoLength,
	          pid,
	          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
	      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
	      tableEnd = offset + 3 + sectionLength - 4;
	      // to determine where the table is, we have to figure out how
	      // long the program info descriptors are
	      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
	      // advance the offset to the first entry in the mapping table
	      offset += 12 + programInfoLength;
	      while (offset < tableEnd) {
	        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
	        switch (data[offset]) {
	          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
	          case 0x0f:
	            //logger.log('AAC PID:'  + pid);
	            if (result.audio === -1) {
	              result.audio = pid;
	            }
	            break;
	          // Packetized metadata (ID3)
	          case 0x15:
	            //logger.log('ID3 PID:'  + pid);
	            if (result.id3 === -1) {
	              result.id3 = pid;
	            }
	            break;
	          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
	          case 0x1b:
	            //logger.log('AVC PID:'  + pid);
	            if (result.avc === -1) {
	              result.avc = pid;
	            }
	            break;
	          // ISO/IEC 11172-3 (MPEG-1 audio)
	          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
	          case 0x03:
	          case 0x04:
	            //logger.log('MPEG PID:'  + pid);
	            if (!mpegSupported) {
	              _logger.logger.log('MPEG audio found, not supported in this browser for now');
	            } else if (result.audio === -1) {
	              result.audio = pid;
	              result.isAAC = false;
	            }
	            break;
	          case 0x24:
	            _logger.logger.warn('HEVC stream type found, not supported for now');
	            break;
	          default:
	            _logger.logger.log('unkown stream type:' + data[offset]);
	            break;
	        }
	        // move to the next table entry
	        // skip past the elementary stream descriptors, if present
	        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
	      }
	      return result;
	    }
	  }, {
	    key: '_parsePES',
	    value: function _parsePES(stream) {
	      var i = 0,
	          frag,
	          pesFlags,
	          pesPrefix,
	          pesLen,
	          pesHdrLen,
	          pesData,
	          pesPts,
	          pesDts,
	          payloadStartOffset,
	          data = stream.data;
	      // safety check
	      if (!stream || stream.size === 0) {
	        return null;
	      }

	      // we might need up to 19 bytes to read PES header
	      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
	      // usually only one merge is needed (and this is rare ...)
	      while (data[0].length < 19 && data.length > 1) {
	        var newData = new Uint8Array(data[0].length + data[1].length);
	        newData.set(data[0]);
	        newData.set(data[1], data[0].length);
	        data[0] = newData;
	        data.splice(1, 1);
	      }
	      //retrieve PTS/DTS from first fragment
	      frag = data[0];
	      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
	      if (pesPrefix === 1) {
	        pesLen = (frag[4] << 8) + frag[5];
	        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
	        // minus 6 : PES header size
	        if (pesLen && pesLen > stream.size - 6) {
	          return null;
	        }
	        pesFlags = frag[7];
	        if (pesFlags & 0xC0) {
	          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
	              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
	              as Bitwise operators treat their operands as a sequence of 32 bits */
	          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
	          (frag[10] & 0xFF) * 4194304 + // 1 << 22
	          (frag[11] & 0xFE) * 16384 + // 1 << 14
	          (frag[12] & 0xFF) * 128 + // 1 << 7
	          (frag[13] & 0xFE) / 2;
	          // check if greater than 2^32 -1
	          if (pesPts > 4294967295) {
	            // decrement 2^33
	            pesPts -= 8589934592;
	          }
	          if (pesFlags & 0x40) {
	            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
	            (frag[15] & 0xFF) * 4194304 + // 1 << 22
	            (frag[16] & 0xFE) * 16384 + // 1 << 14
	            (frag[17] & 0xFF) * 128 + // 1 << 7
	            (frag[18] & 0xFE) / 2;
	            // check if greater than 2^32 -1
	            if (pesDts > 4294967295) {
	              // decrement 2^33
	              pesDts -= 8589934592;
	            }
	          } else {
	            pesDts = pesPts;
	          }
	        }
	        pesHdrLen = frag[8];
	        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
	        payloadStartOffset = pesHdrLen + 9;

	        stream.size -= payloadStartOffset;
	        //reassemble PES packet
	        pesData = new Uint8Array(stream.size);
	        while (data.length) {
	          frag = data.shift();
	          var len = frag.byteLength;
	          if (payloadStartOffset) {
	            if (payloadStartOffset > len) {
	              // trim full frag if PES header bigger than frag
	              payloadStartOffset -= len;
	              continue;
	            } else {
	              // trim partial frag if PES header smaller than frag
	              frag = frag.subarray(payloadStartOffset);
	              len -= payloadStartOffset;
	              payloadStartOffset = 0;
	            }
	          }
	          pesData.set(frag, i);
	          i += len;
	        }
	        if (pesLen) {
	          // payload size : remove PES header + PES extension
	          pesLen -= pesHdrLen + 3;
	        }
	        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
	      } else {
	        return null;
	      }
	    }
	  }, {
	    key: 'pushAccesUnit',
	    value: function pushAccesUnit(avcSample, avcTrack) {
	      if (avcSample.units.units.length && avcSample.frame) {
	        // only push AVC sample if starting with a keyframe is not mandatory OR
	        //    if keyframe already found in this fragment OR
	        //       keyframe found in last fragment (track.sps) AND
	        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
	        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (avcTrack.samples.length || this.contiguous)) {
	          avcTrack.samples.push(avcSample);
	        } else {
	          // dropped samples, track it
	          avcTrack.dropped++;
	        }
	      }
	      if (avcSample.debug.length) {
	        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug + ',' + avcSample.units.length);
	      }
	    }
	  }, {
	    key: '_parseAVCPES',
	    value: function _parseAVCPES(pes, last) {
	      var _this = this;

	      //logger.log('parse new PES');
	      var track = this._avcTrack,
	          units = this._parseAVCNALu(pes.data),
	          debug = false,
	          expGolombDecoder,
	          avcSample = this.avcSample,
	          push,
	          i;
	      //free pes.data to save up some memory
	      pes.data = null;

	      units.forEach(function (unit) {
	        switch (unit.type) {
	          //NDR
	          case 1:
	            push = true;
	            if (debug && avcSample) {
	              avcSample.debug += 'NDR ';
	            }
	            avcSample.frame = true;
	            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
	            var data = unit.data;
	            if (data.length > 1) {
	              var sliceType = new _expGolomb2.default(data).readSliceType();
	              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
	              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
	              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
	              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
	              //if (sliceType === 2 || sliceType === 7) {
	              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
	                avcSample.key = true;
	              }
	            }
	            break;
	          //IDR
	          case 5:
	            push = true;
	            // handle PES not starting with AUD
	            if (!avcSample) {
	              avcSample = _this.avcSample = _this._createAVCSample(true, pes.pts, pes.dts, '');
	            }
	            if (debug) {
	              avcSample.debug += 'IDR ';
	            }
	            avcSample.key = true;
	            avcSample.frame = true;
	            break;
	          //SEI
	          case 6:
	            push = true;
	            if (debug && avcSample) {
	              avcSample.debug += 'SEI ';
	            }
	            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

	            // skip frameType
	            expGolombDecoder.readUByte();

	            var payloadType = 0;
	            var payloadSize = 0;
	            var endOfCaptions = false;
	            var b = 0;

	            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
	              payloadType = 0;
	              do {
	                b = expGolombDecoder.readUByte();
	                payloadType += b;
	              } while (b === 0xFF);

	              // Parse payload size.
	              payloadSize = 0;
	              do {
	                b = expGolombDecoder.readUByte();
	                payloadSize += b;
	              } while (b === 0xFF);

	              // TODO: there can be more than one payload in an SEI packet...
	              // TODO: need to read type and size in a while loop to get them all
	              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

	                endOfCaptions = true;

	                var countryCode = expGolombDecoder.readUByte();

	                if (countryCode === 181) {
	                  var providerCode = expGolombDecoder.readUShort();

	                  if (providerCode === 49) {
	                    var userStructure = expGolombDecoder.readUInt();

	                    if (userStructure === 0x47413934) {
	                      var userDataType = expGolombDecoder.readUByte();

	                      // Raw CEA-608 bytes wrapped in CEA-708 packet
	                      if (userDataType === 3) {
	                        var firstByte = expGolombDecoder.readUByte();
	                        var secondByte = expGolombDecoder.readUByte();

	                        var totalCCs = 31 & firstByte;
	                        var byteArray = [firstByte, secondByte];

	                        for (i = 0; i < totalCCs; i++) {
	                          // 3 bytes per CC
	                          byteArray.push(expGolombDecoder.readUByte());
	                          byteArray.push(expGolombDecoder.readUByte());
	                          byteArray.push(expGolombDecoder.readUByte());
	                        }

	                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
	                      }
	                    }
	                  }
	                }
	              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
	                for (i = 0; i < payloadSize; i++) {
	                  expGolombDecoder.readUByte();
	                }
	              }
	            }
	            break;
	          //SPS
	          case 7:
	            push = true;
	            if (debug && avcSample) {
	              avcSample.debug += 'SPS ';
	            }
	            if (!track.sps) {
	              expGolombDecoder = new _expGolomb2.default(unit.data);
	              var config = expGolombDecoder.readSPS();
	              track.width = config.width;
	              track.height = config.height;
	              track.sps = [unit.data];
	              track.duration = _this._duration;
	              var codecarray = unit.data.subarray(1, 4);
	              var codecstring = 'avc1.';
	              for (i = 0; i < 3; i++) {
	                var h = codecarray[i].toString(16);
	                if (h.length < 2) {
	                  h = '0' + h;
	                }
	                codecstring += h;
	              }
	              track.codec = codecstring;
	            }
	            break;
	          //PPS
	          case 8:
	            push = true;
	            if (debug && avcSample) {
	              avcSample.debug += 'PPS ';
	            }
	            if (!track.pps) {
	              track.pps = [unit.data];
	            }
	            break;
	          // AUD
	          case 9:
	            push = false;
	            if (avcSample) {
	              _this.pushAccesUnit(avcSample, track);
	            }
	            avcSample = _this.avcSample = _this._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
	            break;
	          // Filler Data
	          case 12:
	            push = false;
	            break;
	          default:
	            push = false;
	            if (avcSample) {
	              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
	            }
	            break;
	        }
	        if (avcSample && push) {
	          var _units = avcSample.units;
	          _units.units.push(unit);
	        }
	      });
	      // if last PES packet, push samples
	      if (last && avcSample) {
	        this.pushAccesUnit(avcSample, track);
	        this.avcSample = null;
	      }
	    }
	  }, {
	    key: '_createAVCSample',
	    value: function _createAVCSample(key, pts, dts, debug) {
	      return { key: key, pts: pts, dts: dts, units: { units: [], length: 0 }, debug: debug };
	    }
	  }, {
	    key: '_insertSampleInOrder',
	    value: function _insertSampleInOrder(arr, data) {
	      var len = arr.length;
	      if (len > 0) {
	        if (data.pts >= arr[len - 1].pts) {
	          arr.push(data);
	        } else {
	          for (var pos = len - 1; pos >= 0; pos--) {
	            if (data.pts < arr[pos].pts) {
	              arr.splice(pos, 0, data);
	              break;
	            }
	          }
	        }
	      } else {
	        arr.push(data);
	      }
	    }
	  }, {
	    key: '_getLastNalUnit',
	    value: function _getLastNalUnit() {
	      var avcSample = this.avcSample,
	          lastUnit = void 0;
	      // try to fallback to previous sample if current one is empty
	      if (!avcSample || avcSample.units.units.length === 0) {
	        var track = this._avcTrack,
	            samples = track.samples;
	        avcSample = samples[samples.length - 1];
	      }
	      if (avcSample) {
	        var units = avcSample.units.units;
	        lastUnit = units[units.length - 1];
	      }
	      return lastUnit;
	    }
	  }, {
	    key: '_parseAVCNALu',
	    value: function _parseAVCNALu(array) {
	      var i = 0,
	          len = array.byteLength,
	          value,
	          overflow,
	          track = this._avcTrack,
	          state = track.naluState || 0,
	          lastState = state;
	      var units = [],
	          unit,
	          unitType,
	          lastUnitStart = -1,
	          lastUnitType;
	      //logger.log('PES:' + Hex.hexDump(array));
	      while (i < len) {
	        value = array[i++];
	        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
	        if (!state) {
	          state = value ? 0 : 1;
	          continue;
	        }
	        if (state === 1) {
	          state = value ? 0 : 2;
	          continue;
	        }
	        // finding 3 or 4-byte start codes (00 00 01 OR 00 00 00 01)
	        switch (state) {
	          case 2:
	          case 3:
	            if (value === 0) {
	              state = 3;
	            } else if (value === 1) {
	              if (lastUnitStart >= 0) {
	                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
	                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
	                units.push(unit);
	              } else {
	                // lastUnitStart is undefined => this is the first start code found in this PES packet
	                // first check if start code delimiter is overlapping between 2 PES packets,
	                // ie it started in last packet (lastState not zero)
	                // and ended at the beginning of this PES packet (i <= 4 - lastState)
	                var lastUnit = this._getLastNalUnit();
	                if (lastUnit) {
	                  if (lastState && i <= 4 - lastState) {
	                    // start delimiter overlapping between PES packets
	                    // strip start delimiter bytes from the end of last NAL unit
	                    // check if lastUnit had a state different from zero
	                    if (lastUnit.state) {
	                      // strip last bytes
	                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
	                    }
	                  }
	                  // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
	                  overflow = i - state - 1;
	                  if (overflow > 0) {
	                    //logger.log('first NALU found with overflow:' + overflow);
	                    var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
	                    tmp.set(lastUnit.data, 0);
	                    tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
	                    lastUnit.data = tmp;
	                  }
	                }
	              }
	              // check if we can read unit type
	              if (i < len) {
	                unitType = array[i] & 0x1f;
	                //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
	                lastUnitStart = i;
	                lastUnitType = unitType;
	                state = 0;
	              } else {
	                // not enough byte to read unit type. let's read it on next PES parsing
	                state = -1;
	              }
	            } else {
	              state = 0;
	            }
	            break;
	          case -1:
	            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
	            lastUnitStart = 0;
	            // NALu type is value read from offset 0
	            lastUnitType = value & 0x1f;
	            state = 0;
	            break;
	          default:
	            break;
	        }
	      }
	      if (lastUnitStart >= 0 && state >= 0) {
	        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
	        units.push(unit);
	        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
	      }
	      // no NALu found
	      if (units.length === 0) {
	        // append pes.data to previous NAL unit
	        var _lastUnit = this._getLastNalUnit();
	        if (_lastUnit) {
	          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
	          _tmp.set(_lastUnit.data, 0);
	          _tmp.set(array, _lastUnit.data.byteLength);
	          _lastUnit.data = _tmp;
	        }
	      }
	      track.naluState = state;
	      return units;
	    }

	    /**
	     * remove Emulation Prevention bytes from a RBSP
	     */

	  }, {
	    key: 'discardEPB',
	    value: function discardEPB(data) {
	      var length = data.byteLength,
	          EPBPositions = [],
	          i = 1,
	          newLength,
	          newData;

	      // Find all `Emulation Prevention Bytes`
	      while (i < length - 2) {
	        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
	          EPBPositions.push(i + 2);
	          i += 2;
	        } else {
	          i++;
	        }
	      }

	      // If no Emulation Prevention Bytes were found just return the original
	      // array
	      if (EPBPositions.length === 0) {
	        return data;
	      }

	      // Create a new array to hold the NAL unit data
	      newLength = length - EPBPositions.length;
	      newData = new Uint8Array(newLength);
	      var sourceIndex = 0;

	      for (i = 0; i < newLength; sourceIndex++, i++) {
	        if (sourceIndex === EPBPositions[0]) {
	          // Skip this byte
	          sourceIndex++;
	          // Remove this position index
	          EPBPositions.shift();
	        }
	        newData[i] = data[sourceIndex];
	      }
	      return newData;
	    }
	  }, {
	    key: '_parseAACPES',
	    value: function _parseAACPES(pes) {
	      var track = this._audioTrack,
	          data = pes.data,
	          pts = pes.pts,
	          startOffset = 0,
	          aacOverFlow = this.aacOverFlow,
	          aacLastPTS = this.aacLastPTS,
	          config,
	          frameLength,
	          frameDuration,
	          frameIndex,
	          offset,
	          headerLength,
	          stamp,
	          len,
	          aacSample;
	      if (aacOverFlow) {
	        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
	        tmp.set(aacOverFlow, 0);
	        tmp.set(data, aacOverFlow.byteLength);
	        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
	        data = tmp;
	      }
	      // look for ADTS header (0xFFFx)
	      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
	        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
	          break;
	        }
	      }
	      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
	      if (offset) {
	        var reason, fatal;
	        if (offset < len - 1) {
	          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
	          fatal = false;
	        } else {
	          reason = 'no ADTS header found in AAC PES';
	          fatal = true;
	        }
	        _logger.logger.warn('parsing error:' + reason);
	        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
	        if (fatal) {
	          return;
	        }
	      }
	      if (!track.audiosamplerate) {
	        config = _adts2.default.getAudioConfig(this.observer, data, offset, this.audioCodec);
	        track.config = config.config;
	        track.audiosamplerate = config.samplerate;
	        track.channelCount = config.channelCount;
	        track.codec = config.codec;
	        track.duration = this._duration;
	        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
	      }
	      frameIndex = 0;
	      frameDuration = 1024 * 90000 / track.audiosamplerate;

	      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
	      // first sample PTS should be equal to last sample PTS + frameDuration
	      if (aacOverFlow && aacLastPTS) {
	        var newPTS = aacLastPTS + frameDuration;
	        if (Math.abs(newPTS - pts) > 1) {
	          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
	          pts = newPTS;
	        }
	      }

	      while (offset + 5 < len) {
	        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
	        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
	        // retrieve frame size
	        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
	        frameLength -= headerLength;
	        //stamp = pes.pts;

	        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
	          stamp = pts + frameIndex * frameDuration;
	          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
	          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
	          track.samples.push(aacSample);
	          track.len += frameLength;
	          offset += frameLength + headerLength;
	          frameIndex++;
	          // look for ADTS header (0xFFFx)
	          for (; offset < len - 1; offset++) {
	            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
	              break;
	            }
	          }
	        } else {
	          break;
	        }
	      }
	      if (offset < len) {
	        aacOverFlow = data.subarray(offset, len);
	        //logger.log(`AAC: overflow detected:${len-offset}`);
	      } else {
	        aacOverFlow = null;
	      }
	      this.aacOverFlow = aacOverFlow;
	      this.aacLastPTS = stamp;
	    }
	  }, {
	    key: '_parseMPEGPES',
	    value: function _parseMPEGPES(pes) {
	      var data = pes.data;
	      var pts = pes.pts;
	      var length = data.length;
	      var frameIndex = 0;
	      var offset = 0;
	      var parsed;

	      while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {
	        offset += parsed;
	      }
	    }
	  }, {
	    key: '_onMpegFrame',
	    value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {
	      var frameDuration = 1152 / sampleRate * 1000;
	      var stamp = pts + frameIndex * frameDuration;
	      var track = this._audioTrack;

	      track.config = [];
	      track.channelCount = channelCount;
	      track.audiosamplerate = sampleRate;
	      track.duration = this._duration;
	      track.samples.push({ unit: data, pts: stamp, dts: stamp });
	      track.len += data.length;
	    }
	  }, {
	    key: '_onMpegNoise',
	    value: function _onMpegNoise(data) {
	      _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');
	    }
	  }, {
	    key: '_parseMpeg',
	    value: function _parseMpeg(data, start, end, frameIndex, pts) {
	      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
	      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];

	      if (start + 2 > end) {
	        return -1; // we need at least 2 bytes to detect sync pattern
	      }
	      if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {
	        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
	        if (start + 24 > end) {
	          return -1;
	        }
	        var headerB = data[start + 1] >> 3 & 3;
	        var headerC = data[start + 1] >> 1 & 3;
	        var headerE = data[start + 2] >> 4 & 15;
	        var headerF = data[start + 2] >> 2 & 3;
	        var headerG = !!(data[start + 2] & 2);
	        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
	          var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
	          var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
	          var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
	          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];
	          var padding = headerG ? 1 : 0;
	          var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
	          var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;
	          if (start + frameLength > end) {
	            return -1;
	          }
	          if (this._onMpegFrame) {
	            this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);
	          }
	          return frameLength;
	        }
	      }
	      // noise or ID3, trying to skip
	      var offset = start + 2;
	      while (offset < end) {
	        if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {
	          // sync pattern is found
	          if (this._onMpegNoise) {
	            this._onMpegNoise(data.subarray(start, offset - 1));
	          }
	          return offset - start - 1;
	        }
	        offset++;
	      }
	      return -1;
	    }
	  }, {
	    key: '_parseID3PES',
	    value: function _parseID3PES(pes) {
	      this._id3Track.samples.push(pes);
	    }
	  }], [{
	    key: 'probe',
	    value: function probe(data) {
	      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
	      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
	        return true;
	      } else {
	        return false;
	      }
	    }
	  }]);

	  return TSDemuxer;
	}();

	exports.default = TSDemuxer;

	},{"19":19,"23":23,"26":26,"28":28,"45":45}],26:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ErrorTypes = exports.ErrorTypes = {
	  // Identifier for a network error (loading error / timeout ...)
	  NETWORK_ERROR: 'networkError',
	  // Identifier for a media Error (video/parsing/mediasource error)
	  MEDIA_ERROR: 'mediaError',
	  // Identifier for a mux Error (demuxing/remuxing)
	  MUX_ERROR: 'muxError',
	  // Identifier for all other errors
	  OTHER_ERROR: 'otherError'
	};

	var ErrorDetails = exports.ErrorDetails = {
	  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
	  MANIFEST_LOAD_ERROR: 'manifestLoadError',
	  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
	  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
	  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
	  MANIFEST_PARSING_ERROR: 'manifestParsingError',
	  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
	  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
	  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
	  LEVEL_LOAD_ERROR: 'levelLoadError',
	  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
	  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
	  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
	  LEVEL_SWITCH_ERROR: 'levelSwitchError',
	  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
	  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
	  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
	  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
	  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
	  FRAG_LOAD_ERROR: 'fragLoadError',
	  // Identifier for fragment loop loading error - data: { frag : fragment object}
	  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
	  // Identifier for fragment load timeout error - data: { frag : fragment object}
	  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
	  // Identifier for a fragment decryption error event - data: parsing error description
	  FRAG_DECRYPT_ERROR: 'fragDecryptError',
	  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
	  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
	  FRAG_PARSING_ERROR: 'fragParsingError',
	  // Identifier for a remux alloc error event - data: { id : demuxer Id, bytes : nb of bytes on which allocation failed , reason : error text }
	  REMUX_ALLOC_ERROR: 'remuxAllocError',
	  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
	  KEY_LOAD_ERROR: 'keyLoadError',
	  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
	  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
	  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
	  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
	  // Identifier for a buffer append error - data: append error description
	  BUFFER_APPEND_ERROR: 'bufferAppendError',
	  // Identifier for a buffer appending error event - data: appending error description
	  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
	  // Identifier for a buffer stalled error event
	  BUFFER_STALLED_ERROR: 'bufferStalledError',
	  // Identifier for a buffer full event
	  BUFFER_FULL_ERROR: 'bufferFullError',
	  // Identifier for a buffer seek over hole event
	  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
	  // Identifier for an internal exception happening inside hls.js while handling an event
	  INTERNAL_EXCEPTION: 'internalException'
	};

	},{}],27:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	var _logger = _dereq_(45);

	var _errors = _dereq_(26);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EventHandler = function () {
	  function EventHandler(hls) {
	    _classCallCheck(this, EventHandler);

	    this.hls = hls;
	    this.onEvent = this.onEvent.bind(this);

	    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      events[_key - 1] = arguments[_key];
	    }

	    this.handledEvents = events;
	    this.useGenericHandler = true;

	    this.registerListeners();
	  }

	  _createClass(EventHandler, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.unregisterListeners();
	    }
	  }, {
	    key: 'isEventHandler',
	    value: function isEventHandler() {
	      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
	    }
	  }, {
	    key: 'registerListeners',
	    value: function registerListeners() {
	      if (this.isEventHandler()) {
	        this.handledEvents.forEach(function (event) {
	          if (event === 'hlsEventGeneric') {
	            throw new Error('Forbidden event name: ' + event);
	          }
	          this.hls.on(event, this.onEvent);
	        }.bind(this));
	      }
	    }
	  }, {
	    key: 'unregisterListeners',
	    value: function unregisterListeners() {
	      if (this.isEventHandler()) {
	        this.handledEvents.forEach(function (event) {
	          this.hls.off(event, this.onEvent);
	        }.bind(this));
	      }
	    }

	    /**
	     * arguments: event (string), data (any)
	     */

	  }, {
	    key: 'onEvent',
	    value: function onEvent(event, data) {
	      this.onEventGeneric(event, data);
	    }
	  }, {
	    key: 'onEventGeneric',
	    value: function onEventGeneric(event, data) {
	      var eventToFunction = function eventToFunction(event, data) {
	        var funcName = 'on' + event.replace('hls', '');
	        if (typeof this[funcName] !== 'function') {
	          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
	        }
	        return this[funcName].bind(this, data);
	      };
	      try {
	        eventToFunction.call(this, event, data).call();
	      } catch (err) {
	        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
	        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
	      }
	    }
	  }]);

	  return EventHandler;
	}();

	exports.default = EventHandler;

	},{"26":26,"28":28,"45":45}],28:[function(_dereq_,module,exports){
	'use strict';

	module.exports = {
	  // fired before MediaSource is attaching to media element - data: { media }
	  MEDIA_ATTACHING: 'hlsMediaAttaching',
	  // fired when MediaSource has been succesfully attached to media element - data: { }
	  MEDIA_ATTACHED: 'hlsMediaAttached',
	  // fired before detaching MediaSource from media element - data: { }
	  MEDIA_DETACHING: 'hlsMediaDetaching',
	  // fired when MediaSource has been detached from media element - data: { }
	  MEDIA_DETACHED: 'hlsMediaDetached',
	  // fired when we buffer is going to be resetted
	  BUFFER_RESET: 'hlsBufferReset',
	  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
	  BUFFER_CODECS: 'hlsBufferCodecs',
	  // fired when sourcebuffers have been created data: { tracks : tracks}
	  BUFFER_CREATED: 'hlsBufferCreated',
	  // fired when we append a segment to the buffer - data: { segment: segment object }
	  BUFFER_APPENDING: 'hlsBufferAppending',
	  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING }
	  BUFFER_APPENDED: 'hlsBufferAppended',
	  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
	  BUFFER_EOS: 'hlsBufferEos',
	  // fired when the media buffer should be flushed - data {startOffset, endOffset}
	  BUFFER_FLUSHING: 'hlsBufferFlushing',
	  // fired when the media has been flushed
	  BUFFER_FLUSHED: 'hlsBufferFlushed',
	  // fired to signal that a manifest loading starts - data: { url : manifestURL}
	  MANIFEST_LOADING: 'hlsManifestLoading',
	  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
	  MANIFEST_LOADED: 'hlsManifestLoaded',
	  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
	  MANIFEST_PARSED: 'hlsManifestParsed',
	  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
	  LEVEL_LOADING: 'hlsLevelLoading',
	  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
	  LEVEL_LOADED: 'hlsLevelLoaded',
	  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
	  LEVEL_UPDATED: 'hlsLevelUpdated',
	  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
	  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
	  // fired when a level switch is requested - data: { level : id of new level }
	  LEVEL_SWITCH: 'hlsLevelSwitch',
	  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
	  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
	  // fired when an audio track switch occurs - data: {  id : audio track id}
	  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
	  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
	  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
	  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
	  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
	  // fired when a fragment loading starts - data: { frag : fragment object}
	  FRAG_LOADING: 'hlsFragLoading',
	  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
	  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
	  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
	  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
	  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
	  FRAG_LOADED: 'hlsFragLoaded',
	  // fired when a fragment has finished decrypting - data: { level : levelId, sn : sequence number }
	  FRAG_DECRYPTED: 'hlsFragDecrypted',
	  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, moov : moov MP4 box, codecs : codecs found while parsing fragment}
	  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
	  // fired when parsing sei text is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ sei samples pes ] }
	  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
	  // fired when parsing id3 is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ id3 samples pes ] }
	  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
	  // fired when data have been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
	  FRAG_PARSING_DATA: 'hlsFragParsingData',
	  // fired when fragment parsing is completed - data: { id : demuxer id; level : levelId, sn : sequence number, }
	  FRAG_PARSED: 'hlsFragParsed',
	  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
	  FRAG_BUFFERED: 'hlsFragBuffered',
	  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
	  FRAG_CHANGED: 'hlsFragChanged',
	  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
	  FPS_DROP: 'hlsFpsDrop',
	  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
	  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
	  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
	  ERROR: 'hlsError',
	  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
	  DESTROYING: 'hlsDestroying',
	  // fired when a decrypt key loading starts - data: { frag : fragment object}
	  KEY_LOADING: 'hlsKeyLoading',
	  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
	  KEY_LOADED: 'hlsKeyLoaded',
	  // fired upon stream controller state transitions - data: {previousState, nextState}
	  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
	};

	},{}],29:[function(_dereq_,module,exports){
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *  AAC helper
	 */

	var AAC = function () {
	  function AAC() {
	    _classCallCheck(this, AAC);
	  }

	  _createClass(AAC, null, [{
	    key: "getSilentFrame",
	    value: function getSilentFrame(channelCount) {
	      if (channelCount === 1) {
	        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
	      } else if (channelCount === 2) {
	        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
	      } else if (channelCount === 3) {
	        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
	      } else if (channelCount === 4) {
	        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
	      } else if (channelCount === 5) {
	        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
	      } else if (channelCount === 6) {
	        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
	      }
	      return null;
	    }
	  }]);

	  return AAC;
	}();

	exports.default = AAC;

	},{}],30:[function(_dereq_,module,exports){
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Buffer Helper class, providing methods dealing buffer length retrieval
	*/

	var BufferHelper = function () {
	  function BufferHelper() {
	    _classCallCheck(this, BufferHelper);
	  }

	  _createClass(BufferHelper, null, [{
	    key: "isBuffered",
	    value: function isBuffered(media, position) {
	      if (media) {
	        var buffered = media.buffered;
	        for (var i = 0; i < buffered.length; i++) {
	          if (position >= buffered.start(i) && position <= buffered.end(i)) {
	            return true;
	          }
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "bufferInfo",
	    value: function bufferInfo(media, pos, maxHoleDuration) {
	      if (media) {
	        var vbuffered = media.buffered,
	            buffered = [],
	            i;
	        for (i = 0; i < vbuffered.length; i++) {
	          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
	        }
	        return this.bufferedInfo(buffered, pos, maxHoleDuration);
	      } else {
	        return { len: 0, start: 0, end: 0, nextStart: undefined };
	      }
	    }
	  }, {
	    key: "bufferedInfo",
	    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
	      var buffered2 = [],

	      // bufferStart and bufferEnd are buffer boundaries around current video position
	      bufferLen,
	          bufferStart,
	          bufferEnd,
	          bufferStartNext,
	          i;
	      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
	      buffered.sort(function (a, b) {
	        var diff = a.start - b.start;
	        if (diff) {
	          return diff;
	        } else {
	          return b.end - a.end;
	        }
	      });
	      // there might be some small holes between buffer time range
	      // consider that holes smaller than maxHoleDuration are irrelevant and build another
	      // buffer time range representations that discards those holes
	      for (i = 0; i < buffered.length; i++) {
	        var buf2len = buffered2.length;
	        if (buf2len) {
	          var buf2end = buffered2[buf2len - 1].end;
	          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
	          if (buffered[i].start - buf2end < maxHoleDuration) {
	            // merge overlapping time ranges
	            // update lastRange.end only if smaller than item.end
	            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
	            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
	            if (buffered[i].end > buf2end) {
	              buffered2[buf2len - 1].end = buffered[i].end;
	            }
	          } else {
	            // big hole
	            buffered2.push(buffered[i]);
	          }
	        } else {
	          // first value
	          buffered2.push(buffered[i]);
	        }
	      }
	      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
	        var start = buffered2[i].start,
	            end = buffered2[i].end;
	        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
	        if (pos + maxHoleDuration >= start && pos < end) {
	          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
	          bufferStart = start;
	          bufferEnd = end;
	          bufferLen = bufferEnd - pos;
	        } else if (pos + maxHoleDuration < start) {
	          bufferStartNext = start;
	          break;
	        }
	      }
	      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
	    }
	  }]);

	  return BufferHelper;
	}();

	exports.default = BufferHelper;

	},{}],31:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	var _logger = _dereq_(45);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var LevelHelper = function () {
	  function LevelHelper() {
	    _classCallCheck(this, LevelHelper);
	  }

	  _createClass(LevelHelper, null, [{
	    key: 'mergeDetails',
	    value: function mergeDetails(oldDetails, newDetails) {
	      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
	          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
	          delta = newDetails.startSN - oldDetails.startSN,
	          oldfragments = oldDetails.fragments,
	          newfragments = newDetails.fragments,
	          ccOffset = 0,
	          PTSFrag;

	      // check if old/new playlists have fragments in common
	      if (end < start) {
	        newDetails.PTSKnown = false;
	        return;
	      }
	      // loop through overlapping SN and update startPTS , cc, and duration if any found
	      for (var i = start; i <= end; i++) {
	        var oldFrag = oldfragments[delta + i],
	            newFrag = newfragments[i];
	        if (newFrag && oldFrag) {
	          ccOffset = oldFrag.cc - newFrag.cc;
	          if (!isNaN(oldFrag.startPTS)) {
	            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
	            newFrag.endPTS = oldFrag.endPTS;
	            newFrag.duration = oldFrag.duration;
	            PTSFrag = newFrag;
	          }
	        }
	      }

	      if (ccOffset) {
	        _logger.logger.log('discontinuity sliding from playlist, take drift into account');
	        for (i = 0; i < newfragments.length; i++) {
	          newfragments[i].cc += ccOffset;
	        }
	      }

	      // if at least one fragment contains PTS info, recompute PTS information for all fragments
	      if (PTSFrag) {
	        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
	      } else {
	        // ensure that delta is within oldfragments range
	        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
	        // in that case we also need to adjust start offset of all fragments
	        if (delta >= 0 && delta < oldfragments.length) {
	          // adjust start by sliding offset
	          var sliding = oldfragments[delta].start;
	          for (i = 0; i < newfragments.length; i++) {
	            newfragments[i].start += sliding;
	          }
	        }
	      }
	      // if we are here, it means we have fragments overlapping between
	      // old and new level. reliable PTS info is thus relying on old level
	      newDetails.PTSKnown = oldDetails.PTSKnown;
	      return;
	    }
	  }, {
	    key: 'updateFragPTSDTS',
	    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
	      var fragIdx, fragments, frag, i;
	      // exit if sn out of range
	      if (!details || sn < details.startSN || sn > details.endSN) {
	        return 0;
	      }
	      fragIdx = sn - details.startSN;
	      fragments = details.fragments;
	      frag = fragments[fragIdx];
	      if (!isNaN(frag.startPTS)) {
	        // delta PTS between audio and video
	        var deltaPTS = Math.abs(frag.startPTS - startPTS);
	        if (isNaN(frag.deltaPTS)) {
	          frag.deltaPTS = deltaPTS;
	        } else {
	          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
	        }
	        startPTS = Math.min(startPTS, frag.startPTS);
	        endPTS = Math.max(endPTS, frag.endPTS);
	        startDTS = Math.min(startDTS, frag.startDTS);
	        endDTS = Math.max(endDTS, frag.endDTS);
	      }

	      var drift = startPTS - frag.start;

	      frag.start = frag.startPTS = startPTS;
	      frag.endPTS = endPTS;
	      frag.startDTS = startDTS;
	      frag.endDTS = endDTS;
	      frag.duration = endPTS - startPTS;
	      // adjust fragment PTS/duration from seqnum-1 to frag 0
	      for (i = fragIdx; i > 0; i--) {
	        LevelHelper.updatePTS(fragments, i, i - 1);
	      }

	      // adjust fragment PTS/duration from seqnum to last frag
	      for (i = fragIdx; i < fragments.length - 1; i++) {
	        LevelHelper.updatePTS(fragments, i, i + 1);
	      }
	      details.PTSKnown = true;
	      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

	      return drift;
	    }
	  }, {
	    key: 'updatePTS',
	    value: function updatePTS(fragments, fromIdx, toIdx) {
	      var fragFrom = fragments[fromIdx],
	          fragTo = fragments[toIdx],
	          fragToPTS = fragTo.startPTS;
	      // if we know startPTS[toIdx]
	      if (!isNaN(fragToPTS)) {
	        // update fragment duration.
	        // it helps to fix drifts between playlist reported duration and fragment real duration
	        if (toIdx > fromIdx) {
	          fragFrom.duration = fragToPTS - fragFrom.start;
	          if (fragFrom.duration < 0) {
	            _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
	          }
	        } else {
	          fragTo.duration = fragFrom.start - fragToPTS;
	          if (fragTo.duration < 0) {
	            _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
	          }
	        }
	      } else {
	        // we dont know startPTS[toIdx]
	        if (toIdx > fromIdx) {
	          fragTo.start = fragFrom.start + fragFrom.duration;
	        } else {
	          fragTo.start = fragFrom.start - fragTo.duration;
	        }
	      }
	    }
	  }]);

	  return LevelHelper;
	}();

	exports.default = LevelHelper;

	},{"45":45}],32:[function(_dereq_,module,exports){
	/**
	 * HLS interface
	 */
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	//import FetchLoader from './utils/fetch-loader';


	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _errors = _dereq_(26);

	var _playlistLoader = _dereq_(36);

	var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

	var _fragmentLoader = _dereq_(34);

	var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

	var _abrController = _dereq_(4);

	var _abrController2 = _interopRequireDefault(_abrController);

	var _bufferController = _dereq_(7);

	var _bufferController2 = _interopRequireDefault(_bufferController);

	var _capLevelController = _dereq_(8);

	var _capLevelController2 = _interopRequireDefault(_capLevelController);

	var _audioStreamController = _dereq_(5);

	var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

	var _streamController = _dereq_(12);

	var _streamController2 = _interopRequireDefault(_streamController);

	var _levelController = _dereq_(11);

	var _levelController2 = _interopRequireDefault(_levelController);

	var _timelineController = _dereq_(13);

	var _timelineController2 = _interopRequireDefault(_timelineController);

	var _fpsController = _dereq_(10);

	var _fpsController2 = _interopRequireDefault(_fpsController);

	var _audioTrackController = _dereq_(6);

	var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

	var _logger = _dereq_(45);

	var _xhrLoader = _dereq_(47);

	var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

	var _events3 = _dereq_(1);

	var _events4 = _interopRequireDefault(_events3);

	var _keyLoader = _dereq_(35);

	var _keyLoader2 = _interopRequireDefault(_keyLoader);

	var _cues = _dereq_(43);

	var _cues2 = _interopRequireDefault(_cues);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Hls = function () {
	  _createClass(Hls, null, [{
	    key: 'isSupported',
	    value: function isSupported() {
	      window.MediaSource = window.MediaSource || window.WebKitMediaSource;
	      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
	    }
	  }, {
	    key: 'version',
	    get: function get() {
	      // replaced with browserify-versionify transform
	      return '0.6.14';
	    }
	  }, {
	    key: 'Events',
	    get: function get() {
	      return _events2.default;
	    }
	  }, {
	    key: 'ErrorTypes',
	    get: function get() {
	      return _errors.ErrorTypes;
	    }
	  }, {
	    key: 'ErrorDetails',
	    get: function get() {
	      return _errors.ErrorDetails;
	    }
	  }, {
	    key: 'DefaultConfig',
	    get: function get() {
	      if (!Hls.defaultConfig) {
	        Hls.defaultConfig = {
	          autoStartLoad: true,
	          startPosition: -1,
	          defaultAudioCodec: undefined,
	          debug: false,
	          capLevelOnFPSDrop: false,
	          capLevelToPlayerSize: false,
	          initialLiveManifestSize: 1,
	          maxBufferLength: 30,
	          maxBufferSize: 60 * 1000 * 1000,
	          maxBufferHole: 0.5,
	          maxSeekHole: 2,
	          seekHoleNudgeDuration: 0.01,
	          stalledInBufferedNudgeThreshold: 10,
	          maxFragLookUpTolerance: 0.2,
	          liveSyncDurationCount: 3,
	          liveMaxLatencyDurationCount: Infinity,
	          liveSyncDuration: undefined,
	          liveMaxLatencyDuration: undefined,
	          maxMaxBufferLength: 600,
	          enableWorker: true,
	          enableSoftwareAES: true,
	          enableLazyURLResolve: false,
	          manifestLoadingTimeOut: 10000,
	          manifestLoadingMaxRetry: 1,
	          manifestLoadingRetryDelay: 1000,
	          manifestLoadingMaxRetryTimeout: 64000,
	          startLevel: undefined,
	          levelLoadingTimeOut: 10000,
	          levelLoadingMaxRetry: 4,
	          levelLoadingRetryDelay: 1000,
	          levelLoadingMaxRetryTimeout: 64000,
	          fragLoadingTimeOut: 20000,
	          fragLoadingMaxRetry: 6,
	          fragLoadingRetryDelay: 1000,
	          fragLoadingMaxRetryTimeout: 64000,
	          fragLoadingLoopThreshold: 3,
	          startFragPrefetch: false,
	          fpsDroppedMonitoringPeriod: 5000,
	          fpsDroppedMonitoringThreshold: 0.2,
	          appendErrorMaxRetry: 3,
	          loader: _xhrLoader2.default,
	          //loader: FetchLoader,
	          fLoader: undefined,
	          pLoader: undefined,
	          xhrSetup: undefined,
	          fetchSetup: undefined,
	          abrController: _abrController2.default,
	          bufferController: _bufferController2.default,
	          capLevelController: _capLevelController2.default,
	          fpsController: _fpsController2.default,
	          streamController: _streamController2.default,
	          audioStreamController: _audioStreamController2.default,
	          timelineController: _timelineController2.default,
	          cueHandler: _cues2.default,
	          enableCEA708Captions: true,
	          enableMP2TPassThrough: false,
	          stretchShortVideoTrack: false,
	          forceKeyFrameOnDiscontinuity: true,
	          abrEwmaFastLive: 3,
	          abrEwmaSlowLive: 9,
	          abrEwmaFastVoD: 3,
	          abrEwmaSlowVoD: 9,
	          abrEwmaDefaultEstimate: 5e5, // 500 kbps
	          abrBandWidthFactor: 0.95,
	          abrBandWidthUpFactor: 0.7,
	          maxStarvationDelay: 4,
	          maxLoadingDelay: 4,
	          minAutoBitrate: 0
	        };
	      }
	      return Hls.defaultConfig;
	    },
	    set: function set(defaultConfig) {
	      Hls.defaultConfig = defaultConfig;
	    }
	  }]);

	  function Hls() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Hls);

	    var defaultConfig = Hls.DefaultConfig;

	    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
	      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
	    }

	    for (var prop in defaultConfig) {
	      if (prop in config) {
	        continue;
	      }
	      config[prop] = defaultConfig[prop];
	    }

	    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
	      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
	    }

	    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
	      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
	    }

	    (0, _logger.enableLogs)(config.debug);
	    this.config = config;
	    // observer setup
	    var observer = this.observer = new _events4.default();
	    observer.trigger = function trigger(event) {
	      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        data[_key - 1] = arguments[_key];
	      }

	      observer.emit.apply(observer, [event, event].concat(data));
	    };

	    observer.off = function off(event) {
	      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        data[_key2 - 1] = arguments[_key2];
	      }

	      observer.removeListener.apply(observer, [event].concat(data));
	    };
	    this.on = observer.on.bind(observer);
	    this.off = observer.off.bind(observer);
	    this.trigger = observer.trigger.bind(observer);
	    this.playlistLoader = new _playlistLoader2.default(this);
	    this.fragmentLoader = new _fragmentLoader2.default(this);
	    this.levelController = new _levelController2.default(this);
	    this.abrController = new config.abrController(this);
	    this.bufferController = new config.bufferController(this);
	    this.capLevelController = new config.capLevelController(this);
	    this.fpsController = new config.fpsController(this);
	    this.streamController = new config.streamController(this);
	    this.audioStreamController = new config.audioStreamController(this);
	    this.timelineController = new config.timelineController(this);
	    this.audioTrackController = new _audioTrackController2.default(this);
	    this.keyLoader = new _keyLoader2.default(this);
	  }

	  _createClass(Hls, [{
	    key: 'destroy',
	    value: function destroy() {
	      _logger.logger.log('destroy');
	      this.trigger(_events2.default.DESTROYING);
	      this.detachMedia();
	      this.playlistLoader.destroy();
	      this.fragmentLoader.destroy();
	      this.levelController.destroy();
	      this.abrController.destroy();
	      this.bufferController.destroy();
	      this.capLevelController.destroy();
	      this.fpsController.destroy();
	      this.streamController.destroy();
	      this.audioStreamController.destroy();
	      this.timelineController.destroy();
	      this.audioTrackController.destroy();
	      this.keyLoader.destroy();
	      this.url = null;
	      this.observer.removeAllListeners();
	    }
	  }, {
	    key: 'attachMedia',
	    value: function attachMedia(media) {
	      _logger.logger.log('attachMedia');
	      this.media = media;
	      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
	    }
	  }, {
	    key: 'detachMedia',
	    value: function detachMedia() {
	      _logger.logger.log('detachMedia');
	      this.trigger(_events2.default.MEDIA_DETACHING);
	      this.media = null;
	    }
	  }, {
	    key: 'loadSource',
	    value: function loadSource(url) {
	      _logger.logger.log('loadSource:' + url);
	      this.url = url;
	      // when attaching to a source URL, trigger a playlist load
	      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
	    }
	  }, {
	    key: 'startLoad',
	    value: function startLoad() {
	      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

	      _logger.logger.log('startLoad(' + startPosition + ')');
	      this.levelController.startLoad();
	      this.streamController.startLoad(startPosition);
	      this.audioStreamController.startLoad(startPosition);
	    }
	  }, {
	    key: 'stopLoad',
	    value: function stopLoad() {
	      _logger.logger.log('stopLoad');
	      this.levelController.stopLoad();
	      this.streamController.stopLoad();
	      this.audioStreamController.stopLoad();
	    }
	  }, {
	    key: 'swapAudioCodec',
	    value: function swapAudioCodec() {
	      _logger.logger.log('swapAudioCodec');
	      this.streamController.swapAudioCodec();
	    }
	  }, {
	    key: 'recoverMediaError',
	    value: function recoverMediaError() {
	      _logger.logger.log('recoverMediaError');
	      var media = this.media;
	      this.detachMedia();
	      this.attachMedia(media);
	    }

	    /** Return all quality levels **/

	  }, {
	    key: 'levels',
	    get: function get() {
	      return this.levelController.levels;
	    }

	    /** Return current playback quality level **/

	  }, {
	    key: 'currentLevel',
	    get: function get() {
	      return this.streamController.currentLevel;
	    }

	    /* set quality level immediately (-1 for automatic level selection) */
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set currentLevel:' + newLevel);
	      this.loadLevel = newLevel;
	      this.streamController.immediateLevelSwitch();
	    }

	    /** Return next playback quality level (quality level of next fragment) **/

	  }, {
	    key: 'nextLevel',
	    get: function get() {
	      return this.streamController.nextLevel;
	    }

	    /* set quality level for next fragment (-1 for automatic level selection) */
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set nextLevel:' + newLevel);
	      this.levelController.manualLevel = newLevel;
	      this.streamController.nextLevelSwitch();
	    }

	    /** Return the quality level of current/last loaded fragment **/

	  }, {
	    key: 'loadLevel',
	    get: function get() {
	      return this.levelController.level;
	    }

	    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set loadLevel:' + newLevel);
	      this.levelController.manualLevel = newLevel;
	    }

	    /** Return the quality level of next loaded fragment **/

	  }, {
	    key: 'nextLoadLevel',
	    get: function get() {
	      return this.levelController.nextLoadLevel;
	    }

	    /** set quality level of next loaded fragment **/
	    ,
	    set: function set(level) {
	      this.levelController.nextLoadLevel = level;
	    }

	    /** Return first level (index of first level referenced in manifest)
	    **/

	  }, {
	    key: 'firstLevel',
	    get: function get() {
	      return Math.max(this.levelController.firstLevel, this.abrController.minAutoLevel);
	    }

	    /** set first level (index of first level referenced in manifest)
	    **/
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set firstLevel:' + newLevel);
	      this.levelController.firstLevel = newLevel;
	    }

	    /** Return start level (level of first fragment that will be played back)
	        if not overrided by user, first level appearing in manifest will be used as start level
	        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
	    **/

	  }, {
	    key: 'startLevel',
	    get: function get() {
	      return this.levelController.startLevel;
	    }

	    /** set  start level (level of first fragment that will be played back)
	        if not overrided by user, first level appearing in manifest will be used as start level
	        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
	    **/
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set startLevel:' + newLevel);
	      this.levelController.startLevel = newLevel;
	    }

	    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

	  }, {
	    key: 'autoLevelCapping',
	    get: function get() {
	      return this.abrController.autoLevelCapping;
	    }

	    /** set the capping/max level value that could be used by automatic level selection algorithm **/
	    ,
	    set: function set(newLevel) {
	      _logger.logger.log('set autoLevelCapping:' + newLevel);
	      this.abrController.autoLevelCapping = newLevel;
	    }

	    /* check if we are in automatic level selection mode */

	  }, {
	    key: 'autoLevelEnabled',
	    get: function get() {
	      return this.levelController.manualLevel === -1;
	    }

	    /* return manual level */

	  }, {
	    key: 'manualLevel',
	    get: function get() {
	      return this.levelController.manualLevel;
	    }

	    /** get alternate audio tracks list from playlist **/

	  }, {
	    key: 'audioTracks',
	    get: function get() {
	      return this.audioTrackController.audioTracks;
	    }

	    /** get index of the selected audio track (index in audio track lists) **/

	  }, {
	    key: 'audioTrack',
	    get: function get() {
	      return this.audioTrackController.audioTrack;
	    }

	    /** select an audio track, based on its index in audio track lists**/
	    ,
	    set: function set(audioTrackId) {
	      this.audioTrackController.audioTrack = audioTrackId;
	    }
	  }, {
	    key: 'liveSyncPosition',
	    get: function get() {
	      return this.streamController.liveSyncPosition;
	    }
	  }]);

	  return Hls;
	}();

	exports.default = Hls;

	},{"1":1,"10":10,"11":11,"12":12,"13":13,"26":26,"28":28,"34":34,"35":35,"36":36,"4":4,"43":43,"45":45,"47":47,"5":5,"6":6,"7":7,"8":8}],33:[function(_dereq_,module,exports){
	'use strict';

	// This is mostly for support of the es6 module export
	// syntax with the babel compiler, it looks like it doesnt support
	// function exports like we are used to in node/commonjs
	module.exports = _dereq_(32).default;

	},{"32":32}],34:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	var _urlToolkit = _dereq_(2);

	var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var FragmentLoader = function (_EventHandler) {
	  _inherits(FragmentLoader, _EventHandler);

	  function FragmentLoader(hls) {
	    _classCallCheck(this, FragmentLoader);

	    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

	    _this.loaders = {};
	    return _this;
	  }

	  _createClass(FragmentLoader, [{
	    key: 'destroy',
	    value: function destroy() {
	      var loaders = this.loaders;
	      for (var loaderName in loaders) {
	        var loader = loaders[loaderName];
	        if (loader) {
	          loader.destroy();
	        }
	      }
	      this.loaders = {};
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onFragLoading',
	    value: function onFragLoading(data) {
	      var frag = data.frag,
	          type = frag.type,
	          loader = this.loaders[type],
	          config = this.hls.config;

	      frag.loaded = 0;
	      if (loader) {
	        _logger.logger.warn('abort previous fragment loader for type:' + type);
	        loader.abort();
	      }
	      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

	      var loaderContext = void 0,
	          loaderConfig = void 0,
	          loaderCallbacks = void 0;
	      var url = frag.url ? frag.url : _urlToolkit2.default.buildAbsoluteURL(frag.baseurl, frag.relurl);
	      loaderContext = { url: url, frag: frag, responseType: 'arraybuffer', progressData: false };
	      var start = frag.byteRangeStartOffset,
	          end = frag.byteRangeEndOffset;
	      if (!isNaN(start) && !isNaN(end)) {
	        loaderContext.rangeStart = start;
	        loaderContext.rangeEnd = end;
	      }
	      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
	      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
	      loader.load(loaderContext, loaderConfig, loaderCallbacks);
	    }
	  }, {
	    key: 'loadsuccess',
	    value: function loadsuccess(response, stats, context) {
	      var payload = response.data,
	          frag = context.frag;
	      // detach fragment loader on load success
	      frag.loader = undefined;
	      this.loaders[frag.type] = undefined;
	      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
	    }
	  }, {
	    key: 'loaderror',
	    value: function loaderror(response, context) {
	      var loader = context.loader;
	      if (loader) {
	        loader.abort();
	      }
	      this.loaders[context.type] = undefined;
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
	    }
	  }, {
	    key: 'loadtimeout',
	    value: function loadtimeout(stats, context) {
	      var loader = context.loader;
	      if (loader) {
	        loader.abort();
	      }
	      this.loaders[context.type] = undefined;
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
	    }

	    // data will be used for progressive parsing

	  }, {
	    key: 'loadprogress',
	    value: function loadprogress(stats, context, data) {
	      // jshint ignore:line
	      var frag = context.frag;
	      frag.loaded = stats.loaded;
	      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
	    }
	  }]);

	  return FragmentLoader;
	}(_eventHandler2.default);

	exports.default = FragmentLoader;

	},{"2":2,"26":26,"27":27,"28":28,"45":45}],35:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _errors = _dereq_(26);

	var _logger = _dereq_(45);

	var _urlToolkit = _dereq_(2);

	var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	var KeyLoader = function (_EventHandler) {
	  _inherits(KeyLoader, _EventHandler);

	  function KeyLoader(hls) {
	    _classCallCheck(this, KeyLoader);

	    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

	    _this.loaders = {};
	    _this.decryptkey = null;
	    _this.decrypturl = null;
	    return _this;
	  }

	  _createClass(KeyLoader, [{
	    key: 'destroy',
	    value: function destroy() {
	      for (var loaderName in this.loaders) {
	        var loader = this.loaders[loaderName];
	        if (loader) {
	          loader.destroy();
	        }
	      }
	      this.loaders = {};
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onKeyLoading',
	    value: function onKeyLoading(data) {
	      var frag = data.frag,
	          type = frag.type,
	          loader = this.loaders[type],
	          decryptdata = frag.decryptdata,
	          uri = decryptdata.uri ? decryptdata.uri : _urlToolkit2.default.buildAbsoluteURL(decryptdata.baseuri, decryptdata.reluri);
	      // if uri is different from previous one or if decrypt key not retrieved yet
	      if (uri !== this.decrypturl || this.decryptkey === null) {
	        var config = this.hls.config;

	        if (loader) {
	          _logger.logger.warn('abort previous key loader for type:' + type);
	          loader.abort();
	        }
	        frag.loader = this.loaders[type] = new config.loader(config);
	        this.decrypturl = uri;
	        this.decryptkey = null;

	        var loaderContext = void 0,
	            loaderConfig = void 0,
	            loaderCallbacks = void 0;
	        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
	        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
	        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
	        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
	      } else if (this.decryptkey) {
	        // we already loaded this key, return it
	        decryptdata.key = this.decryptkey;
	        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
	      }
	    }
	  }, {
	    key: 'loadsuccess',
	    value: function loadsuccess(response, stats, context) {
	      var frag = context.frag;
	      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
	      // detach fragment loader on load success
	      frag.loader = undefined;
	      this.loaders[frag.type] = undefined;
	      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
	    }
	  }, {
	    key: 'loaderror',
	    value: function loaderror(response, context) {
	      var frag = context.frag,
	          loader = frag.loader;
	      if (loader) {
	        loader.abort();
	      }
	      this.loaders[context.type] = undefined;
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
	    }
	  }, {
	    key: 'loadtimeout',
	    value: function loadtimeout(stats, context) {
	      var frag = context.frag,
	          loader = frag.loader;
	      if (loader) {
	        loader.abort();
	      }
	      this.loaders[context.type] = undefined;
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
	    }
	  }]);

	  return KeyLoader;
	}(_eventHandler2.default);

	exports.default = KeyLoader;

	},{"2":2,"26":26,"27":27,"28":28,"45":45}],36:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _urlToolkit = _dereq_(2);

	var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _eventHandler = _dereq_(27);

	var _eventHandler2 = _interopRequireDefault(_eventHandler);

	var _errors = _dereq_(26);

	var _attrList = _dereq_(40);

	var _attrList2 = _interopRequireDefault(_attrList);

	var _logger = _dereq_(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Playlist Loader
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

	// https://regex101.com is your friend
	var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
	var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
	var LEVEL_PLAYLIST_REGEX = /(?:#EXT(INF): *(\d*(?:\.\d+)?)(?:,(.*))?)|(?:(?!#)()(\S.+))|(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(BYTERANGE): *(\d+(?:@\d+(?:\.\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\r?\n?/g;

	var PlaylistLoader = function (_EventHandler) {
	  _inherits(PlaylistLoader, _EventHandler);

	  function PlaylistLoader(hls) {
	    _classCallCheck(this, PlaylistLoader);

	    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING));

	    _this.loaders = {};
	    return _this;
	  }

	  _createClass(PlaylistLoader, [{
	    key: 'destroy',
	    value: function destroy() {
	      for (var loaderName in this.loaders) {
	        var loader = this.loaders[loaderName];
	        if (loader) {
	          loader.destroy();
	        }
	      }
	      this.loaders = {};
	      _eventHandler2.default.prototype.destroy.call(this);
	    }
	  }, {
	    key: 'onManifestLoading',
	    value: function onManifestLoading(data) {
	      this.load(data.url, { type: 'manifest' });
	    }
	  }, {
	    key: 'onLevelLoading',
	    value: function onLevelLoading(data) {
	      this.load(data.url, { type: 'level', level: data.level, id: data.id });
	    }
	  }, {
	    key: 'onAudioTrackLoading',
	    value: function onAudioTrackLoading(data) {
	      this.load(data.url, { type: 'audioTrack', id: data.id });
	    }
	  }, {
	    key: 'load',
	    value: function load(url, context) {
	      var loader = this.loaders[context.type];
	      if (loader) {
	        var loaderContext = loader.context;
	        if (loaderContext && loaderContext.url === url) {
	          _logger.logger.trace('playlist request ongoing');
	          return;
	        } else {
	          _logger.logger.warn('abort previous loader for type:' + context.type);
	          loader.abort();
	        }
	      }
	      var config = this.hls.config,
	          retry = void 0,
	          timeout = void 0,
	          retryDelay = void 0,
	          maxRetryDelay = void 0;
	      if (context.type === 'manifest') {
	        retry = config.manifestLoadingMaxRetry;
	        timeout = config.manifestLoadingTimeOut;
	        retryDelay = config.manifestLoadingRetryDelay;
	        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
	      } else {
	        retry = config.levelLoadingMaxRetry;
	        timeout = config.levelLoadingTimeOut;
	        retryDelay = config.levelLoadingRetryDelay;
	        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
	        _logger.logger.log('loading playlist for level ' + context.level);
	      }
	      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
	      context.url = url;
	      context.responseType = '';

	      var loaderConfig = void 0,
	          loaderCallbacks = void 0;
	      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
	      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
	      loader.load(context, loaderConfig, loaderCallbacks);
	    }
	  }, {
	    key: 'resolve',
	    value: function resolve(url, baseUrl) {
	      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url);
	    }
	  }, {
	    key: 'parseMasterPlaylist',
	    value: function parseMasterPlaylist(string, baseurl) {
	      var levels = [],
	          result = void 0;
	      MASTER_PLAYLIST_REGEX.lastIndex = 0;
	      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
	        var level = {};

	        var attrs = level.attrs = new _attrList2.default(result[1]);
	        level.url = this.resolve(result[2], baseurl);

	        var resolution = attrs.decimalResolution('RESOLUTION');
	        if (resolution) {
	          level.width = resolution.width;
	          level.height = resolution.height;
	        }
	        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
	        level.name = attrs.NAME;

	        var codecs = attrs.CODECS;
	        if (codecs) {
	          codecs = codecs.split(/[ ,]+/);
	          for (var i = 0; i < codecs.length; i++) {
	            var codec = codecs[i];
	            if (codec.indexOf('avc1') !== -1) {
	              level.videoCodec = this.avc1toavcoti(codec);
	            } else {
	              level.audioCodec = codec;
	            }
	          }
	        }

	        levels.push(level);
	      }
	      return levels;
	    }
	  }, {
	    key: 'parseMasterPlaylistMedia',
	    value: function parseMasterPlaylistMedia(string, baseurl, type) {
	      var result = void 0,
	          medias = [];
	      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
	      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
	        var media = {};
	        var attrs = new _attrList2.default(result[1]);
	        if (attrs.TYPE === type) {
	          media.groupId = attrs['GROUP-ID'];
	          media.name = attrs.NAME;
	          media.type = type;
	          media.default = attrs.DEFAULT === 'YES';
	          media.autoselect = attrs.AUTOSELECT === 'YES';
	          media.forced = attrs.FORCED === 'YES';
	          if (attrs.URI) {
	            media.url = this.resolve(attrs.URI, baseurl);
	          }
	          media.lang = attrs.LANGUAGE;
	          if (!media.name) {
	            media.name = media.lang;
	          }
	          medias.push(media);
	        }
	      }
	      return medias;
	    }
	    /**
	     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
	     * @returns {Uint8Array}
	     */

	  }, {
	    key: 'createInitializationVector',
	    value: function createInitializationVector(segmentNumber) {
	      var uint8View = new Uint8Array(16);

	      for (var i = 12; i < 16; i++) {
	        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
	      }

	      return uint8View;
	    }

	    /**
	     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
	     * @param levelkey - a playlist's encryption info
	     * @param segmentNumber - the fragment's segment number
	     * @returns {*} - an object to be applied as a fragment's decryptdata
	     */

	  }, {
	    key: 'fragmentDecryptdataFromLevelkey',
	    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
	      var decryptdata = levelkey;

	      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
	        decryptdata = this.cloneObj(levelkey);
	        decryptdata.iv = this.createInitializationVector(segmentNumber);
	      }

	      return decryptdata;
	    }
	  }, {
	    key: 'avc1toavcoti',
	    value: function avc1toavcoti(codec) {
	      var result,
	          avcdata = codec.split('.');
	      if (avcdata.length > 2) {
	        result = avcdata.shift() + '.';
	        result += parseInt(avcdata.shift()).toString(16);
	        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
	      } else {
	        result = codec;
	      }
	      return result;
	    }
	  }, {
	    key: 'cloneObj',
	    value: function cloneObj(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    }
	  }, {
	    key: 'parseLevelPlaylist',
	    value: function parseLevelPlaylist(string, baseurl, id, type) {
	      var currentSN = 0,
	          fragdecryptdata,
	          totalduration = 0,
	          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
	          levelkey = { method: null, key: null, iv: null, uri: null },
	          cc = 0,
	          programDateTime = null,
	          frag = null,
	          result,
	          duration = null,
	          title = null,
	          byteRangeEndOffset = null,
	          byteRangeStartOffset = null,
	          tagList = [],
	          i,
	          config = this.hls.config,
	          lazyURLResolve = config ? config.enableLazyURLResolve : false;

	      LEVEL_PLAYLIST_REGEX.lastIndex = 0;

	      while ((result = LEVEL_PLAYLIST_REGEX.exec(string)) !== null) {
	        for (i = 1; i < result.length; i++) {
	          if (result[i] !== undefined) {
	            break;
	          }
	        }
	        var key = result[i],
	            value1 = result[i + 1],
	            value2 = result[i + 2];

	        switch (key) {
	          case 'PLAYLIST-TYPE':
	            level.type = value1.toUpperCase();
	            break;
	          case 'MEDIA-SEQUENCE':
	            currentSN = level.startSN = parseInt(value1);
	            break;
	          case 'TARGETDURATION':
	            level.targetduration = parseFloat(value1);
	            break;
	          case 'VERSION':
	            level.version = parseInt(value1);
	            break;
	          case 'EXTM3U':
	            break;
	          case 'ENDLIST':
	            level.live = false;
	            break;
	          case 'DIS':
	            cc++;
	            tagList.push([key]);
	            break;
	          case 'DISCONTINUITY-SEQ':
	            cc = parseInt(value1);
	            break;
	          case 'BYTERANGE':
	            var params = value1.split('@');
	            if (params.length === 1) {
	              byteRangeStartOffset = byteRangeEndOffset;
	            } else {
	              byteRangeStartOffset = parseInt(params[1]);
	            }
	            byteRangeEndOffset = parseInt(params[0]) + byteRangeStartOffset;
	            break;
	          case 'INF':
	            duration = parseFloat(value1);
	            title = value2 ? value2 : null;
	            tagList.push(value2 ? [key, value1, value2] : [key, value1]);
	            break;
	          case '':
	            // url
	            if (!isNaN(duration)) {
	              var sn = currentSN++;
	              fragdecryptdata = this.fragmentDecryptdataFromLevelkey(levelkey, sn);
	              frag = { type: type,
	                duration: duration,
	                title: title,
	                start: totalduration,
	                sn: sn,
	                level: id,
	                cc: cc,
	                decryptdata: fragdecryptdata,
	                programDateTime: programDateTime,
	                tagList: tagList };
	              if (lazyURLResolve) {
	                frag.relurl = value1;
	                frag.baseurl = baseurl;
	              } else {
	                frag.url = value1 ? this.resolve(value1, baseurl) : null;
	              }
	              // only include byte range options if used/needed
	              if (byteRangeStartOffset !== null) {
	                frag.byteRangeStartOffset = byteRangeStartOffset;
	                frag.byteRangeEndOffset = byteRangeEndOffset;
	              }
	              level.fragments.push(frag);
	              totalduration += duration;
	              duration = null;
	              title = null;
	              byteRangeStartOffset = null;
	              programDateTime = null;
	              tagList = [];
	            }
	            break;
	          case 'KEY':
	            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
	            var decryptparams = value1;
	            var keyAttrs = new _attrList2.default(decryptparams);
	            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
	                decrypturi = keyAttrs.URI,
	                decryptiv = keyAttrs.hexadecimalInteger('IV');
	            if (decryptmethod) {
	              levelkey = { method: null, key: null, iv: null, uri: null };
	              if (decrypturi && decryptmethod === 'AES-128') {
	                levelkey.method = decryptmethod;
	                // URI to get the key
	                if (lazyURLResolve) {
	                  levelkey.baseuri = baseurl;
	                  levelkey.reluri = decrypturi;
	                } else {
	                  levelkey.uri = this.resolve(decrypturi, baseurl);
	                }
	                levelkey.key = null;
	                // Initialization Vector (IV)
	                levelkey.iv = decryptiv;
	              }
	            }
	            break;
	          case 'START':
	            var startParams = value1;
	            var startAttrs = new _attrList2.default(startParams);
	            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
	            //TIME-OFFSET can be 0
	            if (!isNaN(startTimeOffset)) {
	              level.startTimeOffset = startTimeOffset;
	            }
	            break;
	          case 'PROGRAM-DATE-TIME':
	            programDateTime = new Date(Date.parse(value1));
	            tagList.push([key, value1]);
	            break;
	          case '#':
	            tagList.push(value2 ? [value1, value2] : [value1]);
	            break;
	          default:
	            _logger.logger.warn('line parsed but not handled: ' + result);
	            break;
	        }
	      }
	      //logger.log('found ' + level.fragments.length + ' fragments');
	      if (frag && !(frag.url || frag.relurl)) {
	        level.fragments.pop();
	        totalduration -= frag.duration;
	      }
	      level.totalduration = totalduration;
	      level.averagetargetduration = totalduration / level.fragments.length;
	      level.endSN = currentSN - 1;
	      return level;
	    }
	  }, {
	    key: 'loadsuccess',
	    value: function loadsuccess(response, stats, context) {
	      var string = response.data,
	          url = response.url,
	          type = context.type,
	          id = context.id,
	          level = context.level,
	          hls = this.hls;

	      this.loaders[type] = undefined;
	      // responseURL not supported on some browsers (it is used to detect URL redirection)
	      // data-uri mode also not supported (but no need to detect redirection)
	      if (url === undefined || url.indexOf('data:') === 0) {
	        // fallback to initial URL
	        url = context.url;
	      }
	      stats.tload = performance.now();
	      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
	      if (string.indexOf('#EXTM3U') === 0) {
	        if (string.indexOf('#EXTINF:') > 0) {
	          var isLevel = type !== 'audioTrack',
	              levelDetails = this.parseLevelPlaylist(string, url, (isLevel ? level : id) || 0, isLevel ? 'main' : 'audio');
	          if (type === 'manifest') {
	            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
	            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });
	          }
	          stats.tparsed = performance.now();
	          if (levelDetails.targetduration) {
	            if (isLevel) {
	              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
	            } else {
	              hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
	            }
	          } else {
	            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });
	          }
	        } else {
	          var levels = this.parseMasterPlaylist(string, url);
	          // multi level playlist, parse level info
	          if (levels.length) {
	            var audiotracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
	            if (audiotracks.length) {
	              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
	              var embeddedAudioFound = false;
	              audiotracks.forEach(function (audioTrack) {
	                if (!audioTrack.url) {
	                  embeddedAudioFound = true;
	                }
	              });
	              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
	              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
	              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
	                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
	                audiotracks.unshift({ type: 'main', name: 'main' });
	              }
	            }
	            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audiotracks, url: url, stats: stats });
	          } else {
	            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
	          }
	        }
	      } else {
	        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
	      }
	    }
	  }, {
	    key: 'loaderror',
	    value: function loaderror(response, context) {
	      var details,
	          fatal,
	          loader = context.loader;
	      switch (context.type) {
	        case 'manifest':
	          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
	          fatal = true;
	          break;
	        case 'level':
	          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
	          fatal = false;
	          break;
	        case 'audioTrack':
	          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
	          fatal = false;
	          break;
	      }
	      if (loader) {
	        loader.abort();
	        this.loaders[context.type] = undefined;
	      }
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
	    }
	  }, {
	    key: 'loadtimeout',
	    value: function loadtimeout(stats, context) {
	      var details,
	          fatal,
	          loader = context.loader;
	      switch (context.type) {
	        case 'manifest':
	          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
	          fatal = true;
	          break;
	        case 'level':
	          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
	          fatal = false;
	          break;
	        case 'audioTrack':
	          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
	          fatal = false;
	          break;
	      }
	      if (loader) {
	        loader.abort();
	        this.loaders[context.type] = undefined;
	      }
	      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
	    }
	  }]);

	  return PlaylistLoader;
	}(_eventHandler2.default);

	exports.default = PlaylistLoader;

	},{"2":2,"26":26,"27":27,"28":28,"40":40,"45":45}],37:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Generate MP4 Box
	*/

	//import Hex from '../utils/hex';
	var MP4 = function () {
	  function MP4() {
	    _classCallCheck(this, MP4);
	  }

	  _createClass(MP4, null, [{
	    key: 'init',
	    value: function init() {
	      MP4.types = {
	        avc1: [], // codingname
	        avcC: [],
	        btrt: [],
	        dinf: [],
	        dref: [],
	        esds: [],
	        ftyp: [],
	        hdlr: [],
	        mdat: [],
	        mdhd: [],
	        mdia: [],
	        mfhd: [],
	        minf: [],
	        moof: [],
	        moov: [],
	        mp4a: [],
	        '.mp3': [],
	        mvex: [],
	        mvhd: [],
	        sdtp: [],
	        stbl: [],
	        stco: [],
	        stsc: [],
	        stsd: [],
	        stsz: [],
	        stts: [],
	        tfdt: [],
	        tfhd: [],
	        traf: [],
	        trak: [],
	        trun: [],
	        trex: [],
	        tkhd: [],
	        vmhd: [],
	        smhd: []
	      };

	      var i;
	      for (i in MP4.types) {
	        if (MP4.types.hasOwnProperty(i)) {
	          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
	        }
	      }

	      var videoHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
	      ]);

	      var audioHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
	      ]);

	      MP4.HDLR_TYPES = {
	        'video': videoHdlr,
	        'audio': audioHdlr
	      };

	      var dref = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01, // entry_count
	      0x00, 0x00, 0x00, 0x0c, // entry_size
	      0x75, 0x72, 0x6c, 0x20, // 'url' type
	      0x00, // version 0
	      0x00, 0x00, 0x01 // entry_flags
	      ]);

	      var stco = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00 // entry_count
	      ]);

	      MP4.STTS = MP4.STSC = MP4.STCO = stco;

	      MP4.STSZ = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // sample_size
	      0x00, 0x00, 0x00, 0x00]);
	      MP4.VMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x01, // flags
	      0x00, 0x00, // graphicsmode
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
	      ]);
	      MP4.SMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, // balance
	      0x00, 0x00 // reserved
	      ]);

	      MP4.STSD = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01]); // entry_count

	      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
	      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
	      var minorVersion = new Uint8Array([0, 0, 0, 1]);

	      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
	      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
	    }
	  }, {
	    key: 'box',
	    value: function box(type) {
	      var payload = Array.prototype.slice.call(arguments, 1),
	          size = 8,
	          i = payload.length,
	          len = i,
	          result;
	      // calculate the total size we need to allocate
	      while (i--) {
	        size += payload[i].byteLength;
	      }
	      result = new Uint8Array(size);
	      result[0] = size >> 24 & 0xff;
	      result[1] = size >> 16 & 0xff;
	      result[2] = size >> 8 & 0xff;
	      result[3] = size & 0xff;
	      result.set(type, 4);
	      // copy the payload into the result
	      for (i = 0, size = 8; i < len; i++) {
	        // copy payload[i] array @ offset size
	        result.set(payload[i], size);
	        size += payload[i].byteLength;
	      }
	      return result;
	    }
	  }, {
	    key: 'hdlr',
	    value: function hdlr(type) {
	      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
	    }
	  }, {
	    key: 'mdat',
	    value: function mdat(data) {
	      return MP4.box(MP4.types.mdat, data);
	    }
	  }, {
	    key: 'mdhd',
	    value: function mdhd(timescale, duration) {
	      duration *= timescale;
	      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
	      0x55, 0xc4, // 'und' language (undetermined)
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'mdia',
	    value: function mdia(track) {
	      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
	    }
	  }, {
	    key: 'mfhd',
	    value: function mfhd(sequenceNumber) {
	      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
	      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
	    }
	  }, {
	    key: 'minf',
	    value: function minf(track) {
	      if (track.type === 'audio') {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
	      } else {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
	      }
	    }
	  }, {
	    key: 'moof',
	    value: function moof(sn, baseMediaDecodeTime, track) {
	      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
	    }
	    /**
	     * @param tracks... (optional) {array} the tracks associated with this movie
	     */

	  }, {
	    key: 'moov',
	    value: function moov(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trak(tracks[i]);
	      }

	      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
	    }
	  }, {
	    key: 'mvex',
	    value: function mvex(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trex(tracks[i]);
	      }
	      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
	    }
	  }, {
	    key: 'mvhd',
	    value: function mvhd(timescale, duration) {
	      duration *= timescale;
	      var bytes = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01, // creation_time
	      0x00, 0x00, 0x00, 0x02, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
	      0x00, 0x01, 0x00, 0x00, // 1.0 rate
	      0x01, 0x00, // 1.0 volume
	      0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
	      0xff, 0xff, 0xff, 0xff // next_track_ID
	      ]);
	      return MP4.box(MP4.types.mvhd, bytes);
	    }
	  }, {
	    key: 'sdtp',
	    value: function sdtp(track) {
	      var samples = track.samples || [],
	          bytes = new Uint8Array(4 + samples.length),
	          flags,
	          i;
	      // leave the full box header (4 bytes) all zero
	      // write the sample table
	      for (i = 0; i < samples.length; i++) {
	        flags = samples[i].flags;
	        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
	      }

	      return MP4.box(MP4.types.sdtp, bytes);
	    }
	  }, {
	    key: 'stbl',
	    value: function stbl(track) {
	      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
	    }
	  }, {
	    key: 'avc1',
	    value: function avc1(track) {
	      var sps = [],
	          pps = [],
	          i,
	          data,
	          len;
	      // assemble the SPSs

	      for (i = 0; i < track.sps.length; i++) {
	        data = track.sps[i];
	        len = data.byteLength;
	        sps.push(len >>> 8 & 0xFF);
	        sps.push(len & 0xFF);
	        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
	      }

	      // assemble the PPSs
	      for (i = 0; i < track.pps.length; i++) {
	        data = track.pps[i];
	        len = data.byteLength;
	        pps.push(len >>> 8 & 0xFF);
	        pps.push(len & 0xFF);
	        pps = pps.concat(Array.prototype.slice.call(data));
	      }

	      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
	      sps[3], // profile
	      sps[4], // profile compat
	      sps[5], // level
	      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
	      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
	      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
	      ]).concat(pps))),
	          // "PPS"
	      width = track.width,
	          height = track.height;
	      //console.log('avcc:' + Hex.hexDump(avcc));
	      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, // pre_defined
	      0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
	      width >> 8 & 0xFF, width & 0xff, // width
	      height >> 8 & 0xFF, height & 0xff, // height
	      0x00, 0x48, 0x00, 0x00, // horizresolution
	      0x00, 0x48, 0x00, 0x00, // vertresolution
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // frame_count
	      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
	      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
	      0x00, 0x18, // depth = 24
	      0x11, 0x11]), // pre_defined = -1
	      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
	      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
	      0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate
	      );
	    }
	  }, {
	    key: 'esds',
	    value: function esds(track) {
	      var configlen = track.config.length;
	      return new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags

	      0x03, // descriptor_type
	      0x17 + configlen, // length
	      0x00, 0x01, //es_id
	      0x00, // stream_priority

	      0x04, // descriptor_type
	      0x0f + configlen, // length
	      0x40, //codec : mpeg4_audio
	      0x15, // stream_type
	      0x00, 0x00, 0x00, // buffer_size
	      0x00, 0x00, 0x00, 0x00, // maxBitrate
	      0x00, 0x00, 0x00, 0x00, // avgBitrate

	      0x05 // descriptor_type
	      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
	    }
	  }, {
	    key: 'mp4a',
	    value: function mp4a(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
	    }
	  }, {
	    key: 'mp3',
	    value: function mp3(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'stsd',
	    value: function stsd(track) {
	      if (track.type === 'audio') {
	        if (!track.isAAC && track.codec === 'mp3') {
	          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
	        }
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
	      } else {
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
	      }
	    }
	  }, {
	    key: 'tkhd',
	    value: function tkhd(track) {
	      var id = track.id,
	          duration = track.duration * track.timescale,
	          width = track.width,
	          height = track.height;
	      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x07, // flags
	      0x00, 0x00, 0x00, 0x00, // creation_time
	      0x00, 0x00, 0x00, 0x00, // modification_time
	      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x00, // reserved
	      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, // layer
	      0x00, 0x00, // alternate_group
	      0x00, 0x00, // non-audio track volume
	      0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
	      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
	      ]));
	    }
	  }, {
	    key: 'traf',
	    value: function traf(track, baseMediaDecodeTime) {
	      var sampleDependencyTable = MP4.sdtp(track),
	          id = track.id;
	      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
	      16 + // tfdt
	      8 + // traf header
	      16 + // mfhd
	      8 + // moof header
	      8), // mdat header
	      sampleDependencyTable);
	    }

	    /**
	     * Generate a track box.
	     * @param track {object} a track definition
	     * @return {Uint8Array} the track box
	     */

	  }, {
	    key: 'trak',
	    value: function trak(track) {
	      track.duration = track.duration || 0xffffffff;
	      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
	    }
	  }, {
	    key: 'trex',
	    value: function trex(track) {
	      var id = track.id;
	      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
	      0x00, 0x00, 0x00, 0x00, // default_sample_duration
	      0x00, 0x00, 0x00, 0x00, // default_sample_size
	      0x00, 0x01, 0x00, 0x01 // default_sample_flags
	      ]));
	    }
	  }, {
	    key: 'trun',
	    value: function trun(track, offset) {
	      var samples = track.samples || [],
	          len = samples.length,
	          arraylen = 12 + 16 * len,
	          array = new Uint8Array(arraylen),
	          i,
	          sample,
	          duration,
	          size,
	          flags,
	          cts;
	      offset += 8 + arraylen;
	      array.set([0x00, // version 0
	      0x00, 0x0f, 0x01, // flags
	      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
	      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
	      ], 0);
	      for (i = 0; i < len; i++) {
	        sample = samples[i];
	        duration = sample.duration;
	        size = sample.size;
	        flags = sample.flags;
	        cts = sample.cts;
	        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
	        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
	        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
	        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
	        ], 12 + 16 * i);
	      }
	      return MP4.box(MP4.types.trun, array);
	    }
	  }, {
	    key: 'initSegment',
	    value: function initSegment(tracks) {
	      if (!MP4.types) {
	        MP4.init();
	      }
	      var movie = MP4.moov(tracks),
	          result;
	      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
	      result.set(MP4.FTYP);
	      result.set(movie, MP4.FTYP.byteLength);
	      return result;
	    }
	  }]);

	  return MP4;
	}();

	exports.default = MP4;

	},{}],38:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	var _aac = _dereq_(29);

	var _aac2 = _interopRequireDefault(_aac);

	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	var _logger = _dereq_(45);

	var _mp4Generator = _dereq_(37);

	var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

	var _errors = _dereq_(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MP4Remuxer = function () {
	  function MP4Remuxer(observer, id, config, typeSupported) {
	    _classCallCheck(this, MP4Remuxer);

	    this.observer = observer;
	    this.id = id;
	    this.config = config;
	    this.typeSupported = typeSupported;
	    this.ISGenerated = false;
	    this.PES2MP4SCALEFACTOR = 4;
	    this.PES_TIMESCALE = 90000;
	    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;
	  }

	  _createClass(MP4Remuxer, [{
	    key: 'destroy',
	    value: function destroy() {}
	  }, {
	    key: 'insertDiscontinuity',
	    value: function insertDiscontinuity() {
	      this._initPTS = this._initDTS = undefined;
	    }
	  }, {
	    key: 'switchLevel',
	    value: function switchLevel() {
	      this.ISGenerated = false;
	    }
	  }, {
	    key: 'remux',
	    value: function remux(level, sn, audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
	      this.level = level;
	      this.sn = sn;
	      // generate Init Segment if needed
	      if (!this.ISGenerated) {
	        this.generateIS(audioTrack, videoTrack, timeOffset);
	      }

	      if (this.ISGenerated) {
	        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
	        // calculated in remuxAudio.
	        //logger.log('nb AAC samples:' + audioTrack.samples.length);
	        if (audioTrack.samples.length) {
	          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
	          //logger.log('nb AVC samples:' + videoTrack.samples.length);
	          if (videoTrack.samples.length) {
	            var audioTrackLength = void 0;
	            if (audioData) {
	              audioTrackLength = audioData.endPTS - audioData.startPTS;
	            }
	            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
	          }
	        } else {
	          var videoData = void 0;
	          //logger.log('nb AVC samples:' + videoTrack.samples.length);
	          if (videoTrack.samples.length) {
	            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
	          }
	          if (videoData && audioTrack.codec) {
	            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
	          }
	        }
	      }
	      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
	      if (id3Track.samples.length) {
	        this.remuxID3(id3Track, timeOffset);
	      }
	      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
	      if (textTrack.samples.length) {
	        this.remuxText(textTrack, timeOffset);
	      }
	      //notify end of parsing
	      this.observer.trigger(_events2.default.FRAG_PARSED, { id: this.id, level: this.level, sn: this.sn });
	    }
	  }, {
	    key: 'generateIS',
	    value: function generateIS(audioTrack, videoTrack, timeOffset) {
	      var observer = this.observer,
	          audioSamples = audioTrack.samples,
	          videoSamples = videoTrack.samples,
	          pesTimeScale = this.PES_TIMESCALE,
	          typeSupported = this.typeSupported,
	          container = 'audio/mp4',
	          tracks = {},
	          data = { id: this.id, level: this.level, sn: this.sn, tracks: tracks, unique: false },
	          computePTSDTS = this._initPTS === undefined,
	          initPTS,
	          initDTS;

	      if (computePTSDTS) {
	        initPTS = initDTS = Infinity;
	      }
	      if (audioTrack.config && audioSamples.length) {
	        audioTrack.timescale = audioTrack.audiosamplerate;
	        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits
	        // we know that each AAC sample contains 1024 frames....
	        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)
	        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)
	        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {
	          (function () {
	            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {
	              if (!b) {
	                return a;
	              }
	              return greatestCommonDivisor(b, a % b);
	            };
	            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, audioTrack.isAAC ? 1024 : 1152);
	          })();
	        }
	        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);
	        if (!audioTrack.isAAC) {
	          if (typeSupported.mpeg) {
	            // Chrome and Safari
	            container = 'audio/mpeg';
	            audioTrack.codec = '';
	          } else if (typeSupported.mp3) {
	            // Firefox
	            audioTrack.codec = 'mp3';
	          }
	        }
	        tracks.audio = {
	          container: container,
	          codec: audioTrack.codec,
	          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
	          metadata: {
	            channelCount: audioTrack.channelCount
	          }
	        };
	        if (computePTSDTS) {
	          // remember first PTS of this demuxing context. for audio, PTS = DTS
	          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;
	        }
	      }

	      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
	        videoTrack.timescale = this.MP4_TIMESCALE;
	        tracks.video = {
	          container: 'video/mp4',
	          codec: videoTrack.codec,
	          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
	          metadata: {
	            width: videoTrack.width,
	            height: videoTrack.height
	          }
	        };
	        if (computePTSDTS) {
	          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);
	          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);
	        }
	      }

	      if (Object.keys(tracks).length) {
	        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
	        this.ISGenerated = true;
	        if (computePTSDTS) {
	          this._initPTS = initPTS;
	          this._initDTS = initDTS;
	        }
	      } else {
	        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
	      }
	    }
	  }, {
	    key: 'remuxVideo',
	    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
	      var offset = 8,
	          pesTimeScale = this.PES_TIMESCALE,
	          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,
	          mp4SampleDuration,
	          mdat,
	          moof,
	          firstPTS,
	          firstDTS,
	          nextDTS,
	          lastPTS,
	          lastDTS,
	          inputSamples = track.samples,
	          outputSamples = [],
	          ptsNormalize = this._PTSNormalize,
	          initDTS = this._initDTS;

	      // for (let i = 0; i < track.samples.length; i++) {
	      //   let avcSample = track.samples[i];
	      //   let units = avcSample.units.units;
	      //   let unitsString = '';
	      //   for (let j = 0; j < units.length ; j++) {
	      //     unitsString += units[j].type + ',';
	      //     if (units[j].data.length < 500) {
	      //       unitsString += Hex.hexDump(units[j].data);
	      //     }
	      //   }
	      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
	      // }

	      // sort video samples by DTS order
	      inputSamples.sort(function (a, b) {
	        return a.dts - b.dts;
	      });

	      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
	      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
	        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
	      }, 0);
	      if (PTSDTSshift < 0) {
	        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
	        for (var i = 0; i < inputSamples.length; i++) {
	          inputSamples[i].dts += PTSDTSshift;
	        }
	      }

	      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
	      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
	      var nextAvcDts = void 0;
	      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
	      if (contiguous) {
	        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
	        nextAvcDts = this.nextAvcDts;
	      } else {
	        // if not contiguous, let's use target timeOffset
	        nextAvcDts = timeOffset * pesTimeScale;
	      }

	      // compute first DTS and last DTS, normalize them against reference value
	      var sample = inputSamples[0];
	      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
	      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);

	      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
	      var delta = Math.round((firstDTS - nextAvcDts) / 90);
	      // if fragment are contiguous, detect hole/overlapping between fragments
	      if (contiguous) {
	        if (delta) {
	          if (delta > 1) {
	            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
	          } else if (delta < -1) {
	            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
	          }
	          // remove hole/gap : set DTS to next expected DTS
	          firstDTS = nextAvcDts;
	          inputSamples[0].dts = firstDTS + initDTS;
	          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
	          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
	          inputSamples[0].pts = firstPTS + initDTS;
	          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
	        }
	      }
	      nextDTS = firstDTS;

	      // compute lastPTS/lastDTS
	      sample = inputSamples[inputSamples.length - 1];
	      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
	      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
	      lastPTS = Math.max(lastPTS, lastDTS);

	      var vendor = navigator.vendor,
	          userAgent = navigator.userAgent,
	          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');

	      // on Safari let's signal the same sample duration for all samples
	      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
	      // set this constant duration as being the avg delta between consecutive DTS.
	      if (isSafari) {
	        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));
	      }

	      // normalize all PTS/DTS now ...
	      for (var _i = 0; _i < inputSamples.length; _i++) {
	        var _sample = inputSamples[_i];
	        if (isSafari) {
	          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
	          _sample.dts = firstDTS + _i * pes2mp4ScaleFactor * mp4SampleDuration;
	        } else {
	          // ensure sample monotonic DTS
	          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);
	          // ensure dts is a multiple of scale factor to avoid rounding issues
	          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
	        }
	        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
	        // and we ensure that computed value is greater or equal than sample DTS
	        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);
	        // ensure pts is a multiple of scale factor to avoid rounding issues
	        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
	      }

	      /* concatenate the video data and construct the mdat in place
	        (need 8 more bytes to fill length and mpdat type) */
	      var mdatSize = track.len + 4 * track.nbNalu + 8;
	      try {
	        mdat = new Uint8Array(mdatSize);
	      } catch (err) {
	        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, level: this.level, id: this.id, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
	        return;
	      }
	      var view = new DataView(mdat.buffer);
	      view.setUint32(0, mdat.byteLength);
	      mdat.set(_mp4Generator2.default.types.mdat, 4);

	      for (var _i2 = 0; _i2 < inputSamples.length; _i2++) {
	        var avcSample = inputSamples[_i2],
	            mp4SampleLength = 0,
	            compositionTimeOffset = void 0;
	        // convert NALU bitstream to MP4 format (prepend NALU with size field)
	        while (avcSample.units.units.length) {
	          var unit = avcSample.units.units.shift();
	          view.setUint32(offset, unit.data.byteLength);
	          offset += 4;
	          mdat.set(unit.data, offset);
	          offset += unit.data.byteLength;
	          mp4SampleLength += 4 + unit.data.byteLength;
	        }

	        if (!isSafari) {
	          // expected sample duration is the Decoding Timestamp diff of consecutive samples
	          if (_i2 < inputSamples.length - 1) {
	            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
	          } else {
	            var config = this.config,
	                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
	            if (config.stretchShortVideoTrack) {
	              // In some cases, a segment's audio track duration may exceed the video track duration.
	              // Since we've already remuxed audio, and we know how long the audio track is, we look to
	              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
	              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
	              // the duration of the last frame to minimize any potential gap between segments.
	              var maxBufferHole = config.maxBufferHole,
	                  maxSeekHole = config.maxSeekHole,
	                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),
	                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAudioPts) - avcSample.pts;
	              if (deltaToFrameEnd > gapTolerance) {
	                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
	                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
	                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
	                if (mp4SampleDuration < 0) {
	                  mp4SampleDuration = lastFrameDuration;
	                }
	                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
	              } else {
	                mp4SampleDuration = lastFrameDuration;
	              }
	            } else {
	              mp4SampleDuration = lastFrameDuration;
	            }
	          }
	          mp4SampleDuration /= pes2mp4ScaleFactor;
	          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);
	        } else {
	          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));
	        }

	        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
	        outputSamples.push({
	          size: mp4SampleLength,
	          // constant duration
	          duration: mp4SampleDuration,
	          cts: compositionTimeOffset,
	          flags: {
	            isLeading: 0,
	            isDependedOn: 0,
	            hasRedundancy: 0,
	            degradPrio: 0,
	            dependsOn: avcSample.key ? 2 : 1,
	            isNonSync: avcSample.key ? 0 : 1
	          }
	        });
	      }
	      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
	      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;
	      var dropped = track.dropped;
	      track.len = 0;
	      track.nbNalu = 0;
	      track.dropped = 0;
	      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
	        var flags = outputSamples[0].flags;
	        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
	        // https://code.google.com/p/chromium/issues/detail?id=229412
	        flags.dependsOn = 2;
	        flags.isNonSync = 0;
	      }
	      track.samples = outputSamples;
	      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
	      track.samples = [];

	      var data = {
	        id: this.id,
	        level: this.level,
	        sn: this.sn,
	        data1: moof,
	        data2: mdat,
	        startPTS: firstPTS / pesTimeScale,
	        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,
	        startDTS: firstDTS / pesTimeScale,
	        endDTS: this.nextAvcDts / pesTimeScale,
	        type: 'video',
	        nb: outputSamples.length,
	        dropped: dropped
	      };
	      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
	      return data;
	    }
	  }, {
	    key: 'remuxAudio',
	    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
	      var pesTimeScale = this.PES_TIMESCALE,
	          mp4timeScale = track.timescale,
	          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
	          expectedSampleDuration = track.timescale * (track.isAAC ? 1024 : 1152) / track.audiosamplerate,
	          pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor,
	          ptsNormalize = this._PTSNormalize,
	          initDTS = this._initDTS,
	          rawMPEG = !track.isAAC && this.typeSupported.mpeg;

	      var view,
	          offset = rawMPEG ? 0 : 8,
	          audioSample,
	          mp4Sample,
	          unit,
	          mdat,
	          moof,
	          firstPTS,
	          firstDTS,
	          lastDTS,
	          pts,
	          dts,
	          ptsnorm,
	          dtsnorm,
	          samples = [],
	          samples0 = [],
	          fillFrame,
	          newStamp,
	          nextAudioPts;

	      track.samples.sort(function (a, b) {
	        return a.pts - b.pts;
	      });
	      samples0 = track.samples;

	      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
	      // for sake of clarity:
	      // consecutive fragments are frags with
	      //  - less than 100ms gaps between new time offset and next expected PTS OR
	      //  - less than 20 audio frames distance
	      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
	      // this helps ensuring audio continuity
	      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

	      nextAudioPts = this.nextAudioPts;
	      contiguous |= samples0.length && nextAudioPts && (Math.abs(timeOffset - nextAudioPts / pesTimeScale) < 0.1 || Math.abs(samples0[0].pts - nextAudioPts - this._initDTS) < 20 * pesFrameDuration);

	      if (!contiguous) {
	        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
	        nextAudioPts = timeOffset * pesTimeScale;
	      }
	      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
	      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
	      // In an effort to prevent this from happening, we inject frames here where there are gaps.
	      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
	      // frame.

	      // only inject/drop audio frames in case time offset is accurate
	      if (accurateTimeOffset && track.isAAC) {
	        for (var i = 0, nextPtsNorm = nextAudioPts; i < samples0.length;) {
	          // First, let's see how far off this frame is from where we expect it to be
	          var sample = samples0[i],
	              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),
	              delta = ptsNorm - nextPtsNorm;

	          // If we're overlapping by more than a duration, drop this sample
	          if (delta <= -pesFrameDuration) {
	            _logger.logger.warn('Dropping 1 audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');
	            samples0.splice(i, 1);
	            track.len -= sample.unit.length;
	            // Don't touch nextPtsNorm or i
	          }
	          // Otherwise, if we're more than a frame away from where we should be, insert missing frames
	          else if (delta >= pesFrameDuration) {
	              var missing = Math.round(delta / pesFrameDuration);
	              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(delta / 90) + ' ms gap.');
	              for (var j = 0; j < missing; j++) {
	                newStamp = nextPtsNorm + initDTS;
	                newStamp = Math.max(newStamp, initDTS);
	                fillFrame = _aac2.default.getSilentFrame(track.channelCount);
	                if (!fillFrame) {
	                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
	                  fillFrame = sample.unit.subarray();
	                }
	                samples0.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
	                track.len += fillFrame.length;
	                nextPtsNorm += pesFrameDuration;
	                i += 1;
	              }

	              // Adjust sample to next expected pts
	              sample.pts = sample.dts = nextPtsNorm + initDTS;
	              nextPtsNorm += pesFrameDuration;
	              i += 1;
	            }
	            // Otherwise, we're within half a frame duration, so just adjust pts
	            else {
	                if (Math.abs(delta) > 0.1 * pesFrameDuration) {
	                  //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + pesFrameDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(pesFrameDuration)}).`);
	                }
	                nextPtsNorm += pesFrameDuration;
	                if (i === 0) {
	                  sample.pts = sample.dts = initDTS + nextAudioPts;
	                } else {
	                  sample.pts = sample.dts = samples0[i - 1].pts + pesFrameDuration;
	                }
	                i += 1;
	              }
	        }
	      }

	      while (samples0.length) {
	        audioSample = samples0.shift();
	        unit = audioSample.unit;
	        pts = audioSample.pts - initDTS;
	        dts = audioSample.dts - initDTS;
	        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
	        // if not first sample
	        if (lastDTS !== undefined) {
	          ptsnorm = ptsNormalize(pts, lastDTS);
	          dtsnorm = ptsNormalize(dts, lastDTS);
	          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);
	        } else {
	          ptsnorm = ptsNormalize(pts, nextAudioPts);
	          dtsnorm = ptsNormalize(dts, nextAudioPts);
	          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / pesTimeScale),
	              numMissingFrames = 0;
	          // if fragment are contiguous, detect hole/overlapping between fragments
	          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
	          if (contiguous && track.isAAC) {
	            // log delta
	            if (_delta) {
	              if (_delta > 0) {
	                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / pesFrameDuration);
	                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
	                if (numMissingFrames > 0) {
	                  fillFrame = _aac2.default.getSilentFrame(track.channelCount);
	                  if (!fillFrame) {
	                    fillFrame = unit.subarray();
	                  }
	                  track.len += numMissingFrames * fillFrame.length;
	                }
	                // if we have frame overlap, overlapping for more than half a frame duraion
	              } else if (_delta < -12) {
	                // drop overlapping audio frames... browser will deal with it
	                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
	                track.len -= unit.byteLength;
	                continue;
	              }
	              // set PTS/DTS to expected PTS/DTS
	              ptsnorm = dtsnorm = nextAudioPts;
	            }
	          }
	          // remember first PTS of our audioSamples, ensure value is positive
	          firstPTS = Math.max(0, ptsnorm);
	          firstDTS = Math.max(0, dtsnorm);
	          if (track.len > 0) {
	            /* concatenate the audio data and construct the mdat in place
	              (need 8 more bytes to fill length and mdat type) */

	            var mdatSize = rawMPEG ? track.len : track.len + 8;
	            try {
	              mdat = new Uint8Array(mdatSize);
	            } catch (err) {
	              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, level: this.level, id: this.id, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
	              return;
	            }
	            if (!rawMPEG) {
	              view = new DataView(mdat.buffer);
	              view.setUint32(0, mdat.byteLength);
	              mdat.set(_mp4Generator2.default.types.mdat, 4);
	            }
	          } else {
	            // no audio samples
	            return;
	          }
	          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
	            newStamp = ptsnorm - (numMissingFrames - _i3) * pesFrameDuration;
	            fillFrame = _aac2.default.getSilentFrame(track.channelCount);
	            if (!fillFrame) {
	              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
	              fillFrame = unit.subarray();
	            }
	            mdat.set(fillFrame, offset);
	            offset += fillFrame.byteLength;
	            mp4Sample = {
	              size: fillFrame.byteLength,
	              cts: 0,
	              duration: 1024,
	              flags: {
	                isLeading: 0,
	                isDependedOn: 0,
	                hasRedundancy: 0,
	                degradPrio: 0,
	                dependsOn: 1
	              }
	            };
	            samples.push(mp4Sample);
	          }
	        }
	        mdat.set(unit, offset);
	        offset += unit.byteLength;
	        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
	        mp4Sample = {
	          size: unit.byteLength,
	          cts: 0,
	          duration: 0,
	          flags: {
	            isLeading: 0,
	            isDependedOn: 0,
	            hasRedundancy: 0,
	            degradPrio: 0,
	            dependsOn: 1
	          }
	        };
	        samples.push(mp4Sample);
	        lastDTS = dtsnorm;
	      }
	      var lastSampleDuration = 0;
	      var nbSamples = samples.length;
	      //set last sample duration as being identical to previous sample
	      if (nbSamples >= 2) {
	        lastSampleDuration = samples[nbSamples - 2].duration;
	        mp4Sample.duration = lastSampleDuration;
	      }
	      if (nbSamples) {
	        // next audio sample PTS should be equal to last sample PTS + duration
	        this.nextAudioPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;
	        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
	        track.len = 0;
	        track.samples = samples;
	        if (rawMPEG) {
	          moof = new Uint8Array();
	        } else {
	          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
	        }
	        track.samples = [];
	        var audioData = {
	          id: this.id,
	          level: this.level,
	          sn: this.sn,
	          data1: moof,
	          data2: mdat,
	          startPTS: firstPTS / pesTimeScale,
	          endPTS: this.nextAudioPts / pesTimeScale,
	          startDTS: firstDTS / pesTimeScale,
	          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,
	          type: 'audio',
	          nb: nbSamples
	        };
	        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
	        return audioData;
	      }
	      return null;
	    }
	  }, {
	    key: 'remuxEmptyAudio',
	    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
	      var pesTimeScale = this.PES_TIMESCALE,
	          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,
	          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
	          nextAudioPts = this.nextAudioPts,


	      // sync with video's timestamp
	      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * pesTimeScale) + this._initDTS,
	          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,

	      // one sample's duration value
	      sampleDuration = 1024,
	          frameDuration = pes2mp4ScaleFactor * sampleDuration,


	      // samples count of this segment's duration
	      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


	      // silent frame
	      silentFrame = _aac2.default.getSilentFrame(track.channelCount);

	      _logger.logger.warn('remux empty Audio');
	      // Can't remux if we can't generate a silent frame...
	      if (!silentFrame) {
	        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
	        return;
	      }

	      var samples = [];
	      for (var i = 0; i < nbSamples; i++) {
	        var stamp = startDTS + i * frameDuration;
	        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
	        track.len += silentFrame.length;
	      }
	      track.samples = samples;

	      this.remuxAudio(track, timeOffset, contiguous);
	    }
	  }, {
	    key: 'remuxID3',
	    value: function remuxID3(track, timeOffset) {
	      var length = track.samples.length,
	          sample;
	      // consume samples
	      if (length) {
	        for (var index = 0; index < length; index++) {
	          sample = track.samples[index];
	          // setting id3 pts, dts to relative time
	          // using this._initPTS and this._initDTS to calculate relative time
	          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
	          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;
	        }
	        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
	          id: this.id,
	          level: this.level,
	          sn: this.sn,
	          samples: track.samples
	        });
	      }

	      track.samples = [];
	      timeOffset = timeOffset;
	    }
	  }, {
	    key: 'remuxText',
	    value: function remuxText(track, timeOffset) {
	      track.samples.sort(function (a, b) {
	        return a.pts - b.pts;
	      });

	      var length = track.samples.length,
	          sample;
	      // consume samples
	      if (length) {
	        for (var index = 0; index < length; index++) {
	          sample = track.samples[index];
	          // setting text pts, dts to relative time
	          // using this._initPTS and this._initDTS to calculate relative time
	          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
	        }
	        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
	          id: this.id,
	          level: this.level,
	          sn: this.sn,
	          samples: track.samples
	        });
	      }

	      track.samples = [];
	      timeOffset = timeOffset;
	    }
	  }, {
	    key: '_PTSNormalize',
	    value: function _PTSNormalize(value, reference) {
	      var offset;
	      if (reference === undefined) {
	        return value;
	      }
	      if (reference < value) {
	        // - 2^33
	        offset = -8589934592;
	      } else {
	        // + 2^33
	        offset = 8589934592;
	      }
	      /* PTS is 33bit (from 0 to 2^33 -1)
	        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
	        PTS looping occured. fill the gap */
	      while (Math.abs(value - reference) > 4294967296) {
	        value += offset;
	      }
	      return value;
	    }
	  }, {
	    key: 'passthrough',
	    get: function get() {
	      return false;
	    }
	  }]);

	  return MP4Remuxer;
	}();

	exports.default = MP4Remuxer;

	},{"26":26,"28":28,"29":29,"37":37,"45":45}],39:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


	var _events = _dereq_(28);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var PassThroughRemuxer = function () {
	  function PassThroughRemuxer(observer, id) {
	    _classCallCheck(this, PassThroughRemuxer);

	    this.observer = observer;
	    this.id = id;
	    this.ISGenerated = false;
	  }

	  _createClass(PassThroughRemuxer, [{
	    key: 'destroy',
	    value: function destroy() {}
	  }, {
	    key: 'insertDiscontinuity',
	    value: function insertDiscontinuity() {}
	  }, {
	    key: 'switchLevel',
	    value: function switchLevel() {
	      this.ISGenerated = false;
	    }
	  }, {
	    key: 'remux',
	    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, rawData) {
	      var observer = this.observer;
	      // generate Init Segment if needed
	      if (!this.ISGenerated) {
	        var tracks = {},
	            data = { id: this.id, tracks: tracks, unique: true },
	            track = videoTrack,
	            codec = track.codec;

	        if (codec) {
	          data.tracks.video = {
	            container: track.container,
	            codec: codec,
	            metadata: {
	              width: track.width,
	              height: track.height
	            }
	          };
	        }

	        track = audioTrack;
	        codec = track.codec;
	        if (codec) {
	          data.tracks.audio = {
	            container: track.container,
	            codec: codec,
	            metadata: {
	              channelCount: track.channelCount
	            }
	          };
	        }
	        this.ISGenerated = true;
	        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
	      }
	      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
	        id: this.id,
	        data1: rawData,
	        startPTS: timeOffset,
	        startDTS: timeOffset,
	        type: 'audiovideo',
	        nb: 1,
	        dropped: 0
	      });
	    }
	  }, {
	    key: 'passthrough',
	    get: function get() {
	      return true;
	    }
	  }]);

	  return PassThroughRemuxer;
	}();

	exports.default = PassThroughRemuxer;

	},{"28":28}],40:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
	var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

	// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

	var AttrList = function () {
	  function AttrList(attrs) {
	    _classCallCheck(this, AttrList);

	    if (typeof attrs === 'string') {
	      attrs = AttrList.parseAttrList(attrs);
	    }
	    for (var attr in attrs) {
	      if (attrs.hasOwnProperty(attr)) {
	        this[attr] = attrs[attr];
	      }
	    }
	  }

	  _createClass(AttrList, [{
	    key: 'decimalInteger',
	    value: function decimalInteger(attrName) {
	      var intValue = parseInt(this[attrName], 10);
	      if (intValue > Number.MAX_SAFE_INTEGER) {
	        return Infinity;
	      }
	      return intValue;
	    }
	  }, {
	    key: 'hexadecimalInteger',
	    value: function hexadecimalInteger(attrName) {
	      if (this[attrName]) {
	        var stringValue = (this[attrName] || '0x').slice(2);
	        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

	        var value = new Uint8Array(stringValue.length / 2);
	        for (var i = 0; i < stringValue.length / 2; i++) {
	          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
	        }
	        return value;
	      } else {
	        return null;
	      }
	    }
	  }, {
	    key: 'hexadecimalIntegerAsNumber',
	    value: function hexadecimalIntegerAsNumber(attrName) {
	      var intValue = parseInt(this[attrName], 16);
	      if (intValue > Number.MAX_SAFE_INTEGER) {
	        return Infinity;
	      }
	      return intValue;
	    }
	  }, {
	    key: 'decimalFloatingPoint',
	    value: function decimalFloatingPoint(attrName) {
	      return parseFloat(this[attrName]);
	    }
	  }, {
	    key: 'enumeratedString',
	    value: function enumeratedString(attrName) {
	      return this[attrName];
	    }
	  }, {
	    key: 'decimalResolution',
	    value: function decimalResolution(attrName) {
	      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
	      if (res === null) {
	        return undefined;
	      }
	      return {
	        width: parseInt(res[1], 10),
	        height: parseInt(res[2], 10)
	      };
	    }
	  }], [{
	    key: 'parseAttrList',
	    value: function parseAttrList(input) {
	      var match,
	          attrs = {};
	      ATTR_LIST_REGEX.lastIndex = 0;
	      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
	        var value = match[2],
	            quote = '"';

	        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
	          value = value.slice(1, -1);
	        }
	        attrs[match[1]] = value;
	      }
	      return attrs;
	    }
	  }]);

	  return AttrList;
	}();

	exports.default = AttrList;

	},{}],41:[function(_dereq_,module,exports){
	"use strict";

	var BinarySearch = {
	    /**
	     * Searches for an item in an array which matches a certain condition.
	     * This requires the condition to only match one item in the array,
	     * and for the array to be ordered.
	     *
	     * @param {Array} list The array to search.
	     * @param {Function} comparisonFunction
	     *      Called and provided a candidate item as the first argument.
	     *      Should return:
	     *          > -1 if the item should be located at a lower index than the provided item.
	     *          > 1 if the item should be located at a higher index than the provided item.
	     *          > 0 if the item is the item you're looking for.
	     *
	     * @return {*} The object if it is found or null otherwise.
	     */
	    search: function search(list, comparisonFunction) {
	        var minIndex = 0;
	        var maxIndex = list.length - 1;
	        var currentIndex = null;
	        var currentElement = null;

	        while (minIndex <= maxIndex) {
	            currentIndex = (minIndex + maxIndex) / 2 | 0;
	            currentElement = list[currentIndex];

	            var comparisonResult = comparisonFunction(currentElement);
	            if (comparisonResult > 0) {
	                minIndex = currentIndex + 1;
	            } else if (comparisonResult < 0) {
	                maxIndex = currentIndex - 1;
	            } else {
	                return currentElement;
	            }
	        }

	        return null;
	    }
	};

	module.exports = BinarySearch;

	},{}],42:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *
	 * This code was ported from the dash.js project at:
	 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
	 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
	 *
	 * The original copyright appears below:
	 *
	 * The copyright in this software is being made available under the BSD License,
	 * included below. This software may be subject to other third party and contributor
	 * rights, including patent rights, and no such rights are granted under this license.
	 *
	 * Copyright (c) 2015-2016, DASH Industry Forum.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *  1. Redistributions of source code must retain the above copyright notice, this
	 *  list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above copyright notice,
	 *  this list of conditions and the following disclaimer in the documentation and/or
	 *  other materials provided with the distribution.
	 *  2. Neither the name of Dash Industry Forum nor the names of its
	 *  contributors may be used to endorse or promote products derived from this software
	 *  without specific prior written permission.
	 *
	 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
	 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
	 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 *  POSSIBILITY OF SUCH DAMAGE.
	 */
	/**
	 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
	 */

	var specialCea608CharsCodes = {
	    0x2a: 0xe1, // lowercase a, acute accent
	    0x5c: 0xe9, // lowercase e, acute accent
	    0x5e: 0xed, // lowercase i, acute accent
	    0x5f: 0xf3, // lowercase o, acute accent
	    0x60: 0xfa, // lowercase u, acute accent
	    0x7b: 0xe7, // lowercase c with cedilla
	    0x7c: 0xf7, // division symbol
	    0x7d: 0xd1, // uppercase N tilde
	    0x7e: 0xf1, // lowercase n tilde
	    0x7f: 0x2588, // Full block
	    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
	    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
	    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
	    0x80: 0xae, // Registered symbol (R)
	    0x81: 0xb0, // degree sign
	    0x82: 0xbd, // 1/2 symbol
	    0x83: 0xbf, // Inverted (open) question mark
	    0x84: 0x2122, // Trademark symbol (TM)
	    0x85: 0xa2, // Cents symbol
	    0x86: 0xa3, // Pounds sterling
	    0x87: 0x266a, // Music 8'th note
	    0x88: 0xe0, // lowercase a, grave accent
	    0x89: 0x20, // transparent space (regular)
	    0x8a: 0xe8, // lowercase e, grave accent
	    0x8b: 0xe2, // lowercase a, circumflex accent
	    0x8c: 0xea, // lowercase e, circumflex accent
	    0x8d: 0xee, // lowercase i, circumflex accent
	    0x8e: 0xf4, // lowercase o, circumflex accent
	    0x8f: 0xfb, // lowercase u, circumflex accent
	    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
	    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
	    0x90: 0xc1, // capital letter A with acute
	    0x91: 0xc9, // capital letter E with acute
	    0x92: 0xd3, // capital letter O with acute
	    0x93: 0xda, // capital letter U with acute
	    0x94: 0xdc, // capital letter U with diaresis
	    0x95: 0xfc, // lowercase letter U with diaeresis
	    0x96: 0x2018, // opening single quote
	    0x97: 0xa1, // inverted exclamation mark
	    0x98: 0x2a, // asterisk
	    0x99: 0x2019, // closing single quote
	    0x9a: 0x2501, // box drawings heavy horizontal
	    0x9b: 0xa9, // copyright sign
	    0x9c: 0x2120, // Service mark
	    0x9d: 0x2022, // (round) bullet
	    0x9e: 0x201c, // Left double quotation mark
	    0x9f: 0x201d, // Right double quotation mark
	    0xa0: 0xc0, // uppercase A, grave accent
	    0xa1: 0xc2, // uppercase A, circumflex
	    0xa2: 0xc7, // uppercase C with cedilla
	    0xa3: 0xc8, // uppercase E, grave accent
	    0xa4: 0xca, // uppercase E, circumflex
	    0xa5: 0xcb, // capital letter E with diaresis
	    0xa6: 0xeb, // lowercase letter e with diaresis
	    0xa7: 0xce, // uppercase I, circumflex
	    0xa8: 0xcf, // uppercase I, with diaresis
	    0xa9: 0xef, // lowercase i, with diaresis
	    0xaa: 0xd4, // uppercase O, circumflex
	    0xab: 0xd9, // uppercase U, grave accent
	    0xac: 0xf9, // lowercase u, grave accent
	    0xad: 0xdb, // uppercase U, circumflex
	    0xae: 0xab, // left-pointing double angle quotation mark
	    0xaf: 0xbb, // right-pointing double angle quotation mark
	    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
	    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
	    0xb0: 0xc3, // Uppercase A, tilde
	    0xb1: 0xe3, // Lowercase a, tilde
	    0xb2: 0xcd, // Uppercase I, acute accent
	    0xb3: 0xcc, // Uppercase I, grave accent
	    0xb4: 0xec, // Lowercase i, grave accent
	    0xb5: 0xd2, // Uppercase O, grave accent
	    0xb6: 0xf2, // Lowercase o, grave accent
	    0xb7: 0xd5, // Uppercase O, tilde
	    0xb8: 0xf5, // Lowercase o, tilde
	    0xb9: 0x7b, // Open curly brace
	    0xba: 0x7d, // Closing curly brace
	    0xbb: 0x5c, // Backslash
	    0xbc: 0x5e, // Caret
	    0xbd: 0x5f, // Underscore
	    0xbe: 0x7c, // Pipe (vertical line)
	    0xbf: 0x223c, // Tilde operator
	    0xc0: 0xc4, // Uppercase A, umlaut
	    0xc1: 0xe4, // Lowercase A, umlaut
	    0xc2: 0xd6, // Uppercase O, umlaut
	    0xc3: 0xf6, // Lowercase o, umlaut
	    0xc4: 0xdf, // Esszett (sharp S)
	    0xc5: 0xa5, // Yen symbol
	    0xc6: 0xa4, // Generic currency sign
	    0xc7: 0x2503, // Box drawings heavy vertical
	    0xc8: 0xc5, // Uppercase A, ring
	    0xc9: 0xe5, // Lowercase A, ring
	    0xca: 0xd8, // Uppercase O, stroke
	    0xcb: 0xf8, // Lowercase o, strok
	    0xcc: 0x250f, // Box drawings heavy down and right
	    0xcd: 0x2513, // Box drawings heavy down and left
	    0xce: 0x2517, // Box drawings heavy up and right
	    0xcf: 0x251b // Box drawings heavy up and left
	};

	/**
	 * Utils
	 */
	var getCharForByte = function getCharForByte(byte) {
	    var charCode = byte;
	    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
	        charCode = specialCea608CharsCodes[byte];
	    }
	    return String.fromCharCode(charCode);
	};

	var NR_ROWS = 15,
	    NR_COLS = 32;
	// Tables to look up row from PAC data
	var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
	var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
	var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
	var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

	var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

	/**
	 * Simple logger class to be able to write with time-stamps and filter on level.
	 */
	var logger = {
	    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
	    time: null,
	    verboseLevel: 0, // Only write errors
	    setTime: function setTime(newTime) {
	        this.time = newTime;
	    },
	    log: function log(severity, msg) {
	        var minLevel = this.verboseFilter[severity];
	        if (this.verboseLevel >= minLevel) {
	            console.log(this.time + ' [' + severity + '] ' + msg);
	        }
	    }
	};

	var numArrayToHexArray = function numArrayToHexArray(numArray) {
	    var hexArray = [];
	    for (var j = 0; j < numArray.length; j++) {
	        hexArray.push(numArray[j].toString(16));
	    }
	    return hexArray;
	};

	var PenState = function () {
	    function PenState(foreground, underline, italics, background, flash) {
	        _classCallCheck(this, PenState);

	        this.foreground = foreground || 'white';
	        this.underline = underline || false;
	        this.italics = italics || false;
	        this.background = background || 'black';
	        this.flash = flash || false;
	    }

	    _createClass(PenState, [{
	        key: 'reset',
	        value: function reset() {
	            this.foreground = 'white';
	            this.underline = false;
	            this.italics = false;
	            this.background = 'black';
	            this.flash = false;
	        }
	    }, {
	        key: 'setStyles',
	        value: function setStyles(styles) {
	            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
	            for (var i = 0; i < attribs.length; i++) {
	                var style = attribs[i];
	                if (styles.hasOwnProperty(style)) {
	                    this[style] = styles[style];
	                }
	            }
	        }
	    }, {
	        key: 'isDefault',
	        value: function isDefault() {
	            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(other) {
	            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
	        }
	    }, {
	        key: 'copy',
	        value: function copy(newPenState) {
	            this.foreground = newPenState.foreground;
	            this.underline = newPenState.underline;
	            this.italics = newPenState.italics;
	            this.background = newPenState.background;
	            this.flash = newPenState.flash;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
	        }
	    }]);

	    return PenState;
	}();

	/**
	 * Unicode character with styling and background.
	 * @constructor
	 */


	var StyledUnicodeChar = function () {
	    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
	        _classCallCheck(this, StyledUnicodeChar);

	        this.uchar = uchar || ' '; // unicode character
	        this.penState = new PenState(foreground, underline, italics, background, flash);
	    }

	    _createClass(StyledUnicodeChar, [{
	        key: 'reset',
	        value: function reset() {
	            this.uchar = ' ';
	            this.penState.reset();
	        }
	    }, {
	        key: 'setChar',
	        value: function setChar(uchar, newPenState) {
	            this.uchar = uchar;
	            this.penState.copy(newPenState);
	        }
	    }, {
	        key: 'setPenState',
	        value: function setPenState(newPenState) {
	            this.penState.copy(newPenState);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(other) {
	            return this.uchar === other.uchar && this.penState.equals(other.penState);
	        }
	    }, {
	        key: 'copy',
	        value: function copy(newChar) {
	            this.uchar = newChar.uchar;
	            this.penState.copy(newChar.penState);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty() {
	            return this.uchar === ' ' && this.penState.isDefault();
	        }
	    }]);

	    return StyledUnicodeChar;
	}();

	/**
	 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
	 * @constructor
	 */


	var Row = function () {
	    function Row() {
	        _classCallCheck(this, Row);

	        this.chars = [];
	        for (var i = 0; i < NR_COLS; i++) {
	            this.chars.push(new StyledUnicodeChar());
	        }
	        this.pos = 0;
	        this.currPenState = new PenState();
	    }

	    _createClass(Row, [{
	        key: 'equals',
	        value: function equals(other) {
	            var equal = true;
	            for (var i = 0; i < NR_COLS; i++) {
	                if (!this.chars[i].equals(other.chars[i])) {
	                    equal = false;
	                    break;
	                }
	            }
	            return equal;
	        }
	    }, {
	        key: 'copy',
	        value: function copy(other) {
	            for (var i = 0; i < NR_COLS; i++) {
	                this.chars[i].copy(other.chars[i]);
	            }
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty() {
	            var empty = true;
	            for (var i = 0; i < NR_COLS; i++) {
	                if (!this.chars[i].isEmpty()) {
	                    empty = false;
	                    break;
	                }
	            }
	            return empty;
	        }

	        /**
	         *  Set the cursor to a valid column.
	         */

	    }, {
	        key: 'setCursor',
	        value: function setCursor(absPos) {
	            if (this.pos !== absPos) {
	                this.pos = absPos;
	            }
	            if (this.pos < 0) {
	                logger.log('ERROR', 'Negative cursor position ' + this.pos);
	                this.pos = 0;
	            } else if (this.pos > NR_COLS) {
	                logger.log('ERROR', 'Too large cursor position ' + this.pos);
	                this.pos = NR_COLS;
	            }
	        }

	        /**
	         * Move the cursor relative to current position.
	         */

	    }, {
	        key: 'moveCursor',
	        value: function moveCursor(relPos) {
	            var newPos = this.pos + relPos;
	            if (relPos > 1) {
	                for (var i = this.pos + 1; i < newPos + 1; i++) {
	                    this.chars[i].setPenState(this.currPenState);
	                }
	            }
	            this.setCursor(newPos);
	        }

	        /**
	         * Backspace, move one step back and clear character.
	         */

	    }, {
	        key: 'backSpace',
	        value: function backSpace() {
	            this.moveCursor(-1);
	            this.chars[this.pos].setChar(' ', this.currPenState);
	        }
	    }, {
	        key: 'insertChar',
	        value: function insertChar(byte) {
	            if (byte >= 0x90) {
	                //Extended char
	                this.backSpace();
	            }
	            var char = getCharForByte(byte);
	            if (this.pos >= NR_COLS) {
	                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
	                return;
	            }
	            this.chars[this.pos].setChar(char, this.currPenState);
	            this.moveCursor(1);
	        }
	    }, {
	        key: 'clearFromPos',
	        value: function clearFromPos(startPos) {
	            var i;
	            for (i = startPos; i < NR_COLS; i++) {
	                this.chars[i].reset();
	            }
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.clearFromPos(0);
	            this.pos = 0;
	            this.currPenState.reset();
	        }
	    }, {
	        key: 'clearToEndOfRow',
	        value: function clearToEndOfRow() {
	            this.clearFromPos(this.pos);
	        }
	    }, {
	        key: 'getTextString',
	        value: function getTextString() {
	            var chars = [];
	            var empty = true;
	            for (var i = 0; i < NR_COLS; i++) {
	                var char = this.chars[i].uchar;
	                if (char !== ' ') {
	                    empty = false;
	                }
	                chars.push(char);
	            }
	            if (empty) {
	                return '';
	            } else {
	                return chars.join('');
	            }
	        }
	    }, {
	        key: 'setPenStyles',
	        value: function setPenStyles(styles) {
	            this.currPenState.setStyles(styles);
	            var currChar = this.chars[this.pos];
	            currChar.setPenState(this.currPenState);
	        }
	    }]);

	    return Row;
	}();

	/**
	 * Keep a CEA-608 screen of 32x15 styled characters
	 * @constructor
	*/


	var CaptionScreen = function () {
	    function CaptionScreen() {
	        _classCallCheck(this, CaptionScreen);

	        this.rows = [];
	        for (var i = 0; i < NR_ROWS; i++) {
	            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
	        }
	        this.currRow = NR_ROWS - 1;
	        this.nrRollUpRows = null;
	        this.reset();
	    }

	    _createClass(CaptionScreen, [{
	        key: 'reset',
	        value: function reset() {
	            for (var i = 0; i < NR_ROWS; i++) {
	                this.rows[i].clear();
	            }
	            this.currRow = NR_ROWS - 1;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(other) {
	            var equal = true;
	            for (var i = 0; i < NR_ROWS; i++) {
	                if (!this.rows[i].equals(other.rows[i])) {
	                    equal = false;
	                    break;
	                }
	            }
	            return equal;
	        }
	    }, {
	        key: 'copy',
	        value: function copy(other) {
	            for (var i = 0; i < NR_ROWS; i++) {
	                this.rows[i].copy(other.rows[i]);
	            }
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty() {
	            var empty = true;
	            for (var i = 0; i < NR_ROWS; i++) {
	                if (!this.rows[i].isEmpty()) {
	                    empty = false;
	                    break;
	                }
	            }
	            return empty;
	        }
	    }, {
	        key: 'backSpace',
	        value: function backSpace() {
	            var row = this.rows[this.currRow];
	            row.backSpace();
	        }
	    }, {
	        key: 'clearToEndOfRow',
	        value: function clearToEndOfRow() {
	            var row = this.rows[this.currRow];
	            row.clearToEndOfRow();
	        }

	        /**
	         * Insert a character (without styling) in the current row.
	         */

	    }, {
	        key: 'insertChar',
	        value: function insertChar(char) {
	            var row = this.rows[this.currRow];
	            row.insertChar(char);
	        }
	    }, {
	        key: 'setPen',
	        value: function setPen(styles) {
	            var row = this.rows[this.currRow];
	            row.setPenStyles(styles);
	        }
	    }, {
	        key: 'moveCursor',
	        value: function moveCursor(relPos) {
	            var row = this.rows[this.currRow];
	            row.moveCursor(relPos);
	        }
	    }, {
	        key: 'setCursor',
	        value: function setCursor(absPos) {
	            logger.log('INFO', 'setCursor: ' + absPos);
	            var row = this.rows[this.currRow];
	            row.setCursor(absPos);
	        }
	    }, {
	        key: 'setPAC',
	        value: function setPAC(pacData, lastOutputScreen) {
	            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
	            var newRow = pacData.row - 1;
	            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
	                newRow = this.nrRollUpRows - 1;
	            }

	            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
	            if (this.nrRollUpRows && this.currRow !== newRow) {
	                //clear all rows first
	                for (var i = 0; i < NR_ROWS; i++) {
	                    this.rows[i].clear();
	                }

	                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
	                //topRowIndex - the start of rows to copy (inclusive index)
	                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
	                //We only copy if the last position was already shown.
	                //We use the cueStartTime value to check this.
	                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
	                if (prevLineTime && prevLineTime < logger.time) {
	                    for (i = 0; i < this.nrRollUpRows; i++) {
	                        this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
	                    }
	                }
	            }

	            this.currRow = newRow;
	            var row = this.rows[this.currRow];
	            if (pacData.indent !== null) {
	                var indent = pacData.indent;
	                var prevPos = Math.max(indent - 1, 0);
	                row.setCursor(pacData.indent);
	                pacData.color = row.chars[prevPos].penState.foreground;
	            }
	            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
	            this.setPen(styles);
	        }

	        /**
	         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
	         */

	    }, {
	        key: 'setBkgData',
	        value: function setBkgData(bkgData) {

	            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
	            this.backSpace();
	            this.setPen(bkgData);
	            this.insertChar(0x20); //Space
	        }
	    }, {
	        key: 'setRollUpRows',
	        value: function setRollUpRows(nrRows) {
	            this.nrRollUpRows = nrRows;
	        }
	    }, {
	        key: 'rollUp',
	        value: function rollUp() {
	            if (this.nrRollUpRows === null) {
	                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
	                return; //Not properly setup
	            }
	            logger.log('TEXT', this.getDisplayText());
	            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
	            var topRow = this.rows.splice(topRowIndex, 1)[0];
	            topRow.clear();
	            this.rows.splice(this.currRow, 0, topRow);
	            logger.log('INFO', 'Rolling up');
	            //logger.log('TEXT', this.get_display_text())
	        }

	        /**
	         * Get all non-empty rows with as unicode text.
	         */

	    }, {
	        key: 'getDisplayText',
	        value: function getDisplayText(asOneRow) {
	            asOneRow = asOneRow || false;
	            var displayText = [];
	            var text = '';
	            var rowNr = -1;
	            for (var i = 0; i < NR_ROWS; i++) {
	                var rowText = this.rows[i].getTextString();
	                if (rowText) {
	                    rowNr = i + 1;
	                    if (asOneRow) {
	                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
	                    } else {
	                        displayText.push(rowText.trim());
	                    }
	                }
	            }
	            if (displayText.length > 0) {
	                if (asOneRow) {
	                    text = '[' + displayText.join(' | ') + ']';
	                } else {
	                    text = displayText.join('\n');
	                }
	            }
	            return text;
	        }
	    }, {
	        key: 'getTextAndFormat',
	        value: function getTextAndFormat() {
	            return this.rows;
	        }
	    }]);

	    return CaptionScreen;
	}();

	//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

	var Cea608Channel = function () {
	    function Cea608Channel(channelNumber, outputFilter) {
	        _classCallCheck(this, Cea608Channel);

	        this.chNr = channelNumber;
	        this.outputFilter = outputFilter;
	        this.mode = null;
	        this.verbose = 0;
	        this.displayedMemory = new CaptionScreen();
	        this.nonDisplayedMemory = new CaptionScreen();
	        this.lastOutputScreen = new CaptionScreen();
	        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
	        this.writeScreen = this.displayedMemory;
	        this.mode = null;
	        this.cueStartTime = null; // Keeps track of where a cue started.
	    }

	    _createClass(Cea608Channel, [{
	        key: 'reset',
	        value: function reset() {
	            this.mode = null;
	            this.displayedMemory.reset();
	            this.nonDisplayedMemory.reset();
	            this.lastOutputScreen.reset();
	            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
	            this.writeScreen = this.displayedMemory;
	            this.mode = null;
	            this.cueStartTime = null;
	            this.lastCueEndTime = null;
	        }
	    }, {
	        key: 'getHandler',
	        value: function getHandler() {
	            return this.outputFilter;
	        }
	    }, {
	        key: 'setHandler',
	        value: function setHandler(newHandler) {
	            this.outputFilter = newHandler;
	        }
	    }, {
	        key: 'setPAC',
	        value: function setPAC(pacData) {
	            this.writeScreen.setPAC(pacData, this.lastOutputScreen);
	        }
	    }, {
	        key: 'setBkgData',
	        value: function setBkgData(bkgData) {
	            this.writeScreen.setBkgData(bkgData);
	        }
	    }, {
	        key: 'setMode',
	        value: function setMode(newMode) {
	            if (newMode === this.mode) {
	                return;
	            }
	            this.mode = newMode;
	            logger.log('INFO', 'MODE=' + newMode);
	            if (this.mode === 'MODE_POP-ON') {
	                this.writeScreen = this.nonDisplayedMemory;
	            } else {
	                this.writeScreen = this.displayedMemory;
	                this.writeScreen.reset();
	                this.lastOutputScreen.reset();
	            }
	            if (this.mode !== 'MODE_ROLL-UP') {
	                this.displayedMemory.nrRollUpRows = null;
	                this.nonDisplayedMemory.nrRollUpRows = null;
	            }
	            this.mode = newMode;
	        }
	    }, {
	        key: 'insertChars',
	        value: function insertChars(chars) {
	            for (var i = 0; i < chars.length; i++) {
	                this.writeScreen.insertChar(chars[i]);
	            }
	            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
	            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
	            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
	                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
	                this.outputDataUpdate();
	            }
	        }
	    }, {
	        key: 'ccRCL',
	        value: function ccRCL() {
	            // Resume Caption Loading (switch mode to Pop On)
	            logger.log('INFO', 'RCL - Resume Caption Loading');
	            this.setMode('MODE_POP-ON');
	        }
	    }, {
	        key: 'ccBS',
	        value: function ccBS() {
	            // BackSpace
	            logger.log('INFO', 'BS - BackSpace');
	            if (this.mode === 'MODE_TEXT') {
	                return;
	            }
	            this.writeScreen.backSpace();
	            if (this.writeScreen === this.displayedMemory) {
	                this.outputDataUpdate();
	            }
	        }
	    }, {
	        key: 'ccAOF',
	        value: function ccAOF() {
	            // Reserved (formerly Alarm Off)
	            return;
	        }
	    }, {
	        key: 'ccAON',
	        value: function ccAON() {
	            // Reserved (formerly Alarm On)
	            return;
	        }
	    }, {
	        key: 'ccDER',
	        value: function ccDER() {
	            // Delete to End of Row
	            logger.log('INFO', 'DER- Delete to End of Row');
	            this.writeScreen.clearToEndOfRow();
	            this.outputDataUpdate();
	        }
	    }, {
	        key: 'ccRU',
	        value: function ccRU(nrRows) {
	            //Roll-Up Captions-2,3,or 4 Rows
	            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
	            this.writeScreen = this.displayedMemory;
	            this.setMode('MODE_ROLL-UP');
	            this.writeScreen.setRollUpRows(nrRows);
	        }
	    }, {
	        key: 'ccFON',
	        value: function ccFON() {
	            //Flash On
	            logger.log('INFO', 'FON - Flash On');
	            this.writeScreen.setPen({ flash: true });
	        }
	    }, {
	        key: 'ccRDC',
	        value: function ccRDC() {
	            // Resume Direct Captioning (switch mode to PaintOn)
	            logger.log('INFO', 'RDC - Resume Direct Captioning');
	            this.setMode('MODE_PAINT-ON');
	        }
	    }, {
	        key: 'ccTR',
	        value: function ccTR() {
	            // Text Restart in text mode (not supported, however)
	            logger.log('INFO', 'TR');
	            this.setMode('MODE_TEXT');
	        }
	    }, {
	        key: 'ccRTD',
	        value: function ccRTD() {
	            // Resume Text Display in Text mode (not supported, however)
	            logger.log('INFO', 'RTD');
	            this.setMode('MODE_TEXT');
	        }
	    }, {
	        key: 'ccEDM',
	        value: function ccEDM() {
	            // Erase Displayed Memory
	            logger.log('INFO', 'EDM - Erase Displayed Memory');
	            this.displayedMemory.reset();
	            this.outputDataUpdate();
	        }
	    }, {
	        key: 'ccCR',
	        value: function ccCR() {
	            // Carriage Return
	            logger.log('CR - Carriage Return');
	            this.writeScreen.rollUp();
	            this.outputDataUpdate();
	        }
	    }, {
	        key: 'ccENM',
	        value: function ccENM() {
	            //Erase Non-Displayed Memory
	            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
	            this.nonDisplayedMemory.reset();
	        }
	    }, {
	        key: 'ccEOC',
	        value: function ccEOC() {
	            //End of Caption (Flip Memories)
	            logger.log('INFO', 'EOC - End Of Caption');
	            if (this.mode === 'MODE_POP-ON') {
	                var tmp = this.displayedMemory;
	                this.displayedMemory = this.nonDisplayedMemory;
	                this.nonDisplayedMemory = tmp;
	                this.writeScreen = this.nonDisplayedMemory;
	                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
	            }
	            this.outputDataUpdate();
	        }
	    }, {
	        key: 'ccTO',
	        value: function ccTO(nrCols) {
	            // Tab Offset 1,2, or 3 columns
	            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
	            this.writeScreen.moveCursor(nrCols);
	        }
	    }, {
	        key: 'ccMIDROW',
	        value: function ccMIDROW(secondByte) {
	            // Parse MIDROW command
	            var styles = { flash: false };
	            styles.underline = secondByte % 2 === 1;
	            styles.italics = secondByte >= 0x2e;
	            if (!styles.italics) {
	                var colorIndex = Math.floor(secondByte / 2) - 0x10;
	                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
	                styles.foreground = colors[colorIndex];
	            } else {
	                styles.foreground = 'white';
	            }
	            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
	            this.writeScreen.setPen(styles);
	        }
	    }, {
	        key: 'outputDataUpdate',
	        value: function outputDataUpdate() {
	            var t = logger.time;
	            if (t === null) {
	                return;
	            }
	            if (this.outputFilter) {
	                if (this.outputFilter.updateData) {
	                    this.outputFilter.updateData(t, this.displayedMemory);
	                }
	                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
	                    // Start of a new cue
	                    this.cueStartTime = t;
	                } else {
	                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
	                        if (this.outputFilter.newCue) {
	                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
	                        }
	                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
	                    }
	                }
	                this.lastOutputScreen.copy(this.displayedMemory);
	            }
	        }
	    }, {
	        key: 'cueSplitAtTime',
	        value: function cueSplitAtTime(t) {
	            if (this.outputFilter) {
	                if (!this.displayedMemory.isEmpty()) {
	                    if (this.outputFilter.newCue) {
	                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
	                    }
	                    this.cueStartTime = t;
	                }
	            }
	        }
	    }]);

	    return Cea608Channel;
	}();

	var Cea608Parser = function () {
	    function Cea608Parser(field, out1, out2) {
	        _classCallCheck(this, Cea608Parser);

	        this.field = field || 1;
	        this.outputs = [out1, out2];
	        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
	        this.currChNr = -1; // Will be 1 or 2
	        this.lastCmdA = null; // First byte of last command
	        this.lastCmdB = null; // Second byte of last command
	        this.bufferedData = [];
	        this.startTime = null;
	        this.lastTime = null;
	        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
	    }

	    _createClass(Cea608Parser, [{
	        key: 'getHandler',
	        value: function getHandler(index) {
	            return this.channels[index].getHandler();
	        }
	    }, {
	        key: 'setHandler',
	        value: function setHandler(index, newHandler) {
	            this.channels[index].setHandler(newHandler);
	        }

	        /**
	         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
	         */

	    }, {
	        key: 'addData',
	        value: function addData(t, byteList) {
	            var cmdFound,
	                a,
	                b,
	                charsFound = false;

	            this.lastTime = t;
	            logger.setTime(t);

	            for (var i = 0; i < byteList.length; i += 2) {
	                a = byteList[i] & 0x7f;
	                b = byteList[i + 1] & 0x7f;
	                if (a === 0 && b === 0) {
	                    this.dataCounters.padding += 2;
	                    continue;
	                } else {
	                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
	                }
	                cmdFound = this.parseCmd(a, b);
	                if (!cmdFound) {
	                    cmdFound = this.parseMidrow(a, b);
	                }
	                if (!cmdFound) {
	                    cmdFound = this.parsePAC(a, b);
	                }
	                if (!cmdFound) {
	                    cmdFound = this.parseBackgroundAttributes(a, b);
	                }
	                if (!cmdFound) {
	                    charsFound = this.parseChars(a, b);
	                    if (charsFound) {
	                        if (this.currChNr && this.currChNr >= 0) {
	                            var channel = this.channels[this.currChNr - 1];
	                            channel.insertChars(charsFound);
	                        } else {
	                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
	                        }
	                    }
	                }
	                if (cmdFound) {
	                    this.dataCounters.cmd += 2;
	                } else if (charsFound) {
	                    this.dataCounters.char += 2;
	                } else {
	                    this.dataCounters.other += 2;
	                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
	                }
	            }
	        }

	        /**
	         * Parse Command.
	         * @returns {Boolean} Tells if a command was found
	         */

	    }, {
	        key: 'parseCmd',
	        value: function parseCmd(a, b) {
	            var chNr = null;

	            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
	            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
	            if (!(cond1 || cond2)) {
	                return false;
	            }

	            if (a === this.lastCmdA && b === this.lastCmdB) {
	                this.lastCmdA = null;
	                this.lastCmdB = null; // Repeated commands are dropped (once)
	                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
	                return true;
	            }

	            if (a === 0x14 || a === 0x17) {
	                chNr = 1;
	            } else {
	                chNr = 2; // (a === 0x1C || a=== 0x1f)
	            }

	            var channel = this.channels[chNr - 1];

	            if (a === 0x14 || a === 0x1C) {
	                if (b === 0x20) {
	                    channel.ccRCL();
	                } else if (b === 0x21) {
	                    channel.ccBS();
	                } else if (b === 0x22) {
	                    channel.ccAOF();
	                } else if (b === 0x23) {
	                    channel.ccAON();
	                } else if (b === 0x24) {
	                    channel.ccDER();
	                } else if (b === 0x25) {
	                    channel.ccRU(2);
	                } else if (b === 0x26) {
	                    channel.ccRU(3);
	                } else if (b === 0x27) {
	                    channel.ccRU(4);
	                } else if (b === 0x28) {
	                    channel.ccFON();
	                } else if (b === 0x29) {
	                    channel.ccRDC();
	                } else if (b === 0x2A) {
	                    channel.ccTR();
	                } else if (b === 0x2B) {
	                    channel.ccRTD();
	                } else if (b === 0x2C) {
	                    channel.ccEDM();
	                } else if (b === 0x2D) {
	                    channel.ccCR();
	                } else if (b === 0x2E) {
	                    channel.ccENM();
	                } else if (b === 0x2F) {
	                    channel.ccEOC();
	                }
	            } else {
	                //a == 0x17 || a == 0x1F
	                channel.ccTO(b - 0x20);
	            }
	            this.lastCmdA = a;
	            this.lastCmdB = b;
	            this.currChNr = chNr;
	            return true;
	        }

	        /**
	         * Parse midrow styling command
	         * @returns {Boolean}
	         */

	    }, {
	        key: 'parseMidrow',
	        value: function parseMidrow(a, b) {
	            var chNr = null;

	            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
	                if (a === 0x11) {
	                    chNr = 1;
	                } else {
	                    chNr = 2;
	                }
	                if (chNr !== this.currChNr) {
	                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
	                    return false;
	                }
	                var channel = this.channels[chNr - 1];
	                channel.ccMIDROW(b);
	                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
	                return true;
	            }
	            return false;
	        }
	        /**
	         * Parse Preable Access Codes (Table 53).
	         * @returns {Boolean} Tells if PAC found
	         */

	    }, {
	        key: 'parsePAC',
	        value: function parsePAC(a, b) {

	            var chNr = null;
	            var row = null;

	            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
	            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
	            if (!(case1 || case2)) {
	                return false;
	            }

	            if (a === this.lastCmdA && b === this.lastCmdB) {
	                this.lastCmdA = null;
	                this.lastCmdB = null;
	                return true; // Repeated commands are dropped (once)
	            }

	            chNr = a <= 0x17 ? 1 : 2;

	            if (0x40 <= b && b <= 0x5F) {
	                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
	            } else {
	                // 0x60 <= b <= 0x7F
	                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
	            }
	            var pacData = this.interpretPAC(row, b);
	            var channel = this.channels[chNr - 1];
	            channel.setPAC(pacData);
	            this.lastCmdA = a;
	            this.lastCmdB = b;
	            this.currChNr = chNr;
	            return true;
	        }

	        /**
	         * Interpret the second byte of the pac, and return the information.
	         * @returns {Object} pacData with style parameters.
	         */

	    }, {
	        key: 'interpretPAC',
	        value: function interpretPAC(row, byte) {
	            var pacIndex = byte;
	            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

	            if (byte > 0x5F) {
	                pacIndex = byte - 0x60;
	            } else {
	                pacIndex = byte - 0x40;
	            }
	            pacData.underline = (pacIndex & 1) === 1;
	            if (pacIndex <= 0xd) {
	                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
	            } else if (pacIndex <= 0xf) {
	                pacData.italics = true;
	                pacData.color = 'white';
	            } else {
	                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
	            }
	            return pacData; // Note that row has zero offset. The spec uses 1.
	        }

	        /**
	         * Parse characters.
	         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
	         */

	    }, {
	        key: 'parseChars',
	        value: function parseChars(a, b) {

	            var channelNr = null,
	                charCodes = null,
	                charCode1 = null;

	            if (a >= 0x19) {
	                channelNr = 2;
	                charCode1 = a - 8;
	            } else {
	                channelNr = 1;
	                charCode1 = a;
	            }
	            if (0x11 <= charCode1 && charCode1 <= 0x13) {
	                // Special character
	                var oneCode = b;
	                if (charCode1 === 0x11) {
	                    oneCode = b + 0x50;
	                } else if (charCode1 === 0x12) {
	                    oneCode = b + 0x70;
	                } else {
	                    oneCode = b + 0x90;
	                }
	                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
	                charCodes = [oneCode];
	            } else if (0x20 <= a && a <= 0x7f) {
	                charCodes = b === 0 ? [a] : [a, b];
	            }
	            if (charCodes) {
	                var hexCodes = numArrayToHexArray(charCodes);
	                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
	                this.lastCmdA = null;
	                this.lastCmdB = null;
	            }
	            return charCodes;
	        }

	        /**
	        * Parse extended background attributes as well as new foreground color black.
	        * @returns{Boolean} Tells if background attributes are found
	        */

	    }, {
	        key: 'parseBackgroundAttributes',
	        value: function parseBackgroundAttributes(a, b) {
	            var bkgData, index, chNr, channel;

	            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
	            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
	            if (!(case1 || case2)) {
	                return false;
	            }
	            bkgData = {};
	            if (a === 0x10 || a === 0x18) {
	                index = Math.floor((b - 0x20) / 2);
	                bkgData.background = backgroundColors[index];
	                if (b % 2 === 1) {
	                    bkgData.background = bkgData.background + '_semi';
	                }
	            } else if (b === 0x2d) {
	                bkgData.background = 'transparent';
	            } else {
	                bkgData.foreground = 'black';
	                if (b === 0x2f) {
	                    bkgData.underline = true;
	                }
	            }
	            chNr = a < 0x18 ? 1 : 2;
	            channel = this.channels[chNr - 1];
	            channel.setBkgData(bkgData);
	            this.lastCmdA = null;
	            this.lastCmdB = null;
	            return true;
	        }

	        /**
	         * Reset state of parser and its channels.
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            for (var i = 0; i < this.channels.length; i++) {
	                if (this.channels[i]) {
	                    this.channels[i].reset();
	                }
	            }
	            this.lastCmdA = null;
	            this.lastCmdB = null;
	        }

	        /**
	         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
	         */

	    }, {
	        key: 'cueSplitAtTime',
	        value: function cueSplitAtTime(t) {
	            for (var i = 0; i < this.channels.length; i++) {
	                if (this.channels[i]) {
	                    this.channels[i].cueSplitAtTime(t);
	                }
	            }
	        }
	    }]);

	    return Cea608Parser;
	}();

	exports.default = Cea608Parser;

	},{}],43:[function(_dereq_,module,exports){
	'use strict';

	var Cues = {

	  newCue: function newCue(track, startTime, endTime, captionScreen) {
	    var row;
	    var cue;
	    var indenting;
	    var indent;
	    var text;
	    var VTTCue = window.VTTCue || window.TextTrackCue;

	    for (var r = 0; r < captionScreen.rows.length; r++) {
	      row = captionScreen.rows[r];
	      indenting = true;
	      indent = 0;
	      text = '';

	      if (!row.isEmpty()) {
	        for (var c = 0; c < row.chars.length; c++) {
	          if (row.chars[c].uchar.match(/\s/) && indenting) {
	            indent++;
	          } else {
	            text += row.chars[c].uchar;
	            indenting = false;
	          }
	        }
	        //To be used for cleaning-up orphaned roll-up captions
	        row.cueStartTime = startTime;
	        cue = new VTTCue(startTime, endTime, text.trim());

	        if (indent >= 16) {
	          indent--;
	        } else {
	          indent++;
	        }

	        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
	        // also, drop line 1 since it's to close to the top
	        if (navigator.userAgent.match(/Firefox\//)) {
	          cue.line = r + 1;
	        } else {
	          cue.line = r > 7 ? r - 2 : r + 1;
	        }
	        cue.align = 'left';
	        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
	        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
	        track.addCue(cue);
	      }
	    }
	  }

	};

	module.exports = Cues;

	},{}],44:[function(_dereq_,module,exports){
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * compute an Exponential Weighted moving average
	 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
	 *  - heavily inspired from shaka-player
	 */

	var EWMA = function () {

	  //  About half of the estimated value will be from the last |halfLife| samples by weight.
	  function EWMA(halfLife) {
	    _classCallCheck(this, EWMA);

	    // Larger values of alpha expire historical data more slowly.
	    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
	    this.estimate_ = 0;
	    this.totalWeight_ = 0;
	  }

	  _createClass(EWMA, [{
	    key: "sample",
	    value: function sample(weight, value) {
	      var adjAlpha = Math.pow(this.alpha_, weight);
	      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
	      this.totalWeight_ += weight;
	    }
	  }, {
	    key: "getTotalWeight",
	    value: function getTotalWeight() {
	      return this.totalWeight_;
	    }
	  }, {
	    key: "getEstimate",
	    value: function getEstimate() {
	      if (this.alpha_) {
	        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
	        return this.estimate_ / zeroFactor;
	      } else {
	        return this.estimate_;
	      }
	    }
	  }]);

	  return EWMA;
	}();

	exports.default = EWMA;

	},{}],45:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function noop() {}

	var fakeLogger = {
	  trace: noop,
	  debug: noop,
	  log: noop,
	  warn: noop,
	  info: noop,
	  error: noop
	};

	var exportedLogger = fakeLogger;

	/*globals self: false */

	//let lastCallTime;
	// function formatMsgWithTimeInfo(type, msg) {
	//   const now = Date.now();
	//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
	//   lastCallTime = now;
	//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
	//   return msg;
	// }

	function formatMsg(type, msg) {
	  msg = '[' + type + '] > ' + msg;
	  return msg;
	}

	function consolePrintFn(type) {
	  var func = self.console[type];
	  if (func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      if (args[0]) {
	        args[0] = formatMsg(type, args[0]);
	      }
	      func.apply(self.console, args);
	    };
	  }
	  return noop;
	}

	function exportLoggerFunctions(debugConfig) {
	  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    functions[_key2 - 1] = arguments[_key2];
	  }

	  functions.forEach(function (type) {
	    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
	  });
	}

	var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
	  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
	    exportLoggerFunctions(debugConfig,
	    // Remove out from list here to hard-disable a log-level
	    //'trace',
	    'debug', 'log', 'info', 'warn', 'error');
	    // Some browsers don't allow to use bind on console object anyway
	    // fallback to default if needed
	    try {
	      exportedLogger.log();
	    } catch (e) {
	      exportedLogger = fakeLogger;
	    }
	  } else {
	    exportedLogger = fakeLogger;
	  }
	};

	var logger = exports.logger = exportedLogger;

	},{}],46:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *  TimeRanges to string helper
	 */

	var TimeRanges = function () {
	  function TimeRanges() {
	    _classCallCheck(this, TimeRanges);
	  }

	  _createClass(TimeRanges, null, [{
	    key: 'toString',
	    value: function toString(r) {
	      var log = '',
	          len = r.length;
	      for (var i = 0; i < len; i++) {
	        log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
	      }
	      return log;
	    }
	  }]);

	  return TimeRanges;
	}();

	exports.default = TimeRanges;

	},{}],47:[function(_dereq_,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

	var _logger = _dereq_(45);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var XhrLoader = function () {
	  function XhrLoader(config) {
	    _classCallCheck(this, XhrLoader);

	    if (config && config.xhrSetup) {
	      this.xhrSetup = config.xhrSetup;
	    }
	  }

	  _createClass(XhrLoader, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.abort();
	      this.loader = null;
	    }
	  }, {
	    key: 'abort',
	    value: function abort() {
	      var loader = this.loader;
	      if (loader && loader.readyState !== 4) {
	        this.stats.aborted = true;
	        loader.abort();
	      }

	      window.clearTimeout(this.requestTimeout);
	      this.requestTimeout = null;
	      window.clearTimeout(this.retryTimeout);
	      this.retryTimeout = null;
	    }
	  }, {
	    key: 'load',
	    value: function load(context, config, callbacks) {
	      this.context = context;
	      this.config = config;
	      this.callbacks = callbacks;
	      this.stats = { trequest: performance.now(), retry: 0 };
	      this.retryDelay = config.retryDelay;
	      this.loadInternal();
	    }
	  }, {
	    key: 'loadInternal',
	    value: function loadInternal() {
	      var xhr,
	          context = this.context;

	      if (typeof XDomainRequest !== 'undefined') {
	        xhr = this.loader = new XDomainRequest();
	      } else {
	        xhr = this.loader = new XMLHttpRequest();
	      }

	      xhr.onreadystatechange = this.readystatechange.bind(this);
	      xhr.onprogress = this.loadprogress.bind(this);

	      xhr.open('GET', context.url, true);

	      if (context.rangeEnd) {
	        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
	      }
	      xhr.responseType = context.responseType;
	      var stats = this.stats;
	      stats.tfirst = 0;
	      stats.loaded = 0;
	      if (this.xhrSetup) {
	        this.xhrSetup(xhr, context.url);
	      }
	      // setup timeout before we perform request
	      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
	      xhr.send();
	    }
	  }, {
	    key: 'readystatechange',
	    value: function readystatechange(event) {
	      var xhr = event.currentTarget,
	          readyState = xhr.readyState,
	          stats = this.stats,
	          context = this.context,
	          config = this.config;

	      // don't proceed if xhr has been aborted
	      if (stats.aborted) {
	        return;
	      }

	      // in any case clear the current xhrs timeout
	      window.clearTimeout(this.requestTimeout);

	      // HEADERS_RECEIVED
	      if (readyState >= 2) {
	        if (stats.tfirst === 0) {
	          stats.tfirst = Math.max(performance.now(), stats.trequest);
	          // reset timeout to total timeout duration minus the time it took to receive headers
	          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout - (stats.tfirst - stats.trequest));
	        }
	        if (readyState === 4) {
	          var status = xhr.status;
	          // http status between 200 to 299 are all successful
	          if (status >= 200 && status < 300) {
	            stats.tload = Math.max(stats.tfirst, performance.now());
	            var data = void 0,
	                len = void 0;
	            if (context.responseType === 'arraybuffer') {
	              data = xhr.response;
	              len = data.byteLength;
	            } else {
	              data = xhr.responseText;
	              len = data.length;
	            }
	            stats.loaded = stats.total = len;
	            var response = { url: xhr.responseURL, data: data };
	            this.callbacks.onSuccess(response, stats, context);
	          } else {
	            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
	            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
	              _logger.logger.error(status + ' while loading ' + context.url);
	              this.callbacks.onError({ code: status, text: xhr.statusText }, context);
	            } else {
	              // retry
	              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
	              // aborts and resets internal state
	              this.destroy();
	              // schedule retry
	              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
	              // set exponential backoff
	              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
	              stats.retry++;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'loadtimeout',
	    value: function loadtimeout() {
	      _logger.logger.warn('timeout while loading ' + this.context.url);
	      this.callbacks.onTimeout(this.stats, this.context);
	    }
	  }, {
	    key: 'loadprogress',
	    value: function loadprogress(event) {
	      var stats = this.stats;
	      stats.loaded = event.loaded;
	      if (event.lengthComputable) {
	        stats.total = event.total;
	      }
	      var onProgress = this.callbacks.onProgress;
	      if (onProgress) {
	        // last args is to provide on progress data
	        onProgress(stats, this.context, null);
	      }
	    }
	  }]);

	  return XhrLoader;
	}();

	exports.default = XhrLoader;

	},{"45":45}]},{},[33])(33)
	});
	//# sourceMappingURL=hls.js.map


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are **not** supported.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = isEqual;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(187)(module)))

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(189);

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _events = __webpack_require__(5);

	var _events2 = _interopRequireDefault(_events);

	var _playback = __webpack_require__(60);

	var _playback2 = _interopRequireDefault(_playback);

	var _mediator = __webpack_require__(53);

	var _mediator2 = _interopRequireDefault(_mediator);

	var _styler = __webpack_require__(15);

	var _styler2 = _interopRequireDefault(_styler);

	var _template = __webpack_require__(17);

	var _template2 = _interopRequireDefault(_template);

	var _style = __webpack_require__(190);

	var _style2 = _interopRequireDefault(_style);

	var _youtube = __webpack_require__(191);

	var _youtube2 = _interopRequireDefault(_youtube);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var YoutubePlayback = function (_Playback) {
	    _inherits(YoutubePlayback, _Playback);

	    _createClass(YoutubePlayback, [{
	        key: 'name',
	        get: function get() {
	            return 'youtube_playback';
	        }
	    }, {
	        key: 'template',
	        get: function get() {
	            return (0, _template2.default)(_youtube2.default);
	        }
	    }, {
	        key: 'attributes',
	        get: function get() {
	            return {
	                'data-youtube-playback': '',
	                class: 'zplayer-youtube-playback',
	                id: this.cid
	            };
	        }
	    }]);

	    function YoutubePlayback(options) {
	        _classCallCheck(this, YoutubePlayback);

	        var _this = _possibleConstructorReturn(this, _Playback.call(this, options));

	        _this.settings = {
	            seekEnabled: true,
	            left: ['playpause', 'position', 'duration'],
	            default: ['seekbar'],
	            right: ['fullscreen', 'volume', 'hd-indicator']
	        };

	        _mediator2.default.on(_events2.default.PLAYER_RESIZE, _this.updateSize, _this);
	        _this.$el.hide();
	        return _this;
	    }

	    YoutubePlayback.prototype.setupYoutubePlayer = function setupYoutubePlayer() {
	        if (window.YT && window.YT.Player) {
	            this.embedYoutubePlayer();
	        } else {
	            this.embedYoutubeApiScript();
	        }
	    };

	    YoutubePlayback.prototype.embedYoutubeApiScript = function embedYoutubeApiScript() {
	        var _this2 = this;

	        var script = document.createElement('script');
	        script.setAttribute('type', 'text/javascript');
	        script.setAttribute('async', 'async');
	        script.setAttribute('src', 'https://www.youtube.com/iframe_api');
	        document.body.appendChild(script);
	        window.onYouTubeIframeAPIReady = function () {
	            return _this2.embedYoutubePlayer();
	        };
	    };

	    YoutubePlayback.prototype.embedYoutubePlayer = function embedYoutubePlayer() {
	        var _this3 = this;

	        var playerVars = {
	            controls: 0,
	            autoplay: this.options.autoPlay ? 1 : 0,
	            disablekb: 1,
	            rel: 0,
	            enablejsapi: 1,
	            iv_load_policy: 3,
	            modestbranding: 1,
	            showinfo: 0,
	            html5: 1,
	            playsinline: this.options.playInline ? 1 : 0
	        };
	        if (this.options.youtubePlaylist) {
	            playerVars.listType = 'playlist';
	            playerVars.list = this.options.youtubePlaylist;
	        }
	        this.player = new YT.Player('yt' + this.cid, {
	            videoId: this.options.source,
	            playerVars: playerVars,
	            width: '100%',
	            height: '100%',
	            events: {
	                onReady: function onReady() {
	                    return _this3.ready();
	                },
	                onStateChange: function onStateChange(event) {
	                    return _this3.stateChange(event);
	                },
	                onPlaybackQualityChange: function onPlaybackQualityChange(event) {
	                    return _this3.qualityChange(event);
	                }
	            }
	        });
	    };

	    YoutubePlayback.prototype.updateSize = function updateSize() {
	        this.player && this.player.setSize(this.$el.width(), this.$el.height());
	    };

	    YoutubePlayback.prototype.ready = function ready() {
	        this._ready = true;
	        this.$el.hide();
	        if (this.options.autoPlay === true) {
	            this.play();
	        }
	        this.trigger(_events2.default.PB_READY);
	    };

	    YoutubePlayback.prototype.qualityChange = function qualityChange(event) {
	        this.trigger(_events2.default.PB_HIGHDEFINITIONUPDATE);
	    };

	    YoutubePlayback.prototype.stateChange = function stateChange(event) {
	        switch (event.data) {
	            case YT.PlayerState.PLAYING:
	                this.$el.show();
	                this.enableMediaControl();
	                this.trigger(_events2.default.PB_PLAY);
	                break;
	            case YT.PlayerState.ENDED:
	                if (this.options.youtubeShowRelated) {
	                    this.disableMediaControl();
	                } else {
	                    this.trigger(_events2.default.PB_ENDED);
	                    this.$el.hide();
	                }
	                break;
	            default:
	                this.$el.show();
	                break;
	        }
	    };

	    YoutubePlayback.prototype.play = function play() {
	        var _this4 = this;

	        if (this._ready) {
	            this._progressTimer = this._progressTimer || setInterval(function () {
	                return _this4.progress();
	            }, 100);
	            this._timeupdateTimer = setInterval(function () {
	                return _this4.timeupdate();
	            }, 100);
	            this.player.playVideo();
	            this.trigger(_events2.default.PB_PLAY);
	            this.trigger(_events2.default.PB_BUFFERFULL);
	        } else {}
	    };

	    YoutubePlayback.prototype.pause = function pause() {
	        clearInterval(this._timeupdateTimer);
	        this._timeupdateTimer = null;
	        this.player && this.player.pauseVideo();
	        this.trigger(_events2.default.PB_PAUSE);
	    };

	    YoutubePlayback.prototype.seek = function seek(position) {
	        if (!this.player) return;
	        this.player.seekTo(position);
	    };

	    YoutubePlayback.prototype.volume = function volume(value) {
	        this.player && this.player.setVolume(value);
	    };

	    YoutubePlayback.prototype.progress = function progress() {
	        var buffered = this.player.getDuration() * this.player.getVideoLoadedFraction();
	        this.trigger(_events2.default.PB_PROGRESS, 0, buffered, this.player.getDuration());
	    };

	    YoutubePlayback.prototype.timeupdate = function timeupdate() {
	        this.trigger(_events2.default.PB_TIMEUPDATE, { current: this.player.getCurrentTime(), total: this.player.getDuration() });
	    };

	    YoutubePlayback.prototype.isPlaying = function isPlaying() {
	        return this.player && this._timeupdateTimer && this.player.getPlayerState() == YT.PlayerState.PLAYING;
	    };

	    YoutubePlayback.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
	        return this.player && !!this.player.getPlaybackQuality().match(/^hd\d+/);
	    };

	    YoutubePlayback.prototype.getDuration = function getDuration() {
	        var duration = 0;
	        if (this.player) {
	            duration = this.player.getDuration();
	        }
	        return duration;
	    };

	    YoutubePlayback.prototype.disableMediaControl = function disableMediaControl() {
	        this.$el.css({ 'pointer-events': 'auto' });
	        this.trigger(_events2.default.PB_MEDIACONTROL_DISABLE);
	    };

	    YoutubePlayback.prototype.enableMediaControl = function enableMediaControl() {
	        this.$el.css({ 'pointer-events': 'none' });
	        this.trigger(_events2.default.PB_MEDIACONTROL_ENABLE);
	    };

	    YoutubePlayback.prototype.render = function render() {
	        this.$el.html(this.template({ id: 'yt' + this.cid }));
	        var style = _styler2.default.getStyleFor(_style2.default, { baseUrl: this.options.baseUrl });
	        this.$el.append(style);
	        this.setupYoutubePlayer();
	        return this;
	    };

	    return YoutubePlayback;
	}(_playback2.default);

	YoutubePlayback.canPlay = function (source) {
	    return true;
	};

	module.exports = window.YoutubePlayback = YoutubePlayback;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(25)();
	// imports


	// module
	exports.push([module.id, ".zplayer-youtube-playback {\n  height: 100%; }\n", ""]);

	// exports


/***/ },
/* 191 */
/***/ function(module, exports) {

	module.exports = "<div id=\"<%=id%>\"></div>\n";

/***/ }
/******/ ])
});
;